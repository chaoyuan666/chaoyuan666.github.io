<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SPARQL</title>
      <link href="/2022/07/07/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E6%8E%A2%E7%A9%B6GeoSPARQL/"/>
      <url>/2022/07/07/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E6%8E%A2%E7%A9%B6GeoSPARQL/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/sinat_36226553/article/details/116308818">探究GeoSPARQL（一）</a></p></blockquote><p>前缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns#</span><br><span class="line">owl: http://www.w3.org/2002/07/owl#</span><br><span class="line">geo: http://www.opengis.net/ont/geosparql#</span><br><span class="line">rdfs: http://www.w3.org/2000/01/rdf-schema#</span><br><span class="line">sf: http://www.opengis.net/ont/sf#</span><br><span class="line">wd: http://www.wikidata.org/wiki/</span><br><span class="line">wkg: http://www.worldkg.org/resource/</span><br><span class="line">wkgs: http://www.worldkg.org/schema/</span><br><span class="line">uom: http://www.opengis.net/def/uom/OGC/1.0/</span><br></pre></td></tr></table></figure><h1 id="SPARQL"><a href="#SPARQL" class="headerlink" title="SPARQL"></a>SPARQL</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">prefix wkgs: <span class="operator">&lt;</span>http:<span class="operator">/</span><span class="operator">/</span>www.worldkg.org<span class="operator">/</span>schema<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"># 查询有多少个三元组</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="operator">&lt;</span>http:<span class="operator">/</span><span class="operator">/</span>WorldKG.knowledge.graph<span class="operator">&gt;</span> <span class="keyword">where</span> &#123;?s ?r ?o&#125;</span><br><span class="line"></span><br><span class="line"># 查询顶级类下边有多少子类</span><br><span class="line"><span class="keyword">SELECT</span> ?subClass <span class="keyword">WHERE</span> &#123; ?subClass rdfs:subClassOf wkgs:WKGObject . &#125;</span><br><span class="line"></span><br><span class="line"># 查询多少个Top<span class="operator">-</span>level classes  <span class="operator">/</span><span class="operator">/</span> <span class="number">33</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(?subClass) <span class="keyword">WHERE</span> &#123; ?subClass rdfs:subClassOf wkgs:WKGObject . &#125;</span><br><span class="line"></span><br><span class="line"># 查询多少个sub<span class="operator">-</span>classes</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(?class)  <span class="keyword">WHERE</span> &#123;</span><br><span class="line">  ?class1 rdfs:subClassOf wkgs:WKGObject .</span><br><span class="line">  ?class rdfs:subClassOf ?class1 .</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ?class1 (<span class="built_in">COUNT</span>(?resource) <span class="keyword">AS</span> ?count) <span class="keyword">WHERE</span> &#123;</span><br><span class="line">  ?class1 rdfs:subClassOf wkgs:WKGObject .</span><br><span class="line">  ?class rdfs:subClassOf ?class1 .</span><br><span class="line">  ?resource rdf:type ?class.</span><br><span class="line">  &#125; <span class="keyword">GROUP</span> <span class="keyword">BY</span> ?class</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">DESC</span>(?count)</span><br><span class="line"></span><br><span class="line"># Waterway 的子类以及它们的使用频率</span><br><span class="line"><span class="keyword">SELECT</span> ?class (<span class="built_in">COUNT</span>(?resource) <span class="keyword">AS</span> ?count) <span class="keyword">WHERE</span> &#123;</span><br><span class="line">  ?class rdfs:subClassOf wkgs:Waterway .</span><br><span class="line">  ?resource rdf:type ?class.</span><br><span class="line">  &#125; <span class="keyword">GROUP</span> <span class="keyword">BY</span> ?class</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">DESC</span>(?count)</span><br><span class="line"></span><br><span class="line"># 查询多少个Top<span class="operator">-</span>level classes  <span class="operator">/</span><span class="operator">/</span> <span class="number">33</span></span><br><span class="line"><span class="keyword">SELECT</span> count?class) (<span class="built_in">COUNT</span>(?resource) <span class="keyword">AS</span> ?count) <span class="keyword">WHERE</span> &#123;</span><br><span class="line">  ?class rdfs:subClassOf wkgs:WKGObject .</span><br><span class="line">  ?resource rdf:type ?class.</span><br><span class="line">  &#125; <span class="keyword">GROUP</span> <span class="keyword">BY</span> ?class</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">DESC</span>(?count)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 待归类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openlink virtuoso</title>
      <link href="/2022/07/07/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Openlink%20virtuoso/"/>
      <url>/2022/07/07/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Openlink%20virtuoso/</url>
      
        <content type="html"><![CDATA[<p><strong>Openlink virtuoso软件：</strong></p><blockquote><p><a href="https://blog.csdn.net/Mr_TangGuo/article/details/111586075">Linux 服务器上安装 Virtuoso 数据库 并导入数据（超详细）</a></p><p><a href="https://blog.csdn.net/wtgwtg_/article/details/107963602">Openlink virtuoso安装与加载知识图谱</a></p></blockquote><p>三个文件，还是读取到了：822,369,423</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开isql</span></span><br><span class="line">../bin/isql-v 1111 dba dba</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载数据目录</span></span><br><span class="line">ld_dir_all(&#x27;/home/maocy/WorldKG&#x27;, &#x27;*.ttl&#x27;, &#x27;http://WorldKG.knowledge.graph&#x27;);</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录是否导入成功</span></span><br><span class="line">select * from DB.DBA.load_list;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据读取</span></span><br><span class="line">rdf_loader_run();</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询读取到的数量</span></span><br><span class="line">SPARQL select count(*) from &lt;http://WorldKG.knowledge.graph&gt; where &#123;?s ?r ?o&#125;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除导入目录，避免重复导入</span></span><br><span class="line">DELETE FROM DB.DBA.LOAD_LIST;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存</span></span><br><span class="line">checkpoint;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出</span></span><br><span class="line">exit;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台启动 virtuoso</span></span><br><span class="line">nohup ../bin/virtuoso-t -fd &gt; log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 待归类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache Jena</title>
      <link href="/2022/07/07/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Apache%20Jena%20%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%81/"/>
      <url>/2022/07/07/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Apache%20Jena%20%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Apache-Jena"><a href="#Apache-Jena" class="headerlink" title="Apache Jena"></a>Apache Jena</h1><p>最近在使用Apache Jena读取RDF数据，这里的坑太多了~ 。下边介绍两种安装方式，希望我能让你少走点坑。</p><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/liangcha007/article/details/124644434">https://blog.csdn.net/liangcha007/article/details/124644434</a></p></blockquote><h2 id="1-Docker-方式安装（超简单！）"><a href="#1-Docker-方式安装（超简单！）" class="headerlink" title="1.  Docker 方式安装（超简单！）"></a>1.  Docker 方式安装（超简单！）</h2><p><em>（注意：如果对于Docker不太熟悉，只加载小文件的话可以考虑！文件太大的话，建议还是算了，如果很熟悉怎么使用Docker的当我没说。。。）</em></p><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/qq_37912886/article/details/118962380?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-118962380-blog-117360643.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-118962380-blog-117360643.pc_relevant_default&amp;utm_relevant_index=1">https://blog.csdn.net/qq_37912886/article/details/118962380?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-118962380-blog-117360643.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-118962380-blog-117360643.pc_relevant_default&amp;utm_relevant_index=1</a></p></blockquote><p>1、安装好虚拟机，配置虚拟机的网卡为桥接模式。注意要桥接的网卡是有线网，而且不需要拨号。（因为无线网一般有密码，桥接到无线网卡的话不方便输入wifi密码，导致链接上去也无法上网。网络配置参考链接）</p><p>2、安装curl（安装前最好先更新一下源）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><p> 安装Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>从仓库pull jena-fuseki镜像（没有指定版本号，默认最新版）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull stain/jena-fuseki</span><br></pre></td></tr></table></figure><p>3、启动jena-fuseki</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p 3030:3030 -e &quot;ADMIN_PASSWORD=test@jena&quot; stain/jena-fuseki</span><br></pre></td></tr></table></figure><p>上述命令设置的服务端口为:3030<br>账号：admin，密码：test@jena</p><p>至此，可以在虚拟机的浏览器里输入localhost:3030进入jena页面。</p><blockquote><p>PS：有时候也会出现 <strong>-&gt;</strong> Windows下Docker启动容器时，端口被占用错误。解决办法：<a href="https://www.cnblogs.com/uncmd/p/16056993.html">https://www.cnblogs.com/uncmd/p/16056993.html</a></p></blockquote><hr><h2 id="2-传统方式安装"><a href="#2-传统方式安装" class="headerlink" title="2. 传统方式安装"></a>2. 传统方式安装</h2><p><em>（如果上边这个方法用不了，那就老老实实去装电脑上吧！哈哈哈！）</em></p><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/setella/article/details/103381537">https://blog.csdn.net/setella/article/details/103381537</a></p></blockquote><p>自己看上边链接哈！等我有时间的话我再给你们搬一遍，哈哈哈！下边都是记录我按照那个安装时出现的问题哈。</p><p><img src="https://pic.imgdb.cn/item/62986e460947543129102630.jpg"></p><p>打开失败~，那还能怎么办，查日志呗。</p><p><img src="https://pic.imgdb.cn/item/62986eb9094754312910d01c.jpg"></p><p>原来是java版本的问题，55代表jdk11。Jena官网其实有说明的！</p><blockquote><p>安装java的方式也给你们整理出来了（多版本jdk管理）：<a href="https://blog.csdn.net/qq_42148563/article/details/124668739">https://blog.csdn.net/qq_42148563/article/details/124668739</a></p></blockquote><p>按照上边的安装好了之后，发现能够正常运行，但是我居然访问不了！（我是在服务器上部署的，没出现的不用管哈！）</p><p>网页上显示：</p><p> HTTP status: “403”, message: Forbidden</p><p>修改Fuseki 配置文件（一般放置在/run/configuration下），注释掉访问的限制！</p><p>jena不分系统的，linux下运行bin下！！！  bat是window！！！</p><p><img src="https://pic.imgdb.cn/item/629877d109475431291d11da.jpg"></p><p><img src="https://pic.imgdb.cn/item/62988c36094754312939ba0b.jpg"></p><p>加载数据：</p><p>也可直接加载压缩数据如ttl.gz!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tdbloader --loc=/home/maocy/jena/jena/tdb /home/maocy/jena/jena/data/planet_osm.ttl</span><br></pre></td></tr></table></figure><p>运行服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  ./fuseki-server --loc=/home/maocy/jena/jena/tdbs  /worldKG1.0</span><br></pre></td></tr></table></figure><hr><p>后记：</p><p>使用Sparql进行对源文件直接查询。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sparql --data=/home/maocy/jena/jena/data/planet_osm.ttl --query=/home/maocy/jena/jena/data/test.rq</span><br></pre></td></tr></table></figure><p>运行了20分钟，超出了java的堆栈。数据集确实太大了。。。放弃这种方法，继续尝试。</p><p><img src="https://pic.imgdb.cn/item/62988c36094754312939ba0b.jpg"></p><p>WARN  riot            :: [line: 853542064, col: 36] Unicode replacement character U+FFFD in string</p><p>这个问题，貌似是编码问题。经过搜索相关资料发现，可能是因为数据集有乱码，导致jena报出了警告！</p><p>数据集乱码排查。</p><p><img src="https://pic.imgdb.cn/item/62988cf709475431293ab526.jpg"></p><p>注意：jena报错的行号是从1开始索引的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 待归档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令</title>
      <link href="/2022/07/05/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/05/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><blockquote><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/cxZQgb6Ag0dLrja_5JJjUA">https://mp.weixin.qq.com/s/cxZQgb6Ag0dLrja_5JJjUA</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 待归档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPARQL endpoint 查询超时</title>
      <link href="/2022/06/28/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/SPARQL%20endpoint%20%E6%9F%A5%E8%AF%A2%E8%B6%85%E6%97%B6/"/>
      <url>/2022/06/28/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/SPARQL%20endpoint%20%E6%9F%A5%E8%AF%A2%E8%B6%85%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="SPARQL-endpoint-查询超时"><a href="#SPARQL-endpoint-查询超时" class="headerlink" title="SPARQL endpoint 查询超时"></a>SPARQL endpoint 查询超时</h1><h2 id="DBpedia：三元组的限制"><a href="#DBpedia：三元组的限制" class="headerlink" title="DBpedia：三元组的限制"></a>DBpedia：三元组的限制</h2><p> <a href="http://www.openlinksw.com/virtuoso">OpenLink Virtuoso</a></p><blockquote><p><a href="https://lists.w3.org/Archives/Public/public-lod/2011Aug/0028.html">https://lists.w3.org/Archives/Public/public-lod/2011Aug/0028.html</a></p></blockquote><p>根据以下设置，<a href="http://dbpedia.org/sparql">http://dbpedia.org/sparql</a> 端点对您可以建立的连接数/秒以及对结果集和查询时间的限制都有速率限制：</p><p>   [SPARQL]<br>   ResultSetMaxRows           = 2000<br>   MaxQueryExecutionTime      = 120<br>   MaxQueryCostEstimationTime = 1500</p><p>这些是为了确保每个人都有平等的机会从 dbpedia.org 获取引用数据，并防止编写错误的查询/机器人。</p><p>您可以使用以下选项来绕过这些限制：</p><ol><li><p>使用 LIMIT 和 OFFSET 关键字</p><p>您可以告诉 SPARQL 查询返回部分结果集以及要跳过的记录数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ?s where &#123; ?s a ?o &#125;</span><br><span class="line">LIMIT 1000 OFFSET 2000</span><br></pre></td></tr></table></figure></li><li><p>在您自己的网络中设置 dbpedia 数据库</p><p>dbpedia 项目提供完整的数据集，因此您可以使用 Virtuoso Open Source Edition 在功能强大的机器上设置自己的安装。</p></li><li><p>使用 Amazon EC2 设置预配置的 Virtuoso + 数据库安装（不是免费的）</p><p>See: <a href="http://www.openlinksw.com/dataspace/dav/wiki/Main/VirtAWSDBpedia351C">http://www.openlinksw.com/dataspace/dav/wiki/Main/VirtAWSDBpedia351C</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 待归档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL server实验</title>
      <link href="/2022/06/28/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/SQL%20Server/"/>
      <url>/2022/06/28/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/SQL%20Server/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-Server-2017"><a href="#SQL-Server-2017" class="headerlink" title="SQL Server 2017"></a>SQL Server 2017</h1><blockquote><p>使用Docker安装sqlServer：<a href="https://blog.csdn.net/weixin_45486510/article/details/122212379">https://blog.csdn.net/weixin_45486510/article/details/122212379</a></p><p>Windows10下Docker安装SQL Server启动失败解决方案：<a href="https://blog.csdn.net/yzj_xiaoyue/article/details/93969788">https://blog.csdn.net/yzj_xiaoyue/article/details/93969788</a></p><p>Navicat 15 破解安装：<a href="https://mp.weixin.qq.com/s/j5dhWGB7eTOmAPECpxBSzw">https://mp.weixin.qq.com/s/j5dhWGB7eTOmAPECpxBSzw</a></p></blockquote><h2 id="Docker-部署-SQL-Server-2017"><a href="#Docker-部署-SQL-Server-2017" class="headerlink" title="Docker 部署 SQL Server 2017"></a>Docker 部署 SQL Server 2017</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 docker 镜像</span></span><br><span class="line">docker pull mcr.microsoft.com/mssql/server:2017-latest</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> win系统 双引号 ，linux使用 单引号  1433端口为SQL所采用的，不要更改！</span></span><br><span class="line">docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;SA_PASSWORD=Password@&quot;  -p 4400:1433 --name sqlserver -d mcr.microsoft.com/mssql/server:2017-latest  </span><br></pre></td></tr></table></figure><h2 id="Docker-内访问-SQL-Server"><a href="#Docker-内访问-SQL-Server" class="headerlink" title="Docker 内访问 SQL Server"></a>Docker 内访问 SQL Server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it sqlserver /bin/bash</span><br><span class="line"></span><br><span class="line">/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &quot;Password@&quot;</span><br></pre></td></tr></table></figure><p>Navicat连接SQL server</p><blockquote><p>Navicat连接SQL server详细步骤：<a href="https://blog.csdn.net/liqz666/article/details/107813530">https://blog.csdn.net/liqz666/article/details/107813530</a></p></blockquote><p>navicat 连接十分麻烦。。。</p><p>SQL server 数据库<strong>默认</strong>是不允许被一些其他图形化界面连接上的，所以如果需要想要连接，必须要进行SQL Server 网络配置TCP端口，以及在防火墙里配置1433端口的出站和 入站规则。（放弃…）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建 design_db 数据库</span><br><span class="line"><span class="keyword">create</span> database design_db</span><br><span class="line"></span><br><span class="line"># 查看所有数据库</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> sys.Databases</span><br><span class="line">go</span><br><span class="line"></span><br><span class="line"># 使用 design_db 数据库，创建 Student 表</span><br><span class="line">use design_db</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> tabele Student</span><br><span class="line">(</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">primary</span> key <span class="keyword">identity</span>(<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">Name <span class="type">varchar</span>(<span class="number">50</span>)</span><br><span class="line">)</span><br><span class="line">go</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 待归档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用命令</title>
      <link href="/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it hexo /bin/bash</span><br><span class="line"></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d // 一定要先 clean，防止灵异事件发生</span><br></pre></td></tr></table></figure><h2 id="启动-virtuoso"><a href="#启动-virtuoso" class="headerlink" title="启动 virtuoso"></a>启动 virtuoso</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">virtuoso/virtuoso-opensource/database目录下，后台启动 virtuoso</span>  </span><br><span class="line">nohup ../bin/virtuoso-t -fd &gt; log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 使用</title>
      <link href="/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Docker/"/>
      <url>/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Docker/</url>
      
        <content type="html"><![CDATA[<p><strong>Docker</strong> 包括三个基本概念</p><ul><li><strong>镜像</strong>（<code>Image</code>）</li><li><strong>容器</strong>（<code>Container</code>）</li><li><strong>仓库</strong>（<code>Repository</code>）</li></ul><blockquote><p>参考：<a href="https://yeasy.gitbook.io/docker_practice/basic_concept">https://yeasy.gitbook.io/docker_practice/basic_concept</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog 入门</title>
      <link href="/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><blockquote><p><a href="https://blog.csdn.net/qq_39196431/article/details/123797279">https://blog.csdn.net/qq_39196431/article/details/123797279</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get update -y</span><br><span class="line">apt-get upgrade -y</span><br><span class="line"></span><br><span class="line">apt install git</span><br></pre></td></tr></table></figure><h4 id="ubuntu-解决tab无法自动补全"><a href="#ubuntu-解决tab无法自动补全" class="headerlink" title="ubuntu 解决tab无法自动补全"></a>ubuntu 解决tab无法自动补全</h4><blockquote><p><a href="https://blog.csdn.net/u012849539/article/details/119965164">https://blog.csdn.net/u012849539/article/details/119965164</a></p></blockquote><h4 id="docker进入容器命令"><a href="#docker进入容器命令" class="headerlink" title="docker进入容器命令"></a>docker进入容器命令</h4><blockquote><p><a href="https://blog.csdn.net/m0_67393827/article/details/124174418">https://blog.csdn.net/m0_67393827/article/details/124174418</a></p></blockquote><h4 id="linux环境安装nvm"><a href="#linux环境安装nvm" class="headerlink" title="linux环境安装nvm"></a>linux环境安装nvm</h4><blockquote><p><a href="http://www.manongjc.com/detail/29-fwamcbugdjljgip.html">http://www.manongjc.com/detail/29-fwamcbugdjljgip.html</a></p><p>nvm使用<br><a href="https://blog.csdn.net/qq285744011/article/details/120779124">https://blog.csdn.net/qq285744011/article/details/120779124</a><br><a href="https://blog.csdn.net/zjjcchina/article/details/122298335">https://blog.csdn.net/zjjcchina/article/details/122298335</a></p></blockquote><h4 id="linux生成ssh"><a href="#linux生成ssh" class="headerlink" title="linux生成ssh"></a>linux生成ssh</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;571xxx303@qq.com&quot;</span><br></pre></td></tr></table></figure><h4 id="Git问题：解决“ssh-connect-to-host-github-com-port-22-Connection-timed-out”"><a href="#Git问题：解决“ssh-connect-to-host-github-com-port-22-Connection-timed-out”" class="headerlink" title="Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”"></a>Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</h4><blockquote><p><a href="https://blog.csdn.net/weixin_41287260/article/details/124368189">https://blog.csdn.net/weixin_41287260/article/details/124368189</a>   方法2</p></blockquote><h4 id="Git问题：gnutls-handshake-failed-The-TLS-connection-was-non-properly-terminated-错误解决"><a href="#Git问题：gnutls-handshake-failed-The-TLS-connection-was-non-properly-terminated-错误解决" class="headerlink" title="Git问题：gnutls_handshake() failed: The TLS connection was non-properly terminated. 错误解决"></a>Git问题：gnutls_handshake() failed: The TLS connection was non-properly terminated. 错误解决</h4><blockquote><p><a href="https://blog.csdn.net/u013895878/article/details/123724019">https://blog.csdn.net/u013895878/article/details/123724019</a></p></blockquote><h4 id="Failed-to-connect-to-github-com-port-443-Connection-refused问题解决"><a href="#Failed-to-connect-to-github-com-port-443-Connection-refused问题解决" class="headerlink" title="Failed to connect to github.com port 443: Connection refused问题解决"></a>Failed to connect to github.com port 443: Connection refused问题解决</h4><blockquote><p><a href="https://blog.csdn.net/weixin_44442186/article/details/124979085">https://blog.csdn.net/weixin_44442186/article/details/124979085</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加 140.82.112.3 github.com</span></span><br></pre></td></tr></table></figure><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装Hexo</span><br><span class="line">npm install -g hexo</span><br><span class="line">hexo init # 初始化hexo</span><br><span class="line">hexo g #生成</span><br><span class="line">hexo s #启动服务</span><br></pre></td></tr></table></figure><h4 id="ubuntu换清华源"><a href="#ubuntu换清华源" class="headerlink" title="ubuntu换清华源"></a>ubuntu换清华源</h4><blockquote><p><a href="https://blog.csdn.net/kp19373771/article/details/115983815">https://blog.csdn.net/kp19373771/article/details/115983815</a></p></blockquote><h4 id="docker-使用-（不可行）"><a href="#docker-使用-（不可行）" class="headerlink" title="docker 使用 （不可行）"></a>docker 使用 （不可行）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a &quot;mcy&quot; -m &quot;hexo&quot; f84a3936482a hexo:v0</span><br><span class="line">docker exec -it 44fc0f0582d9 /bin/bash</span><br><span class="line">docker run --name hexo -p 4000:4000 hexo:v0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=666 -v D:/blogs:/blog --net=host  hexo:v0</span><br></pre></td></tr></table></figure><h4 id="docker-使用-（可行）"><a href="#docker-使用-（可行）" class="headerlink" title="docker 使用 （可行）"></a>docker 使用 （可行）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name hexo -p 4000:4000  -v D:/blogs:/blog  ubuntu:18.04</span><br><span class="line">docker exec -it hexo /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>安装git </p><p><a href="https://blog.csdn.net/qq_39196431/article/details/123797279">https://blog.csdn.net/qq_39196431/article/details/123797279</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apt-get update -y</span><br><span class="line">apt-get upgrade -y</span><br><span class="line"></span><br><span class="line">apt install git</span><br><span class="line">apt install vim</span><br><span class="line"></span><br><span class="line">vim /etc/bash.bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo 自动部署</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">butterfly主题</span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装本地搜索插件</span></span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装置顶插件</span></span><br><span class="line">npm install hexo-generator-index --save</span><br></pre></td></tr></table></figure><h4 id="docker-容器备份"><a href="#docker-容器备份" class="headerlink" title="docker 容器备份"></a>docker 容器备份</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">docker commit  -p 57b11527a2d4 hexo_backup</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://wenku.baidu.com/view/0283acc31ae8b8f67c1cfad6195f312b3169eb7c.html">https://wenku.baidu.com/view/0283acc31ae8b8f67c1cfad6195f312b3169eb7c.html</a></p></blockquote><h4 id="butterfly主题配置"><a href="#butterfly主题配置" class="headerlink" title="butterfly主题配置"></a>butterfly主题配置</h4><blockquote><p><a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言</title>
      <link href="/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/go/"/>
      <url>/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/go/</url>
      
        <content type="html"><![CDATA[<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><hr><blockquote><p>参考教程：<a href="https://tour.go-zh.org/welcome/1">https://tour.go-zh.org/welcome/1</a></p></blockquote><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h2><h3 id="1-1-包、变量和函数"><a href="#1-1-包、变量和函数" class="headerlink" title="1.1 包、变量和函数"></a>1.1 包、变量和函数</h3><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h4><p>就类似于c中的常量（固定不变），名字以大写字母开头，那么它就是<strong>已导出的</strong>。“未导出”的名字在该包外均无法访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(math.pi)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上述代码输出错误。应该改为<code>math.Pi</code></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数可以没有参数或接受多个参数。类型在变量名 <strong>之后</strong>。(<a href="https://blog.go-zh.org/gos-declaration-syntax">为何和c家族不一样！</a>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h4><p>函数可以返回任意数量的返回值。<code>swap</code> 函数返回了两个字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := swap(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world hello</span><br></pre></td></tr></table></figure><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p><p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p><p>没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 <code>直接</code> 返回。</p><p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。</p><p>就像在这个例子中看到的一样，<code>var</code> 语句可以出现在包或函数级别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 false false false</span><br></pre></td></tr></table></figure><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>变量声明可以包含初始值，每个变量对应一个。</p><p>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line">fmt.Println(i, j, c, python, java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 true false no!</span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p><p><strong>函数外</strong>的每个语句都必须以<strong>关键字</strong>开始（<code>var</code>, <code>func</code> 等等），因此 <code>:=</code> 结构<strong>不能</strong>在函数外使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">k := <span class="number">3</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(i, j, k, c, python, java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>Go 的基本类型有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line"></span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">int  int8  int16  int32  int64</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">byte // uint8 的别名</span><br><span class="line"></span><br><span class="line">rune // int32 的别名</span><br><span class="line">    // 表示一个 Unicode 码点</span><br><span class="line"></span><br><span class="line">float32 float64</span><br><span class="line"></span><br><span class="line">complex64 complex128</span><br></pre></td></tr></table></figure><p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/cmplx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ToBe   <span class="type">bool</span>       = <span class="literal">false</span></span><br><span class="line">MaxInt <span class="type">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">z      <span class="type">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, ToBe, ToBe)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, MaxInt, MaxInt)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, z, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type: bool Value: false</span><br><span class="line">Type: uint64 Value: 18446744073709551615</span><br><span class="line">Type: complex128 Value: (2+3i)</span><br></pre></td></tr></table></figure><h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h4><p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p><p>零值是：</p><ul><li>数值类型为 <code>0</code>，</li><li>布尔类型为 <code>false</code>，</li><li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %v %v %q\n&quot;</span>, i, f, b, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 false &quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p><p>一些关于数值的转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure><p>或者，更加简单的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="type">float64</span>(i)</span><br><span class="line">u := <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure><p>与 C 不同的是，Go 在不同类型的项之间赋值时<strong>需要显式转换</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = math.Sqrt(<span class="type">float64</span>(x*x + y*y))</span><br><span class="line"><span class="keyword">var</span> z <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br><span class="line">fmt.Println(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p><p>当右值声明了类型时，新变量的类型与其相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line">j := i // j 也是一个 int</span><br></pre></td></tr></table></figure><p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := 42           // int</span><br><span class="line">f := 3.142        // float64</span><br><span class="line">g := 0.867 + 0.5i // complex128</span><br></pre></td></tr></table></figure><p>尝试修改示例代码中 <code>v</code> 的初始值，并观察它是如何影响类型的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := <span class="number">42</span> <span class="comment">// 修改这里！</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;v is of type %T\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v is of type int</span><br></pre></td></tr></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p><p>常量可以是字符、字符串、布尔值或数值。</p><p>常量不能用 <code>:=</code> 语法声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)</span><br><span class="line">fmt.Println(<span class="string">&quot;Happy&quot;</span>, Pi, <span class="string">&quot;Day&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, Truth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello 世界</span><br><span class="line">Happy 3.14 Day</span><br><span class="line">Go rules? true</span><br></pre></td></tr></table></figure><h4 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h4><p>数值常量是高精度的 <strong>值</strong>。</p><p>一个未指定类型的常量由上下文来决定其类型。</p><p>再尝试一下输出 <code>needInt(Big)</code> 吧。</p><p>（<code>int</code> 类型最大可以存储一个 64 位的整数，有时会更小。）</p><p>（<code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class="line"><span class="comment">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class="line">Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"><span class="comment">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class="line">Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(needInt(Small))</span><br><span class="line">fmt.Println(needFloat(Small))</span><br><span class="line">fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">21</span><br><span class="line">0.2</span><br><span class="line">1.2676506002282295e+29</span><br></pre></td></tr></table></figure><h3 id="1-2-流程控制语句"><a href="#1-2-流程控制语句" class="headerlink" title="1.2 流程控制语句"></a>1.2 流程控制语句</h3><p>for、if、else、switch、defer</p><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>Go 只有一种循环结构：<code>for</code> 循环。</p><p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p><ul><li>初始化语句：在第一次迭代前执行</li><li>条件表达式：在每次迭代前求值</li><li>后置语句：在每次迭代的结尾执行</li></ul><p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p><p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p><p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化语句和后置语句是可选的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1024</span></span><br></pre></td></tr></table></figure><h4 id="for-是-Go-中的-“while”"><a href="#for-是-Go-中的-“while”" class="headerlink" title="for 是 Go 中的 “while”"></a>for 是 Go 中的 “while”</h4><p>此时你可以去掉分号，因为 C 的 <code>while</code> 在 Go 中叫做 <code>for</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1024</span></span><br></pre></td></tr></table></figure><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.4142135623730951 2i</span></span><br></pre></td></tr></table></figure><h4 id="if-的简短语句"><a href="#if-的简短语句" class="headerlink" title="if 的简短语句"></a>if 的简短语句</h4><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p><p>该语句声明的变量作用域仅在 <code>if</code> 之内。</p><p>（在最后的 <code>return</code> 语句处使用 <code>v</code> 看看。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9 20</span></span><br></pre></td></tr></table></figure><h4 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if 和 else"></a>if 和 else</h4><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p><p>（在 <code>main</code> 的 <code>fmt.Println</code> 调用开始前，两次对 <code>pow</code> 的调用均已执行并返回其各自的结果。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%g &gt;= %g\n&quot;</span>, v, lim)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里开始就不能使用 v 了</span></span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 27 &gt;= 20</span></span><br><span class="line"><span class="comment">// 9 20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="练习：循环与函数"><a href="#练习：循环与函数" class="headerlink" title="练习：循环与函数"></a>练习：循环与函数</h4><p>为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。</p><p>计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z -= (z*z - x) / (2*z)</span><br></pre></td></tr></table></figure><p>重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。</p><p>在提供的 <code>func Sqrt</code> 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。 要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 …）， 你得到的答案是如何逼近结果的，猜测提升的速度有多快。</p><p>提示：用类型转换或浮点数语法来声明并初始化一个浮点数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z := 1.0</span><br><span class="line">z := float64(1)</span><br></pre></td></tr></table></figure><p>然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。 尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 <a href="https://go-zh.org/pkg/math/#Sqrt">math.Sqrt</a> 接近吗？</p><p>（<em>注：</em> 如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离， 除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。 这种通用方法叫做<a href="https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿法</a>。 它对很多函数，特别是平方根而言非常有效。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">z := <span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> math.Abs(z*z-x) &gt; <span class="number">1e-10</span> &#123;</span><br><span class="line">z -= (z*z - x) / (<span class="number">2</span> * z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;牛顿法求平方根:Sqrt(10) = &quot;</span>, Sqrt(<span class="number">10</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;库函数求平方根:Sqrt(10) = &quot;</span>, math.Sqrt(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//牛顿法求平方根:Sqrt(10) =  3.1622776601683795</span></span><br><span class="line"><span class="comment">//库函数求平方根:Sqrt(10) =  3.1622776601683795</span></span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p><p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Go runs on Linux.</span></span><br></pre></td></tr></table></figure><h4 id="switch-的求值顺序"><a href="#switch-的求值顺序" class="headerlink" title="switch 的求值顺序"></a>switch 的求值顺序</h4><p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p><p>（例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch i &#123;</span><br><span class="line">case 0:</span><br><span class="line">case f():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>i==0</code> 时 <code>f</code> 不会被调用。）</p><p><em>注意：</em> Go 练习场中的时间总是从 2009-11-10 23:00:00 UTC 开始，该值的意义留给读者去发现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;When&#x27;s Saturday?&quot;</span>)</span><br><span class="line">today := time.Now().Weekday()</span><br><span class="line"><span class="keyword">switch</span> time.Saturday &#123;</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">0</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Today.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Tomorrow.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;In two days.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Too far away.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//When&#x27;s Saturday?</span></span><br><span class="line"><span class="comment">//Too far away.</span></span><br></pre></td></tr></table></figure><h4 id="没有条件的-switch"><a href="#没有条件的-switch" class="headerlink" title="没有条件的 switch"></a>没有条件的 switch</h4><p>没有条件的 switch 同 <code>switch true</code> 一样。</p><p>这种形式能将一长串 if-then-else 写得更加清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good evening.</span></span><br></pre></td></tr></table></figure><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>defer 语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br></pre></td></tr></table></figure><h4 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a>defer 栈</h4><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p><p>更多关于 defer 语句的信息，请阅读<a href="http://blog.go-zh.org/defer-panic-and-recover">此博文</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">counting</span></span><br><span class="line"><span class="comment">done</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-3-更多类型：struct、slice-和映射"><a href="#1-3-更多类型：struct、slice-和映射" class="headerlink" title="1.3 更多类型：struct、slice 和映射"></a>1.3 更多类型：struct、slice 和映射</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>Go 拥有指针。指针保存了值的内存地址。</p><p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p *int</span><br></pre></td></tr></table></figure><p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := 42</span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure><p><code>*</code> 操作符表示指针指向的底层值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(*p) // 通过指针 p 读取 i</span><br><span class="line">*p = 21         // 通过指针 p 设置 i</span><br></pre></td></tr></table></figure><p>这也就是通常所说的“间接引用”或“重定向”。</p><p>与 C 不同，Go 没有指针运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">p := &amp;i         <span class="comment">// 指向 i</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 通过指针读取 i 的值</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针设置 i 的值</span></span><br><span class="line">fmt.Println(i)  <span class="comment">// 查看 i 的值</span></span><br><span class="line"></span><br><span class="line">p = &amp;j         <span class="comment">// 指向 j</span></span><br><span class="line">*p = *p / <span class="number">37</span>   <span class="comment">// 通过指针对 j 进行除法运算</span></span><br><span class="line">fmt.Println(j) <span class="comment">// 查看 j 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">42</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">73</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>一个结构体（<code>struct</code>）就是一组字段（field）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="type">int</span></span><br><span class="line">Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;1 2&#125;</span></span><br></pre></td></tr></table></figure><h4 id="结构体字段"><a href="#结构体字段" class="headerlink" title="结构体字段"></a>结构体字段</h4><p>结构体字段使用点号来访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="type">int</span></span><br><span class="line">Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">v.X = <span class="number">4</span></span><br><span class="line">fmt.Println(v.X)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><p>结构体字段可以通过结构体指针来访问。</p><p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code> 就可以。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="type">int</span></span><br><span class="line">Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;1000000000 2&#125;</span></span><br></pre></td></tr></table></figure><h4 id="结构体文法"><a href="#结构体文法" class="headerlink" title="结构体文法"></a>结构体文法</h4><p>结构体文法通过直接列出字段的值来新分配一个结构体。</p><p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p><p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125;</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p><p>表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a [10]int</span><br></pre></td></tr></table></figure><p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p><p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="type">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(primes)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Hello World</span></span><br><span class="line"><span class="comment">[Hello World]</span></span><br><span class="line"><span class="comment">[2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p><p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p><p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high]</span><br></pre></td></tr></table></figure><p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p><p>以下表达式创建了一个切片，它包含 <code>a</code> 中下标从 1 到 3 的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[1:4]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[3 5 7]</span></span><br></pre></td></tr></table></figure><h4 id="切片就像数组的引用"><a href="#切片就像数组的引用" class="headerlink" title="切片就像数组的引用"></a>切片就像数组的引用</h4><p>切片并不存储任何数据，它只是描述了底层数组中的一段。</p><p>更改切片的元素会修改其底层数组中对应的元素。</p><p>与它共享底层数组的切片都会观测到这些修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">names := [<span class="number">4</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;John&quot;</span>,</span><br><span class="line"><span class="string">&quot;Paul&quot;</span>,</span><br><span class="line"><span class="string">&quot;George&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ringo&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(names)</span><br><span class="line"></span><br><span class="line">a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">fmt.Println(names)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[John Paul George Ringo]</span></span><br><span class="line"><span class="comment">[John Paul] [Paul George]</span></span><br><span class="line"><span class="comment">[John XXX] [XXX George]</span></span><br><span class="line"><span class="comment">[John XXX George Ringo]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切片文法"><a href="#切片文法" class="headerlink" title="切片文法"></a>切片文法</h4><p>切片文法类似于没有长度的数组文法。</p><p>这是一个数组文法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure><p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">q := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(q)</span><br><span class="line"></span><br><span class="line">r := []<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br><span class="line">fmt.Println(r)</span><br><span class="line"></span><br><span class="line">s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="type">int</span></span><br><span class="line">b <span class="type">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">[true false true true false true]</span></span><br><span class="line"><span class="comment">[&#123;2 true&#125; &#123;3 false&#125; &#123;5 true&#125; &#123;7 true&#125; &#123;11 false&#125; &#123;13 true&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="切片的默认行为"><a href="#切片的默认行为" class="headerlink" title="切片的默认行为"></a>切片的默认行为</h4><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p><p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度。</p><p>对于数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a [10]int</span><br></pre></td></tr></table></figure><p>来说，以下切片是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[0:10]</span><br><span class="line">a[:10]</span><br><span class="line">a[0:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">s = s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s = s[:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[3 5 7]</span></span><br><span class="line"><span class="comment">[3 5]</span></span><br><span class="line"><span class="comment">[5]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a>切片的长度与容量</h4><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p><p>切片的长度就是它所包含的元素个数。</p><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p><p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p><p>你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展其长度</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 舍弃前两个值</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">len=6 cap=6 [2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">len=0 cap=6 []</span></span><br><span class="line"><span class="comment">len=4 cap=6 [2 3 5 7]</span></span><br><span class="line"><span class="comment">len=2 cap=4 [5 7]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a>nil 切片</h4><p>切片的零值是 <code>nil</code>。</p><p>nil 切片的长度和容量为 0 且没有底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;nil!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[] 0 0</span></span><br><span class="line"><span class="comment">nil!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="用-make-创建切片"><a href="#用-make-创建切片" class="headerlink" title="用 make 创建切片"></a>用 make 创建切片</h4><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p><p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := make([]int, 5)  // len(a)=5</span><br></pre></td></tr></table></figure><p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b := make([]int, 0, 5) // len(b)=0, cap(b)=5</span><br><span class="line"></span><br><span class="line">b = b[:cap(b)] // len(b)=5, cap(b)=5</span><br><span class="line">b = b[1:]      // len(b)=4, cap(b)=4</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">c := b[:<span class="number">2</span>]</span><br><span class="line">printSlice(<span class="string">&quot;c&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">printSlice(<span class="string">&quot;d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="type">string</span>, x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s len=%d cap=%d %v\n&quot;</span>,</span><br><span class="line">s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a len=5 cap=5 [0 0 0 0 0]</span></span><br><span class="line"><span class="comment">b len=0 cap=5 []</span></span><br><span class="line"><span class="comment">c len=2 cap=5 [0 0]</span></span><br><span class="line"><span class="comment">d len=3 cap=3 [0 0 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h4><p>切片可包含任何类型，甚至包括其它的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个井字板（经典游戏）</span></span><br><span class="line">board := [][]<span class="type">string</span>&#123;</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个玩家轮流打上 X 和 O</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, strings.Join(board[i], <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X _ X</span></span><br><span class="line"><span class="comment">O _ X</span></span><br><span class="line"><span class="comment">_ _ O</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h4><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数。内建函数的<a href="https://go-zh.org/pkg/builtin/#append">文档</a>对此函数有详细的介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func append(s []T, vs ...T) []T</span><br></pre></td></tr></table></figure><p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</p><p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</p><p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p><p>（要了解关于切片的更多内容，请阅读文章 <a href="https://blog.go-zh.org/go-slices-usage-and-internals">Go 切片：用法和本质</a>。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个空切片</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个切片会按需增长</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">len=0 cap=0 []</span></span><br><span class="line"><span class="comment">len=1 cap=1 [0]</span></span><br><span class="line"><span class="comment">len=2 cap=2 [0 1]</span></span><br><span class="line"><span class="comment">len=5 cap=6 [0 1 2 3 4]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p><p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2**0 = 1</span></span><br><span class="line"><span class="comment">2**1 = 2</span></span><br><span class="line"><span class="comment">2**2 = 4</span></span><br><span class="line"><span class="comment">2**3 = 8</span></span><br><span class="line"><span class="comment">2**4 = 16</span></span><br><span class="line"><span class="comment">2**5 = 32</span></span><br><span class="line"><span class="comment">2**6 = 64</span></span><br><span class="line"><span class="comment">2**7 = 128</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="range（续）"><a href="#range（续）" class="headerlink" title="range（续）"></a>range（续）</h4><p>可以将下标或值赋予 <code>_</code> 来忽略它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i, _ := range pow</span><br><span class="line">for _, value := range pow</span><br></pre></td></tr></table></figure><p>若你只需要索引，忽略第二个变量即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i := range pow</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pow := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;</span><br><span class="line">pow[i] = <span class="number">1</span> &lt;&lt; <span class="type">uint</span>(i) <span class="comment">// == 2**i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">32</span></span><br><span class="line"><span class="comment">64</span></span><br><span class="line"><span class="comment">128</span></span><br><span class="line"><span class="comment">256</span></span><br><span class="line"><span class="comment">512</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：切片"><a href="#练习：切片" class="headerlink" title="练习：切片"></a>练习：切片</h4><p>实现 <code>Pic</code>。它应当返回一个长度为 <code>dy</code> 的切片，其中每个元素是一个长度为 <code>dx</code>，元素类型为 <code>uint8</code> 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。</p><p>图像的选择由你来定。几个有趣的函数包括 <code>(x+y)/2</code>, <code>x*y</code>, <code>x^y</code>, <code>x*log(y)</code> 和 <code>x%(y+1)</code>。</p><p>（提示：需要使用循环来分配 <code>[][]uint8</code> 中的每个 <code>[]uint8</code>；请使用 <code>uint8(intValue)</code> 在类型之间转换；你可能会用到 <code>math</code> 包中的函数。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/tour/pic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="type">int</span>)</span></span> [][]<span class="type">uint8</span> &#123;</span><br><span class="line">out := <span class="built_in">make</span>([][]<span class="type">uint8</span>, dy)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; dy; i++ &#123;</span><br><span class="line">out[i] = <span class="built_in">make</span>([]<span class="type">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; dx; j++ &#123;</span><br><span class="line">out[i][j] = <span class="type">uint8</span>(i * j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pic.Show(Pic)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>映射将键映射到值。</p><p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。</p><p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;40.68433 -74.39967&#125;</span></span><br></pre></td></tr></table></figure><h4 id="映射的文法"><a href="#映射的文法" class="headerlink" title="映射的文法"></a>映射的文法</h4><p>映射的文法与结构体相似，不过必须有键名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="映射的文法（续）"><a href="#映射的文法（续）" class="headerlink" title="映射的文法（续）"></a>映射的文法（续）</h4><p>若顶级类型只是一个类型名，你可以在文法的元素中省略它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line"><span class="string">&quot;Google&quot;</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="修改映射"><a href="#修改映射" class="headerlink" title="修改映射"></a>修改映射</h4><p>在映射 <code>m</code> 中插入或修改元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[key] = elem</span><br></pre></td></tr></table></figure><p>获取元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure><p>删除元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(m, key)</span><br></pre></td></tr></table></figure><p>通过双赋值检测某个键是否存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure><p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code>。</p><p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值。</p><p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p><p><strong>注</strong> ：若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok := m[key]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The value: 42</span></span><br><span class="line"><span class="comment">The value: 48</span></span><br><span class="line"><span class="comment">The value: 0</span></span><br><span class="line"><span class="comment">The value: 0 Present? false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：映射"><a href="#练习：映射" class="headerlink" title="练习：映射"></a>练习：映射</h4><p>实现 <code>WordCount</code>。它应当返回一个映射，其中包含字符串 <code>s</code> 中每个“单词”的个数。函数 <code>wc.Test</code> 会对此函数执行一系列测试用例，并输出成功还是失败。</p><p>你会发现 <a href="https://go-zh.org/pkg/strings/#Fields">strings.Fields</a> 很有帮助。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;golang.org/x/tour/wc&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WordCount</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">words := strings.Fields(s)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        n, ok := m[word]</span><br><span class="line">        <span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">            m[word] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m[word] = n + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wc.Test(WordCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h4><p>函数也是值。它们可以像其它值一样传递。</p><p>函数值可以用作函数的参数或返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">float64</span>, <span class="type">float64</span>)</span></span> <span class="type">float64</span>) <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(compute(hypot))</span><br><span class="line">fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">81</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h4><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p><p>例如，函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">1 -2</span></span><br><span class="line"><span class="comment">3 -6</span></span><br><span class="line"><span class="comment">6 -12</span></span><br><span class="line"><span class="comment">10 -20</span></span><br><span class="line"><span class="comment">15 -30</span></span><br><span class="line"><span class="comment">21 -42</span></span><br><span class="line"><span class="comment">28 -56</span></span><br><span class="line"><span class="comment">36 -72</span></span><br><span class="line"><span class="comment">45 -90</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：斐波纳契闭包"><a href="#练习：斐波纳契闭包" class="headerlink" title="练习：斐波纳契闭包"></a>练习：斐波纳契闭包</h4><p>让我们用函数做些好玩的事情。</p><p>实现一个 <code>fibonacci</code> 函数，它返回一个函数（闭包），该闭包返回一个<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波纳契数列</a> <code>(0, 1, 1, 2, 3, 5, ...)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个“返回int的函数”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">1</span> <span class="comment">//定义初始的两个值</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">c := a</span><br><span class="line">a, b = b, a+b</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">34</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Go 没有类。不过你可以为结构体类型定义方法。</p><p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p><p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p><p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h4 id="方法即函数"><a href="#方法即函数" class="headerlink" title="方法即函数"></a>方法即函数</h4><p>记住：方法只是个带接收者参数的函数。</p><p>现在这个 <code>Abs</code> 的写法就是个正常的函数，功能并没有什么变化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h4 id="方法（续）"><a href="#方法（续）" class="headerlink" title="方法（续）"></a>方法（续）</h4><p>你也可以为非结构体类型声明方法。</p><p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code>。</p><p>你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法。</p><p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.4142135623730951</span></span><br></pre></td></tr></table></figure><h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><p>你可以为指针接收者声明方法。</p><p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p><p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法。</p><p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p><p>试着移除第 16 行 <code>Scale</code> 函数声明中的 <code>*</code>，观察此程序的行为如何变化。</p><p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure><h4 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h4><p>现在我们要把 <code>Abs</code> 和 <code>Scale</code> 方法重写为函数。</p><p>同样，我们先试着移除掉第 16 的 <code>*</code>。你能看出为什么程序的行为改变了吗？要怎样做才能让该示例顺利通过编译？</p><p>（若你不确定，继续往下看。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(v *Vertex, f <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">Scale(&amp;v, <span class="number">10</span>)</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure><h4 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h4><p>比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">ScaleFunc(v, 5)  // 编译错误！</span><br><span class="line">ScaleFunc(&amp;v, 5) // OK</span><br></pre></td></tr></table></figure><p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">v.Scale(5)  // OK</span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(10) // OK</span><br></pre></td></tr></table></figure><p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">2</span>)</span><br><span class="line">ScaleFunc(&amp;v, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">p.Scale(<span class="number">3</span>)</span><br><span class="line">ScaleFunc(p, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(v, p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;60 80&#125; &amp;&#123;96 72&#125;</span></span><br></pre></td></tr></table></figure><h4 id="方法与指针重定向（续）"><a href="#方法与指针重定向（续）" class="headerlink" title="方法与指针重定向（续）"></a>方法与指针重定向（续）</h4><p>同样的事情也发生在相反的方向。</p><p>接受一个值作为参数的函数必须接受一个指定类型的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(AbsFunc(v))  // OK</span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) // 编译错误！</span><br></pre></td></tr></table></figure><p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(v.Abs()) // OK</span><br><span class="line">p := &amp;v</span><br><span class="line">fmt.Println(p.Abs()) // OK</span><br></pre></td></tr></table></figure><p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AbsFunc</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">fmt.Println(AbsFunc(v))</span><br><span class="line"></span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(p.Abs())</span><br><span class="line">fmt.Println(AbsFunc(*p))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h4><p>使用指针接收者的原因有二：</p><p>首先，方法能够修改其接收者指向的值。</p><p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p><p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p><p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。（我们会在接下来几页中明白为什么。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">v.Scale(<span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;After scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Before scaling: &amp;&#123;X:3 Y:4&#125;, Abs: 5</span></span><br><span class="line"><span class="comment">After scaling: &amp;&#123;X:15 Y:20&#125;, Abs: 25</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p><p>接口类型的变量可以保存任何实现了这些方法的值。</p><p><strong>注意:</strong> 示例代码的 22 行存在一个错误。由于 <code>Abs</code> 方法只为 <code>*Vertex</code> （指针类型）定义，因此 <code>Vertex</code>（值类型）并未实现 <code>Abser</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line"><span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line">a = &amp;v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="接口与隐式实现"><a href="#接口与隐式实现" class="headerlink" title="接口与隐式实现"></a>接口与隐式实现</h4><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p><p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p><p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M() &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello </span></span><br></pre></td></tr></table></figure><h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><p>接口也是值。它们可以像其它值一样传递。</p><p>接口值可以用作函数的参数或返回值。</p><p>在内部，接口值可以看做包含值和具体类型的元组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value, type)</span><br></pre></td></tr></table></figure><p>接口值保存了一个具体底层类型的具体值。</p><p>接口值调用方法时会执行其底层类型的同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span></span> M() &#123;</span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = F(math.Pi)</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&amp;&#123;Hello&#125;, *main.T)</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">(3.141592653589793, main.F)</span></span><br><span class="line"><span class="comment">3.141592653589793</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="底层值为-nil-的接口值"><a href="#底层值为-nil-的接口值" class="headerlink" title="底层值为 nil 的接口值"></a>底层值为 nil 的接口值</h4><p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</p><p>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</p><p><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">i = t</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, *main.T)</span></span><br><span class="line"><span class="comment">&lt;nil&gt;</span></span><br><span class="line"><span class="comment">(&amp;&#123;hello&#125;, *main.T)</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="nil-接口值"><a href="#nil-接口值" class="headerlink" title="nil 接口值"></a>nil 接口值</h4><p>nil 接口值既不保存值也不保存具体类型。</p><p>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class="line"><span class="comment">panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"><span class="comment">[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x47f2e1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">/tmp/sandbox1265149038/prog.go:12 +0x61</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>指定了零个方法的接口值被称为 <em>空接口：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#123;&#125;</span><br></pre></td></tr></table></figure><p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p><p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class="line"><span class="comment">(42, int)</span></span><br><span class="line"><span class="comment">(hello, string)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure><p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p><p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。</p><p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p><p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p><p>请注意这种语法和读取一个映射时的相同之处。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="type">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello true</span></span><br><span class="line"><span class="comment">0 false</span></span><br><span class="line"><span class="comment">panic: interface conversion: interface &#123;&#125; is string, not float64</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p><p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch v := i.(type) &#123;</span><br><span class="line">case T:</span><br><span class="line">    // v 的类型为 T</span><br><span class="line">case S:</span><br><span class="line">    // v 的类型为 S</span><br><span class="line">default:</span><br><span class="line">    // 没有匹配，v 与 i 的类型相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p><p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Twice 21 is 42</span></span><br><span class="line"><span class="comment">&quot;hello&quot; is 5 bytes long</span></span><br><span class="line"><span class="comment">I don&#x27;t know about type bool!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h4><p><a href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">fmt.Println(a, z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Arthur Dent (42 years) Zaphod Beeblebrox (9001 years) </span></span><br></pre></td></tr></table></figure><h4 id="练习：Stringer"><a href="#练习：Stringer" class="headerlink" title="练习：Stringer"></a>练习：Stringer</h4><p>通过让 <code>IPAddr</code> 类型实现 <code>fmt.Stringer</code> 来打印点号分隔的地址。</p><p>例如，<code>IPAddr&#123;1, 2, 3, 4&#125;</code> 应当打印为 <code>&quot;1.2.3.4&quot;</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 给 IPAddr 添加一个 &quot;String() string&quot; 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dot IPAddr)</span></span> String() <span class="type">string</span>&#123;</span><br><span class="line">  str := <span class="string">&quot; &quot;</span></span><br><span class="line">  <span class="keyword">for</span> _, s :=<span class="keyword">range</span> dot&#123;</span><br><span class="line"><span class="keyword">if</span> str!=<span class="string">&quot; &quot;</span>&#123;</span><br><span class="line">str +=<span class="string">&quot;.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">str += strconv.Itoa(<span class="type">int</span>(s))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hosts := <span class="keyword">map</span>[<span class="type">string</span>]IPAddr&#123;</span><br><span class="line"><span class="string">&quot;loopback&quot;</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line"><span class="string">&quot;googleDNS&quot;</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, name, ip)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">loopback:  127.0.0.1</span></span><br><span class="line"><span class="comment">googleDNS:  8.8.8.8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p><p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p><p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, err := strconv.Atoi(&quot;42&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;couldn&#x27;t convert number: %v\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Converted integer:&quot;, i)</span><br></pre></td></tr></table></figure><p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">When time.Time</span><br><span class="line">What <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">time.Now(),</span><br><span class="line"><span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">at 2009-11-10 23:00:00 +0000 UTC m=+0.000000001, it didn&#x27;t work</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：错误"><a href="#练习：错误" class="headerlink" title="练习：错误"></a>练习：错误</h4><p>从<a href="https://tour.go-zh.org/flowcontrol/8">之前的练习</a>中复制 <code>Sqrt</code> 函数，修改它使其返回 <code>error</code> 值。</p><p><code>Sqrt</code> 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。</p><p>创建一个新的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ErrNegativeSqrt float64</span><br></pre></td></tr></table></figure><p>并为其实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (e ErrNegativeSqrt) Error() string</span><br></pre></td></tr></table></figure><p>方法使其拥有 <code>error</code> 值，通过 <code>ErrNegativeSqrt(-2).Error()</code> 调用该方法应返回 <code>&quot;cannot Sqrt negative number: -2&quot;</code>。</p><p><strong>注意:</strong> 在 <code>Error</code> 方法内调用 <code>fmt.Sprint(e)</code> 会让程序陷入死循环。可以通过先转换 <code>e</code> 来避免这个问题：<code>fmt.Sprint(float64(e))</code>。这是为什么呢？</p><p>修改 <code>Sqrt</code> 函数，使其接受一个负数时，返回 <code>ErrNegativeSqrt</code> 值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span></span> Error() <span class="type">string</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;cannot Sqrt negative number:  %v&quot;</span>, <span class="type">float64</span>(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">res := <span class="type">float64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">if</span> x&lt;<span class="number">0</span>&#123;</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">err = ErrNegativeSqrt(x)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">res = math.Sqrt(x)</span><br><span class="line">err = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">fmt.Println(Sqrt(<span class="number">-2</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.4142135623730951 &lt;nil&gt;</span></span><br><span class="line"><span class="comment">0 cannot Sqrt negative number:  -2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p><p>Go 标准库包含了该接口的<a href="https://go-zh.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p><p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (T) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure><p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p><p>示例代码创建了一个 <a href="https://go-zh.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]</span></span><br><span class="line"><span class="comment">b[:n] = &quot;Hello, R&quot;</span></span><br><span class="line"><span class="comment">n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]</span></span><br><span class="line"><span class="comment">b[:n] = &quot;eader!&quot;</span></span><br><span class="line"><span class="comment">n = 0 err = EOF b = [101 97 100 101 114 33 32 82]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：Reader"><a href="#练习：Reader" class="headerlink" title="练习：Reader"></a>练习：Reader</h4><p>实现一个 <code>Reader</code> 类型，它产生一个 ASCII 字符 <code>&#39;A&#39;</code> 的无限流。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/tour/reader&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 给 MyReader 添加一个 Read([]byte) (int, error) 方法</span></span><br><span class="line"><span class="comment">// 向MyReader添加一个Read([]byte) (int, error)方法。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r MyReader)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>,<span class="type">error</span>)&#123;</span><br><span class="line">    <span class="comment">//赋值并返回</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader.Validate(MyReader&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OK!</span></span><br></pre></td></tr></table></figure><h4 id="练习：rot13Reader"><a href="#练习：rot13Reader" class="headerlink" title="练习：rot13Reader"></a>练习：rot13Reader</h4><p>有种常见的模式是一个 <a href="https://go-zh.org/pkg/io/#Reader"><code>io.Reader</code></a> 包装另一个 <code>io.Reader</code>，然后通过某种方式修改其数据流。</p><p>例如，<a href="https://go-zh.org/pkg/compress/gzip/#NewReader"><code>gzip.NewReader</code></a> 函数接受一个 <code>io.Reader</code>（已压缩的数据流）并返回一个同样实现了 <code>io.Reader</code> 的 <code>*gzip.Reader</code>（解压后的数据流）。</p><p>编写一个实现了 <code>io.Reader</code> 并从另一个 <code>io.Reader</code> 中读取数据的 <code>rot13Reader</code>，通过应用 <a href="http://en.wikipedia.org/wiki/ROT13">rot13</a> 代换密码对数据流进行修改。</p><p><code>rot13Reader</code> 类型已经提供。实现 <code>Read</code> 方法以满足 <code>io.Reader</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 读取大文件</title>
      <link href="/2022/06/19/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
      <url>/2022/06/19/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>处理 WorldKG 乱码问题的片段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import linecache</span></span><br><span class="line"><span class="comment"># text = linecache.getline(&#x27;./planet_osm.ttl&#x27;, 12743421)</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;./planet_osm.ttl&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">line = file.readline()</span><br><span class="line">counts = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line"><span class="keyword">if</span> counts &gt;= <span class="number">13352055</span>:</span><br><span class="line"><span class="built_in">print</span>(line)</span><br><span class="line"><span class="keyword">if</span> counts &gt;= <span class="number">13352056</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">line = file.readline()</span><br><span class="line">counts += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 待归档 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPARQL</title>
      <link href="/2022/06/19/blog/SPARQL/SPARQL/"/>
      <url>/2022/06/19/blog/SPARQL/SPARQL/</url>
      
        <content type="html"><![CDATA[<h1 id="SPARQL-1-1-查询语言"><a href="#SPARQL-1-1-查询语言" class="headerlink" title="SPARQL 1.1 查询语言"></a>SPARQL 1.1 查询语言</h1><blockquote><p>原文：<a href="https://www.w3.org/TR/sparql11-query/">https://www.w3.org/TR/sparql11-query/</a></p></blockquote><p><strong>摘要</strong></p><p>RDF 是一种有向的、标记的图形数据格式，用于表示 Web 中的信息。本规范定义了 RDF 的 SPARQL 查询语言的语法和语义。 SPARQL 可用于表达跨不同数据源的查询，无论数据是本地存储为 RDF 还是通过中间件查看为 RDF。 SPARQL 包含查询必需和可选图形模式及其连接和分离的功能。 SPARQL 还支持聚合、子查询、否定、通过表达式创建值、可扩展值测试以及通过源 RDF 图约束查询。 SPARQL 查询的结果可以是结果集或 RDF 图。</p><p>目录：</p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><h3 id="1-1-文档大纲"><a href="#1-1-文档大纲" class="headerlink" title="1.1 文档大纲"></a>1.1 文档大纲</h3><h3 id="1-2-文档约定"><a href="#1-2-文档约定" class="headerlink" title="1.2 文档约定"></a>1.2 文档约定</h3><h4 id="1-2-1-命名空间"><a href="#1-2-1-命名空间" class="headerlink" title="1.2.1 命名空间"></a>1.2.1 命名空间</h4><h4 id="1-2-2-数据描述"><a href="#1-2-2-数据描述" class="headerlink" title="1.2.2 数据描述"></a>1.2.2 数据描述</h4><h4 id="1-2-3-结果描述"><a href="#1-2-3-结果描述" class="headerlink" title="1.2.3 结果描述"></a>1.2.3 结果描述</h4><h4 id="1-2-4-术语"><a href="#1-2-4-术语" class="headerlink" title="1.2.4 术语"></a>1.2.4 术语</h4><h2 id="2-进行简单查询（信息性）"><a href="#2-进行简单查询（信息性）" class="headerlink" title="2 进行简单查询（信息性）"></a>2 进行简单查询（信息性）</h2><h3 id="2-1-编写简单查询"><a href="#2-1-编写简单查询" class="headerlink" title="2.1 编写简单查询"></a>2.1 编写简单查询</h3><h3 id="2-2-多重匹配"><a href="#2-2-多重匹配" class="headerlink" title="2.2 多重匹配"></a>2.2 多重匹配</h3><h3 id="2-3-匹配-RDF-文字"><a href="#2-3-匹配-RDF-文字" class="headerlink" title="2.3 匹配 RDF 文字"></a>2.3 匹配 RDF 文字</h3><h4 id="2-3-1-将文字与语言标签匹配"><a href="#2-3-1-将文字与语言标签匹配" class="headerlink" title="2.3.1 将文字与语言标签匹配"></a>2.3.1 将文字与语言标签匹配</h4><h4 id="2-3-2-将文字与数字类型匹配"><a href="#2-3-2-将文字与数字类型匹配" class="headerlink" title="2.3.2 将文字与数字类型匹配"></a>2.3.2 将文字与数字类型匹配</h4><h4 id="2-3-3-将文字与任意数据类型匹配"><a href="#2-3-3-将文字与任意数据类型匹配" class="headerlink" title="2.3.3 将文字与任意数据类型匹配"></a>2.3.3 将文字与任意数据类型匹配</h4><h3 id="2-4-查询结果中的空白节点标签"><a href="#2-4-查询结果中的空白节点标签" class="headerlink" title="2.4 查询结果中的空白节点标签"></a>2.4 查询结果中的空白节点标签</h3><h3 id="2-5-使用表达式创建值"><a href="#2-5-使用表达式创建值" class="headerlink" title="2.5 使用表达式创建值"></a>2.5 使用表达式创建值</h3><h3 id="2-6-构建-RDF-图"><a href="#2-6-构建-RDF-图" class="headerlink" title="2.6 构建 RDF 图"></a>2.6 构建 RDF 图</h3><h2 id="3-RDF-术语约束（信息性）"><a href="#3-RDF-术语约束（信息性）" class="headerlink" title="3 RDF 术语约束（信息性）"></a>3 RDF 术语约束（信息性）</h2><h3 id="3-1-限制字符串的值"><a href="#3-1-限制字符串的值" class="headerlink" title="3.1 限制字符串的值"></a>3.1 限制字符串的值</h3><h3 id="3-2-限制数值"><a href="#3-2-限制数值" class="headerlink" title="3.2 限制数值"></a>3.2 限制数值</h3><h3 id="3-3-其他术语约束"><a href="#3-3-其他术语约束" class="headerlink" title="3.3 其他术语约束"></a>3.3 其他术语约束</h3><h2 id="4-SPARQL-语法"><a href="#4-SPARQL-语法" class="headerlink" title="4 SPARQL 语法"></a>4 SPARQL 语法</h2><h3 id="4-1-RDF-术语语法"><a href="#4-1-RDF-术语语法" class="headerlink" title="4.1 RDF 术语语法"></a>4.1 RDF 术语语法</h3><h4 id="4-1-1-IRI-语法"><a href="#4-1-1-IRI-语法" class="headerlink" title="4.1.1 IRI 语法"></a>4.1.1 IRI 语法</h4><h5 id="4-1-1-1-前缀名称"><a href="#4-1-1-1-前缀名称" class="headerlink" title="4.1.1.1 前缀名称"></a>4.1.1.1 前缀名称</h5><h5 id="4-1-1-2-相对-IRI"><a href="#4-1-1-2-相对-IRI" class="headerlink" title="4.1.1.2 相对 IRI"></a>4.1.1.2 相对 IRI</h5><h4 id="4-1-2-文字语法"><a href="#4-1-2-文字语法" class="headerlink" title="4.1.2 文字语法"></a>4.1.2 文字语法</h4><h4 id="4-1-3-查询变量的语法"><a href="#4-1-3-查询变量的语法" class="headerlink" title="4.1.3 查询变量的语法"></a>4.1.3 查询变量的语法</h4><h4 id="4-1-4-空白节点的语法"><a href="#4-1-4-空白节点的语法" class="headerlink" title="4.1.4 空白节点的语法"></a>4.1.4 空白节点的语法</h4><h3 id="4-2-三重模式的语法"><a href="#4-2-三重模式的语法" class="headerlink" title="4.2 三重模式的语法"></a>4.2 三重模式的语法</h3><h4 id="4-2-1-谓词-对象列表"><a href="#4-2-1-谓词-对象列表" class="headerlink" title="4.2.1 谓词-对象列表"></a>4.2.1 谓词-对象列表</h4><h4 id="4-2-2-对象列表"><a href="#4-2-2-对象列表" class="headerlink" title="4.2.2 对象列表"></a>4.2.2 对象列表</h4><h4 id="4-2-3-RDF-集合"><a href="#4-2-3-RDF-集合" class="headerlink" title="4.2.3 RDF 集合"></a>4.2.3 RDF 集合</h4><h4 id="4-2-4-rdf-type"><a href="#4-2-4-rdf-type" class="headerlink" title="4.2.4 rdf:type"></a>4.2.4 rdf:type</h4><h2 id="5-图模式"><a href="#5-图模式" class="headerlink" title="5 图模式"></a>5 图模式</h2><h3 id="5-1-基本图模式"><a href="#5-1-基本图模式" class="headerlink" title="5.1 基本图模式"></a>5.1 基本图模式</h3><h4 id="5-1-1-空白节点标签"><a href="#5-1-1-空白节点标签" class="headerlink" title="5.1.1 空白节点标签"></a>5.1.1 空白节点标签</h4><h4 id="5-1-2-扩展基本图模式匹配"><a href="#5-1-2-扩展基本图模式匹配" class="headerlink" title="5.1.2 扩展基本图模式匹配"></a>5.1.2 扩展基本图模式匹配</h4><h3 id="5-2-组图模式"><a href="#5-2-组图模式" class="headerlink" title="5.2 组图模式"></a>5.2 组图模式</h3><h4 id="5-2-1-空组模式"><a href="#5-2-1-空组模式" class="headerlink" title="5.2.1 空组模式"></a>5.2.1 空组模式</h4><h4 id="5-2-2-过滤器范围"><a href="#5-2-2-过滤器范围" class="headerlink" title="5.2.2 过滤器范围"></a>5.2.2 过滤器范围</h4><h4 id="5-2-3-组图模式示例"><a href="#5-2-3-组图模式示例" class="headerlink" title="5.2.3 组图模式示例"></a>5.2.3 组图模式示例</h4><h2 id="6-包括可选值"><a href="#6-包括可选值" class="headerlink" title="6 包括可选值"></a>6 包括可选值</h2><h3 id="6-1-可选模式匹配"><a href="#6-1-可选模式匹配" class="headerlink" title="6.1 可选模式匹配"></a>6.1 可选模式匹配</h3><h3 id="6-2-可选模式匹配中的约束"><a href="#6-2-可选模式匹配中的约束" class="headerlink" title="6.2 可选模式匹配中的约束"></a>6.2 可选模式匹配中的约束</h3><h3 id="6-3-多个可选图形模式"><a href="#6-3-多个可选图形模式" class="headerlink" title="6.3 多个可选图形模式"></a>6.3 多个可选图形模式</h3><h2 id="7-匹配备选方案"><a href="#7-匹配备选方案" class="headerlink" title="7 匹配备选方案"></a>7 匹配备选方案</h2><h2 id="8-否定"><a href="#8-否定" class="headerlink" title="8 否定"></a>8 否定</h2><h3 id="8-1-使用图形模式过滤"><a href="#8-1-使用图形模式过滤" class="headerlink" title="8.1 使用图形模式过滤"></a>8.1 使用图形模式过滤</h3><h4 id="8-1-1-测试模式是否不存在"><a href="#8-1-1-测试模式是否不存在" class="headerlink" title="8.1.1 测试模式是否不存在"></a>8.1.1 测试模式是否不存在</h4><h4 id="8-1-2-测试模式是否存在"><a href="#8-1-2-测试模式是否存在" class="headerlink" title="8.1.2 测试模式是否存在"></a>8.1.2 测试模式是否存在</h4><h3 id="8-2-删除可能的解决方案"><a href="#8-2-删除可能的解决方案" class="headerlink" title="8.2 删除可能的解决方案"></a>8.2 删除可能的解决方案</h3><h3 id="8-3-NOT-EXISTS-和-MINUS-之间的关系和差异"><a href="#8-3-NOT-EXISTS-和-MINUS-之间的关系和差异" class="headerlink" title="8.3 NOT EXISTS 和 MINUS 之间的关系和差异"></a>8.3 NOT EXISTS 和 MINUS 之间的关系和差异</h3><h4 id="8-3-1-示例：变量共享"><a href="#8-3-1-示例：变量共享" class="headerlink" title="8.3.1 示例：变量共享"></a>8.3.1 示例：变量共享</h4><h4 id="8-3-2-示例：固定模式"><a href="#8-3-2-示例：固定模式" class="headerlink" title="8.3.2 示例：固定模式"></a>8.3.2 示例：固定模式</h4><h4 id="8-3-3-示例：内部过滤器"><a href="#8-3-3-示例：内部过滤器" class="headerlink" title="8.3.3 示例：内部过滤器"></a>8.3.3 示例：内部过滤器</h4><h2 id="9-属性路径"><a href="#9-属性路径" class="headerlink" title="9 属性路径"></a>9 属性路径</h2><h3 id="9-1-属性路径语法"><a href="#9-1-属性路径语法" class="headerlink" title="9.1 属性路径语法"></a>9.1 属性路径语法</h3><h3 id="9-2-示例"><a href="#9-2-示例" class="headerlink" title="9.2 示例"></a>9.2 示例</h3><h3 id="9-3-属性路径和等效模式"><a href="#9-3-属性路径和等效模式" class="headerlink" title="9.3 属性路径和等效模式"></a>9.3 属性路径和等效模式</h3><h3 id="9-4-任意长度路径匹配"><a href="#9-4-任意长度路径匹配" class="headerlink" title="9.4 任意长度路径匹配"></a>9.4 任意长度路径匹配</h3><h2 id="10-赋值"><a href="#10-赋值" class="headerlink" title="10 赋值"></a>10 赋值</h2><h3 id="10-1-BIND：分配给变量"><a href="#10-1-BIND：分配给变量" class="headerlink" title="10.1 BIND：分配给变量"></a>10.1 BIND：分配给变量</h3><h3 id="10-2-VALUES：提供内联数据"><a href="#10-2-VALUES：提供内联数据" class="headerlink" title="10.2 VALUES：提供内联数据"></a>10.2 VALUES：提供内联数据</h3><h4 id="10-2-1-VALUES-语法"><a href="#10-2-1-VALUES-语法" class="headerlink" title="10.2.1 VALUES 语法"></a>10.2.1 VALUES 语法</h4><h4 id="10-2-2-VALUES-示例"><a href="#10-2-2-VALUES-示例" class="headerlink" title="10.2.2 VALUES 示例"></a>10.2.2 VALUES 示例</h4><h2 id="11-聚合"><a href="#11-聚合" class="headerlink" title="11 聚合"></a>11 聚合</h2><h3 id="11-1-聚合示例"><a href="#11-1-聚合示例" class="headerlink" title="11.1 聚合示例"></a>11.1 聚合示例</h3><h3 id="11-2-GROUP-BY"><a href="#11-2-GROUP-BY" class="headerlink" title="11.2 GROUP BY"></a>11.2 GROUP BY</h3><h3 id="11-3-HAVING"><a href="#11-3-HAVING" class="headerlink" title="11.3 HAVING"></a>11.3 HAVING</h3><h3 id="11-4-聚合投影限制"><a href="#11-4-聚合投影限制" class="headerlink" title="11.4 聚合投影限制"></a>11.4 聚合投影限制</h3><h3 id="11-5-聚合示例（有错误）"><a href="#11-5-聚合示例（有错误）" class="headerlink" title="11.5 聚合示例（有错误）"></a>11.5 聚合示例（有错误）</h3><h2 id="12-子查询"><a href="#12-子查询" class="headerlink" title="12 子查询"></a>12 子查询</h2><h2 id="13-RDF-数据集"><a href="#13-RDF-数据集" class="headerlink" title="13 RDF 数据集"></a>13 RDF 数据集</h2><h3 id="13-1-RDF-数据集示例"><a href="#13-1-RDF-数据集示例" class="headerlink" title="13.1 RDF 数据集示例"></a>13.1 RDF 数据集示例</h3><h3 id="13-2-指定-RDF-数据集"><a href="#13-2-指定-RDF-数据集" class="headerlink" title="13.2 指定 RDF 数据集"></a>13.2 指定 RDF 数据集</h3><h4 id="13-2-1-指定默认图"><a href="#13-2-1-指定默认图" class="headerlink" title="13.2.1 指定默认图"></a>13.2.1 指定默认图</h4><h4 id="13-2-2-指定命名图"><a href="#13-2-2-指定命名图" class="headerlink" title="13.2.2 指定命名图"></a>13.2.2 指定命名图</h4><h4 id="13-2-3-结合-FROM-和-FROM-NAMED"><a href="#13-2-3-结合-FROM-和-FROM-NAMED" class="headerlink" title="13.2.3 结合 FROM 和 FROM NAMED"></a>13.2.3 结合 FROM 和 FROM NAMED</h4><h3 id="13-3-查询数据集"><a href="#13-3-查询数据集" class="headerlink" title="13.3 查询数据集"></a>13.3 查询数据集</h3><h4 id="13-3-1-访问图名"><a href="#13-3-1-访问图名" class="headerlink" title="13.3.1 访问图名"></a>13.3.1 访问图名</h4><h4 id="13-3-2-限制方式图-IRI"><a href="#13-3-2-限制方式图-IRI" class="headerlink" title="13.3.2 限制方式图 IRI"></a>13.3.2 限制方式图 IRI</h4><h4 id="13-3-3-限制可能的图-IRI"><a href="#13-3-3-限制可能的图-IRI" class="headerlink" title="13.3.3 限制可能的图 IRI"></a>13.3.3 限制可能的图 IRI</h4><h4 id="13-3-4-命名和默认图"><a href="#13-3-4-命名和默认图" class="headerlink" title="13.3.4 命名和默认图"></a>13.3.4 命名和默认图</h4><h2 id="14-基本联合查询"><a href="#14-基本联合查询" class="headerlink" title="14 基本联合查询"></a>14 基本联合查询</h2><h2 id="15-解决方案序列和修饰符"><a href="#15-解决方案序列和修饰符" class="headerlink" title="15 解决方案序列和修饰符"></a>15 解决方案序列和修饰符</h2><h3 id="15-1-ORDER-BY"><a href="#15-1-ORDER-BY" class="headerlink" title="15.1 ORDER BY"></a>15.1 ORDER BY</h3><h3 id="15-2-投影"><a href="#15-2-投影" class="headerlink" title="15.2 投影"></a>15.2 投影</h3><h3 id="15-3-重复解决方案"><a href="#15-3-重复解决方案" class="headerlink" title="15.3 重复解决方案"></a>15.3 重复解决方案</h3><h3 id="15-4-偏移量"><a href="#15-4-偏移量" class="headerlink" title="15.4 偏移量"></a>15.4 偏移量</h3><h3 id="15-5-限制"><a href="#15-5-限制" class="headerlink" title="15.5 限制"></a>15.5 限制</h3><h2 id="16-查询表单"><a href="#16-查询表单" class="headerlink" title="16 查询表单"></a>16 查询表单</h2><h3 id="16-1-SELECT"><a href="#16-1-SELECT" class="headerlink" title="16.1 SELECT"></a>16.1 SELECT</h3><h4 id="16-1-1-投影"><a href="#16-1-1-投影" class="headerlink" title="16.1.1 投影"></a>16.1.1 投影</h4><h4 id="16-1-2-SELECT-表达式"><a href="#16-1-2-SELECT-表达式" class="headerlink" title="16.1.2 SELECT 表达式"></a>16.1.2 SELECT 表达式</h4><h3 id="16-2-CONSTRUCT"><a href="#16-2-CONSTRUCT" class="headerlink" title="16.2 CONSTRUCT"></a>16.2 CONSTRUCT</h3><h4 id="16-2-1-带有空白节点的模板"><a href="#16-2-1-带有空白节点的模板" class="headerlink" title="16.2.1 带有空白节点的模板"></a>16.2.1 带有空白节点的模板</h4><h4 id="16-2-2-访问-RDF-数据集中的图形"><a href="#16-2-2-访问-RDF-数据集中的图形" class="headerlink" title="16.2.2 访问 RDF 数据集中的图形"></a>16.2.2 访问 RDF 数据集中的图形</h4><h4 id="16-2-3-解决方案修饰符和-CONSTRUCT"><a href="#16-2-3-解决方案修饰符和-CONSTRUCT" class="headerlink" title="16.2.3 解决方案修饰符和 CONSTRUCT"></a>16.2.3 解决方案修饰符和 CONSTRUCT</h4><h4 id="16-2-4-CONSTRUCT-WHERE"><a href="#16-2-4-CONSTRUCT-WHERE" class="headerlink" title="16.2.4 CONSTRUCT WHERE"></a>16.2.4 CONSTRUCT WHERE</h4><h3 id="16-3-ASK"><a href="#16-3-ASK" class="headerlink" title="16.3 ASK"></a>16.3 ASK</h3><h3 id="16-4-DESCRIBE-Informative"><a href="#16-4-DESCRIBE-Informative" class="headerlink" title="16.4 DESCRIBE (Informative )"></a>16.4 DESCRIBE (Informative )</h3><h4 id="16-4-1-显式-IRI"><a href="#16-4-1-显式-IRI" class="headerlink" title="16.4.1 显式 IRI"></a>16.4.1 显式 IRI</h4><h4 id="16-4-2-识别资源"><a href="#16-4-2-识别资源" class="headerlink" title="16.4.2 识别资源"></a>16.4.2 识别资源</h4><h4 id="16-4-3-资源描述"><a href="#16-4-3-资源描述" class="headerlink" title="16.4.3 资源描述"></a>16.4.3 资源描述</h4><h2 id="17-表达式和测试值"><a href="#17-表达式和测试值" class="headerlink" title="17 表达式和测试值"></a>17 表达式和测试值</h2><h3 id="17-1-操作数数据类型"><a href="#17-1-操作数数据类型" class="headerlink" title="17.1 操作数数据类型"></a>17.1 操作数数据类型</h3><h3 id="17-2-过滤器评估"><a href="#17-2-过滤器评估" class="headerlink" title="17.2 过滤器评估"></a>17.2 过滤器评估</h3><h4 id="17-2-1-调用"><a href="#17-2-1-调用" class="headerlink" title="17.2.1 调用"></a>17.2.1 调用</h4><h4 id="17-2-2-有效布尔值-EBV"><a href="#17-2-2-有效布尔值-EBV" class="headerlink" title="17.2.2 有效布尔值 (EBV)"></a>17.2.2 有效布尔值 (EBV)</h4><h3 id="17-3-运算符映射"><a href="#17-3-运算符映射" class="headerlink" title="17.3 运算符映射"></a>17.3 运算符映射</h3><h4 id="17-3-1-运算符可扩展性"><a href="#17-3-1-运算符可扩展性" class="headerlink" title="17.3.1 运算符可扩展性"></a>17.3.1 运算符可扩展性</h4><h3 id="17-4-函数定义"><a href="#17-4-函数定义" class="headerlink" title="17.4 函数定义"></a>17.4 函数定义</h3><h4 id="17-4-1-函数形式"><a href="#17-4-1-函数形式" class="headerlink" title="17.4.1 函数形式"></a>17.4.1 函数形式</h4><h5 id="17-4-1-1-绑定"><a href="#17-4-1-1-绑定" class="headerlink" title="17.4.1.1 绑定"></a>17.4.1.1 绑定</h5><h5 id="17-4-1-2-IF"><a href="#17-4-1-2-IF" class="headerlink" title="17.4.1.2 IF"></a>17.4.1.2 IF</h5><h5 id="17-4-1-3-COALESCE"><a href="#17-4-1-3-COALESCE" class="headerlink" title="17.4.1.3 COALESCE"></a>17.4.1.3 COALESCE</h5><h5 id="17-4-1-4-NOT-EXISTS-和-EXISTS"><a href="#17-4-1-4-NOT-EXISTS-和-EXISTS" class="headerlink" title="17.4.1.4 NOT EXISTS 和 EXISTS"></a>17.4.1.4 NOT EXISTS 和 EXISTS</h5><h5 id="17-4-1-5-逻辑或"><a href="#17-4-1-5-逻辑或" class="headerlink" title="17.4.1.5 逻辑或"></a>17.4.1.5 逻辑或</h5><h5 id="17-4-1-6-逻辑和"><a href="#17-4-1-6-逻辑和" class="headerlink" title="17.4.1.6 逻辑和"></a>17.4.1.6 逻辑和</h5><h5 id="17-4-1-7-RDFterm-equal"><a href="#17-4-1-7-RDFterm-equal" class="headerlink" title="17.4.1.7 RDFterm-equal"></a>17.4.1.7 RDFterm-equal</h5><h5 id="17-4-1-8-sameTerm"><a href="#17-4-1-8-sameTerm" class="headerlink" title="17.4.1.8 sameTerm"></a>17.4.1.8 sameTerm</h5><h5 id="17-4-1-9-IN"><a href="#17-4-1-9-IN" class="headerlink" title="17.4.1.9 IN"></a>17.4.1.9 IN</h5><h5 id="17-4-1-10-NOT-IN"><a href="#17-4-1-10-NOT-IN" class="headerlink" title="17.4.1.10 NOT IN"></a>17.4.1.10 NOT IN</h5><h4 id="17-4-2-RDF-术语上的函数"><a href="#17-4-2-RDF-术语上的函数" class="headerlink" title="17.4.2 RDF 术语上的函数"></a>17.4.2 RDF 术语上的函数</h4><h5 id="17-4-2-1-isIRI"><a href="#17-4-2-1-isIRI" class="headerlink" title="17.4.2.1  isIRI"></a>17.4.2.1  isIRI</h5><h5 id="17-4-2-2-ISBLANK"><a href="#17-4-2-2-ISBLANK" class="headerlink" title="17.4.2.2 ISBLANK"></a>17.4.2.2 ISBLANK</h5><h5 id="17-4-2-3-ISLITERAL"><a href="#17-4-2-3-ISLITERAL" class="headerlink" title="17.4.2.3 ISLITERAL"></a>17.4.2.3 ISLITERAL</h5><h5 id="17-4-2-4-ISNUMERIC"><a href="#17-4-2-4-ISNUMERIC" class="headerlink" title="17.4.2.4 ISNUMERIC"></a>17.4.2.4 ISNUMERIC</h5><h5 id="17-4-2-5-Str"><a href="#17-4-2-5-Str" class="headerlink" title="17.4.2.5 Str"></a>17.4.2.5 Str</h5><h5 id="17-4-2-6-Lang"><a href="#17-4-2-6-Lang" class="headerlink" title="17.4.2.6 Lang"></a>17.4.2.6 Lang</h5><h5 id="17-4-2-7-DataType"><a href="#17-4-2-7-DataType" class="headerlink" title="17.4.2.7 DataType"></a>17.4.2.7 DataType</h5><h5 id="17-4-2-8-IRI"><a href="#17-4-2-8-IRI" class="headerlink" title="17.4.2.8 IRI"></a>17.4.2.8 IRI</h5><h5 id="17-4-2-9-Bnode"><a href="#17-4-2-9-Bnode" class="headerlink" title="17.4.2.9 Bnode"></a>17.4.2.9 Bnode</h5><h5 id="17-4-4-2-10-strdt"><a href="#17-4-4-2-10-strdt" class="headerlink" title="17.4.4.2.10 strdt"></a>17.4.4.2.10 strdt</h5><h5 id="17-4-2-11-Strlang"><a href="#17-4-2-11-Strlang" class="headerlink" title="17.4.2.11 Strlang"></a>17.4.2.11 Strlang</h5><h5 id="17-4-2-12-UUIID"><a href="#17-4-2-12-UUIID" class="headerlink" title="17.4.2.12 UUIID"></a>17.4.2.12 UUIID</h5><h5 id="17-4-2-13-StruID-STRUID-STRUID"><a href="#17-4-2-13-StruID-STRUID-STRUID" class="headerlink" title="17.4.2.13 StruID STRUID STRUID"></a>17.4.2.13 StruID STRUID STRUID</h5><h4 id="17-4-3-字符串函数"><a href="#17-4-3-字符串函数" class="headerlink" title="17.4.3 字符串函数"></a>17.4.3 字符串函数</h4><h5 id="17-4-3-1-SPARQL-函数中的字符串"><a href="#17-4-3-1-SPARQL-函数中的字符串" class="headerlink" title="17.4.3.1 SPARQL 函数中的字符串"></a>17.4.3.1 SPARQL 函数中的字符串</h5><h6 id="17-4-3-1-1-字符串参数"><a href="#17-4-3-1-1-字符串参数" class="headerlink" title="17.4.3.1.1 字符串参数"></a>17.4.3.1.1 字符串参数</h6><h6 id="17-4-3-1-2-参数兼容性规则"><a href="#17-4-3-1-2-参数兼容性规则" class="headerlink" title="17.4.3.1.2 参数兼容性规则"></a>17.4.3.1.2 参数兼容性规则</h6><h6 id="17-4-3-1-3-字符串字面量返回类型"><a href="#17-4-3-1-3-字符串字面量返回类型" class="headerlink" title="17.4.3.1.3 字符串字面量返回类型"></a>17.4.3.1.3 字符串字面量返回类型</h6><h5 id="17-4-3-2-STRLEN"><a href="#17-4-3-2-STRLEN" class="headerlink" title="17.4.3.2 STRLEN"></a>17.4.3.2 STRLEN</h5><h5 id="17-4-3-3-SUBSTR"><a href="#17-4-3-3-SUBSTR" class="headerlink" title="17.4.3.3 SUBSTR"></a>17.4.3.3 SUBSTR</h5><h5 id="17-4-3-4-UCASE"><a href="#17-4-3-4-UCASE" class="headerlink" title="17.4.3.4 UCASE"></a>17.4.3.4 UCASE</h5><h5 id="17-4-3-5-LCASE"><a href="#17-4-3-5-LCASE" class="headerlink" title="17.4 .3.5 LCASE"></a>17.4 .3.5 LCASE</h5><h5 id="17-4-3-6-STRSTARTS"><a href="#17-4-3-6-STRSTARTS" class="headerlink" title="17.4.3.6 STRSTARTS"></a>17.4.3.6 STRSTARTS</h5><h5 id="17-4-3-7-STRENDS"><a href="#17-4-3-7-STRENDS" class="headerlink" title="17.4.3.7 STRENDS"></a>17.4.3.7 STRENDS</h5><h5 id="17-4-3-8-CONTAINS"><a href="#17-4-3-8-CONTAINS" class="headerlink" title="17.4.3.8 CONTAINS"></a>17.4.3.8 CONTAINS</h5><h5 id="17-4-3-9-STRBEFORE"><a href="#17-4-3-9-STRBEFORE" class="headerlink" title="17.4.3.9 STRBEFORE"></a>17.4.3.9 STRBEFORE</h5><h5 id="17-4-3-10-STRAFTER"><a href="#17-4-3-10-STRAFTER" class="headerlink" title="17.4.3.10 STRAFTER"></a>17.4.3.10 STRAFTER</h5><h5 id="17-4-3-11-ENCODE-FOR-URI"><a href="#17-4-3-11-ENCODE-FOR-URI" class="headerlink" title="17.4.3.11 ENCODE_FOR_URI"></a>17.4.3.11 ENCODE_FOR_URI</h5><h5 id="17-4-3-12-CONCAT"><a href="#17-4-3-12-CONCAT" class="headerlink" title="17.4.3.12 CONCAT"></a>17.4.3.12 CONCAT</h5><h5 id="17-4-3-13-langMatches"><a href="#17-4-3-13-langMatches" class="headerlink" title="17.4.3.13 langMatches"></a>17.4.3.13 langMatches</h5><h5 id="17-4-3-14-REGEX"><a href="#17-4-3-14-REGEX" class="headerlink" title="17.4.3.14 REGEX"></a>17.4.3.14 REGEX</h5><h5 id="17-4-3-15-REPLACE"><a href="#17-4-3-15-REPLACE" class="headerlink" title="17.4.3.15 REPLACE"></a>17.4.3.15 REPLACE</h5><h4 id="17-4-4-Functions-on-Numerics"><a href="#17-4-4-Functions-on-Numerics" class="headerlink" title="17.4.4 Functions on Numerics"></a>17.4.4 Functions on Numerics</h4><h5 id="17-4-4-1-abs"><a href="#17-4-4-1-abs" class="headerlink" title="17.4 .4.1 abs"></a>17.4 .4.1 abs</h5><h5 id="17-4-4-2-round"><a href="#17-4-4-2-round" class="headerlink" title="17.4.4.2 round"></a>17.4.4.2 round</h5><h5 id="17-4-4-3-ceil"><a href="#17-4-4-3-ceil" class="headerlink" title="17.4.4.3 ceil"></a>17.4.4.3 ceil</h5><h5 id="17-4-4-4-floor"><a href="#17-4-4-4-floor" class="headerlink" title="17.4.4.4 floor"></a>17.4.4.4 floor</h5><h5 id="17-4-4-5-RAND"><a href="#17-4-4-5-RAND" class="headerlink" title="17.4.4.5 RAND"></a>17.4.4.5 RAND</h5><h4 id="17-4-5-日期和时间函数"><a href="#17-4-5-日期和时间函数" class="headerlink" title="17.4.5 日期和时间函数"></a>17.4.5 日期和时间函数</h4><h5 id="17-4-5-1-现在"><a href="#17-4-5-1-现在" class="headerlink" title="17.4.5.1 现在"></a>17.4.5.1 现在</h5><h5 id="17-4-5-2-年"><a href="#17-4-5-2-年" class="headerlink" title="17.4.5.2 年"></a>17.4.5.2 年</h5><h5 id="17-4-5-3-月"><a href="#17-4-5-3-月" class="headerlink" title="17.4.5.3 月"></a>17.4.5.3 月</h5><h5 id="17-4-5-4-天"><a href="#17-4-5-4-天" class="headerlink" title="17.4.5.4 天"></a>17.4.5.4 天</h5><h5 id="17-4-5-5-小时"><a href="#17-4-5-5-小时" class="headerlink" title="17.4.5.5 小时"></a>17.4.5.5 小时</h5><h5 id="17-4-5-6-分钟"><a href="#17-4-5-6-分钟" class="headerlink" title="17.4.5.6 分钟"></a>17.4.5.6 分钟</h5><h5 id="17-4-5-7-秒"><a href="#17-4-5-7-秒" class="headerlink" title="17.4.5.7 秒"></a>17.4.5.7 秒</h5><h5 id="17-4-5-8-时区"><a href="#17-4-5-8-时区" class="headerlink" title="17.4.5.8 时区"></a>17.4.5.8 时区</h5><h5 id="17-4-5-9-tz"><a href="#17-4-5-9-tz" class="headerlink" title="17.4.5.9 tz"></a>17.4.5.9 tz</h5><h4 id="17-4-6-哈希函数"><a href="#17-4-6-哈希函数" class="headerlink" title="17.4.6 哈希函数"></a>17.4.6 哈希函数</h4><h5 id="17-4-6-1-MD5"><a href="#17-4-6-1-MD5" class="headerlink" title="17.4.6.1 MD5"></a>17.4.6.1 MD5</h5><h5 id="17-4-6-2-SHA1"><a href="#17-4-6-2-SHA1" class="headerlink" title="17.4.6.2 SHA1"></a>17.4.6.2 SHA1</h5><h5 id="17-4-6-3-SHA256"><a href="#17-4-6-3-SHA256" class="headerlink" title="17.4.6.3 SHA256"></a>17.4.6.3 SHA256</h5><h5 id="17-4-6-4-SHA384"><a href="#17-4-6-4-SHA384" class="headerlink" title="17.4.6.4 SHA384"></a>17.4.6.4 SHA384</h5><h5 id="17-4-6-5-SHA512"><a href="#17-4-6-5-SHA512" class="headerlink" title="17.4.6.5 SHA512"></a>17.4.6.5 SHA512</h5><h3 id="17-5-XPath-构造函数"><a href="#17-5-XPath-构造函数" class="headerlink" title="17.5 XPath 构造函数"></a>17.5 XPath 构造函数</h3><h3 id="17-6-可扩展值测试"><a href="#17-6-可扩展值测试" class="headerlink" title="17.6 可扩展值测试"></a>17.6 可扩展值测试</h3><h2 id="18-SPARQL-的定义"><a href="#18-SPARQL-的定义" class="headerlink" title="18 SPARQL 的定义"></a>18 SPARQL 的定义</h2><h3 id="18-1-初始定义"><a href="#18-1-初始定义" class="headerlink" title="18.1 初始定义"></a>18.1 初始定义</h3><h4 id="18-1-1-RDF-术语"><a href="#18-1-1-RDF-术语" class="headerlink" title="18.1.1 RDF 术语"></a>18.1.1 RDF 术语</h4><h4 id="18-1-2-简单文字"><a href="#18-1-2-简单文字" class="headerlink" title="18.1.2 简单文字"></a>18.1.2 简单文字</h4><h4 id="18-1-3-RDF-数据集"><a href="#18-1-3-RDF-数据集" class="headerlink" title="18.1.3 RDF 数据集"></a>18.1.3 RDF 数据集</h4><h4 id="18-1-4-查询变量"><a href="#18-1-4-查询变量" class="headerlink" title="18.1.4 查询变量"></a>18.1.4 查询变量</h4><h4 id="18-1-5-三重模式"><a href="#18-1-5-三重模式" class="headerlink" title="18.1.5 三重模式"></a>18.1.5 三重模式</h4><h4 id="18-1-6-基本图模式"><a href="#18-1-6-基本图模式" class="headerlink" title="18.1.6 基本图模式"></a>18.1.6 基本图模式</h4><h4 id="18-1-7-属性路径模式"><a href="#18-1-7-属性路径模式" class="headerlink" title="18.1.7 属性路径模式"></a>18.1.7 属性路径模式</h4><h4 id="18-1-8-解决方案映射"><a href="#18-1-8-解决方案映射" class="headerlink" title="18.1.8 解决方案映射"></a>18.1.8 解决方案映射</h4><h4 id="18-1-9-解决方案序列修饰符"><a href="#18-1-9-解决方案序列修饰符" class="headerlink" title="18.1.9 解决方案序列修饰符"></a>18.1.9 解决方案序列修饰符</h4><h4 id="18-1-10-SPARQL-查询"><a href="#18-1-10-SPARQL-查询" class="headerlink" title="18.1.10 SPARQL 查询"></a>18.1.10 SPARQL 查询</h4><h3 id="18-2-转换为-SPARQL-代数"><a href="#18-2-转换为-SPARQL-代数" class="headerlink" title="18.2 转换为 SPARQL 代数"></a>18.2 转换为 SPARQL 代数</h3><h4 id="18-2-1-变量范围"><a href="#18-2-1-变量范围" class="headerlink" title="18.2.1 变量范围"></a>18.2.1 变量范围</h4><h4 id="18-2-2-转换图形模式"><a href="#18-2-2-转换图形模式" class="headerlink" title="18.2.2 转换图形模式"></a>18.2.2 转换图形模式</h4><h5 id="18-2-2-1-扩展语法形式"><a href="#18-2-2-1-扩展语法形式" class="headerlink" title="18.2.2.1 扩展语法形式"></a>18.2.2.1 扩展语法形式</h5><h5 id="18-2-2-2-收集过滤器元素"><a href="#18-2-2-2-收集过滤器元素" class="headerlink" title="18.2.2.2 收集过滤器元素"></a>18.2.2.2 收集过滤器元素</h5><h5 id="18-2-2-3-翻译属性路径表达式"><a href="#18-2-2-3-翻译属性路径表达式" class="headerlink" title="18.2.2.3 翻译属性路径表达式"></a>18.2.2.3 翻译属性路径表达式</h5><h5 id="18-2-2-4-翻译属性路径模式"><a href="#18-2-2-4-翻译属性路径模式" class="headerlink" title="18.2.2.4 翻译属性路径模式"></a>18.2.2.4 翻译属性路径模式</h5><h5 id="18-2-2-5-转换基本图模式"><a href="#18-2-2-5-转换基本图模式" class="headerlink" title="18.2.2.5 转换基本图模式"></a>18.2.2.5 转换基本图模式</h5><h5 id="18-2-2-6-转换图模式"><a href="#18-2-2-6-转换图模式" class="headerlink" title="18.2.2.6 转换图模式"></a>18.2.2.6 转换图模式</h5><h5 id="18-2-2-7-组过滤器"><a href="#18-2-2-7-组过滤器" class="headerlink" title="18.2.2.7 组过滤器"></a>18.2.2.7 组过滤器</h5><h5 id="18-2-2-8-简化步骤"><a href="#18-2-2-8-简化步骤" class="headerlink" title="18.2.2.8 简化步骤"></a>18.2.2.8 简化步骤</h5><h4 id="18-2-3-映射图模式示例"><a href="#18-2-3-映射图模式示例" class="headerlink" title="18.2.3 映射图模式示例"></a>18.2.3 映射图模式示例</h4><h4 id="18-2-4-转换组、聚合、HAVING、最终VALUES子句和SELECT经验"><a href="#18-2-4-转换组、聚合、HAVING、最终VALUES子句和SELECT经验" class="headerlink" title="18.2.4 转换组、聚合、HAVING、最终VALUES子句和SELECT经验"></a>18.2.4 转换组、聚合、HAVING、最终VALUES子句和SELECT经验</h4><h5 id="18-2-4-1-分组和聚合"><a href="#18-2-4-1-分组和聚合" class="headerlink" title="18.2.4.1 分组和聚合"></a>18.2.4.1 分组和聚合</h5><h5 id="18-2-4-2-具有"><a href="#18-2-4-2-具有" class="headerlink" title="18.2.4.2 具有"></a>18.2.4.2 具有</h5><h5 id="18-2-4-3-值"><a href="#18-2-4-3-值" class="headerlink" title="18.2.4.3 值"></a>18.2.4.3 值</h5><h5 id="18-2-4-4-SELECT-表达式"><a href="#18-2-4-4-SELECT-表达式" class="headerlink" title="18.2.4.4 SELECT 表达式"></a>18.2.4.4 SELECT 表达式</h5><h4 id="18-2-5-转换解决方案修饰符"><a href="#18-2-5-转换解决方案修饰符" class="headerlink" title="18.2.5 转换解决方案修饰符"></a>18.2.5 转换解决方案修饰符</h4><h5 id="18-2-5-1-ORDER-BY"><a href="#18-2-5-1-ORDER-BY" class="headerlink" title="18.2.5.1 ORDER BY"></a>18.2.5.1 ORDER BY</h5><h5 id="18-2-5-2-投影"><a href="#18-2-5-2-投影" class="headerlink" title="18.2.5.2 投影"></a>18.2.5.2 投影</h5><h5 id="18-2-5-3-DISTINCT"><a href="#18-2-5-3-DISTINCT" class="headerlink" title="18.2.5.3 DISTINCT"></a>18.2.5.3 DISTINCT</h5><h5 id="18-2-5-4-减少"><a href="#18-2-5-4-减少" class="headerlink" title="18.2.5.4 减少"></a>18.2.5.4 减少</h5><h5 id="18-2-5-5-偏移和限制"><a href="#18-2-5-5-偏移和限制" class="headerlink" title="18.2.5.5 偏移和限制"></a>18.2.5.5 偏移和限制</h5><h5 id="18-2-5-6-最终代数表达式"><a href="#18-2-5-6-最终代数表达式" class="headerlink" title="18.2.5.6 最终代数表达式"></a>18.2.5.6 最终代数表达式</h5><h3 id="18-3-基本图形模式"><a href="#18-3-基本图形模式" class="headerlink" title="18.3 基本图形模式"></a>18.3 基本图形模式</h3><h4 id="18-3-1-SPARQL-基本图形模式匹配"><a href="#18-3-1-SPARQL-基本图形模式匹配" class="headerlink" title="18.3.1 SPARQL 基本图形模式匹配"></a>18.3.1 SPARQL 基本图形模式匹配</h4><h4 id="18-3-2-空白节点的处理"><a href="#18-3-2-空白节点的处理" class="headerlink" title="18.3.2 空白节点的处理"></a>18.3.2 空白节点的处理</h4><h3 id="18-4-属性路径模式"><a href="#18-4-属性路径模式" class="headerlink" title="18.4 属性路径模式"></a>18.4 属性路径模式</h3><h3 id="18-5-SPARQL-代数"><a href="#18-5-SPARQL-代数" class="headerlink" title="18.5 SPARQL 代数"></a>18.5 SPARQL 代数</h3><h4 id="18-5-1-聚合代数"><a href="#18-5-1-聚合代数" class="headerlink" title="18.5.1 聚合代数"></a>18.5.1 聚合代数</h4><h5 id="18-5-1-1-集合函数"><a href="#18-5-1-1-集合函数" class="headerlink" title="18.5.1.1 集合函数"></a>18.5.1.1 集合函数</h5><h5 id="18-5-1-2-计数"><a href="#18-5-1-2-计数" class="headerlink" title="18.5.1.2 计数"></a>18.5.1.2 计数</h5><h5 id="18-5-1-3-总和"><a href="#18-5-1-3-总和" class="headerlink" title="18.5.1.3 总和"></a>18.5.1.3 总和</h5><h5 id="18-5-1-4-平均"><a href="#18-5-1-4-平均" class="headerlink" title="18.5.1.4 平均"></a>18.5.1.4 平均</h5><h5 id="18-5-1-5-最小"><a href="#18-5-1-5-最小" class="headerlink" title="18.5.1.5 最小"></a>18.5.1.5 最小</h5><h5 id="18-5-1-6-最大"><a href="#18-5-1-6-最大" class="headerlink" title="18.5.1.6 最大"></a>18.5.1.6 最大</h5><h5 id="18-5-1-7-GroupConcat"><a href="#18-5-1-7-GroupConcat" class="headerlink" title="18.5.1.7 GroupConcat"></a>18.5.1.7 GroupConcat</h5><h5 id="18-5-1-8-样本"><a href="#18-5-1-8-样本" class="headerlink" title="18.5.1.8 样本"></a>18.5.1.8 样本</h5><h3 id="18-6-评估语义"><a href="#18-6-评估语义" class="headerlink" title="18.6 评估语义"></a>18.6 评估语义</h3><h3 id="18-7-扩展-SPARQL-基本图匹配"><a href="#18-7-扩展-SPARQL-基本图匹配" class="headerlink" title="18.7 扩展 SPARQL 基本图匹配"></a>18.7 扩展 SPARQL 基本图匹配</h3><h4 id="18-7-1-注释"><a href="#18-7-1-注释" class="headerlink" title="18.7.1 注释"></a>18.7.1 注释</h4><h2 id="19-SPARQL-语法"><a href="#19-SPARQL-语法" class="headerlink" title="19 SPARQL 语法"></a>19 SPARQL 语法</h2><h3 id="19-1-SPARQL-请求字符串"><a href="#19-1-SPARQL-请求字符串" class="headerlink" title="19.1 SPARQL 请求字符串"></a>19.1 SPARQL 请求字符串</h3><h3 id="19-2-代码点转义序列"><a href="#19-2-代码点转义序列" class="headerlink" title="19.2 代码点转义序列"></a>19.2 代码点转义序列</h3><h3 id="19-3-空白"><a href="#19-3-空白" class="headerlink" title="19.3 空白"></a>19.3 空白</h3><h3 id="19-4-注释"><a href="#19-4-注释" class="headerlink" title="19.4 注释"></a>19.4 注释</h3><h3 id="19-5-IRI-参考"><a href="#19-5-IRI-参考" class="headerlink" title="19.5 IRI 参考"></a>19.5 IRI 参考</h3><h3 id="19-6-空白节点和空白节点标签"><a href="#19-6-空白节点和空白节点标签" class="headerlink" title="19.6 空白节点和空白节点标签"></a>19.6 空白节点和空白节点标签</h3><h3 id="19-7-字符串中的转义序列"><a href="#19-7-字符串中的转义序列" class="headerlink" title="19.7 字符串中的转义序列"></a>19.7 字符串中的转义序列</h3><h3 id="19-8-语法"><a href="#19-8-语法" class="headerlink" title="19.8 语法"></a>19.8 语法</h3><h2 id="20-一致性"><a href="#20-一致性" class="headerlink" title="20 一致性"></a>20 一致性</h2><h2 id="21-安全注意事项（信息性）"><a href="#21-安全注意事项（信息性）" class="headerlink" title="21 安全注意事项（信息性）"></a>21 安全注意事项（信息性）</h2><h2 id="22-互联网媒体类型、文件扩展名和-Macintosh文件类型"><a href="#22-互联网媒体类型、文件扩展名和-Macintosh文件类型" class="headerlink" title="22 互联网媒体类型、文件扩展名和 Macintosh文件类型"></a>22 互联网媒体类型、文件扩展名和 Macintosh文件类型</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="A-参考文献"><a href="#A-参考文献" class="headerlink" title="A 参考文献"></a>A 参考文献</h3><h4 id="A-1-规范性参考文献"><a href="#A-1-规范性参考文献" class="headerlink" title="A.1 规范性参考文献"></a>A.1 规范性参考文献</h4><h4 id="A-2-其他参考文献"><a href="#A-2-其他参考文献" class="headerlink" title="A.2 其他参考文献"></a>A.2 其他参考文献</h4><hr><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>RDF 是一种有向的、标记的图形数据格式，用于表示 Web 中的信息。 RDF 通常用于表示个人信息、社交网络、有关数字工件的元数据等，以及提供一种集成不同信息源的方法。本规范定义了 RDF 的 SPARQL 查询语言的语法和语义。</p><p>RDF 的 SPARQL 查询语言旨在满足 RDF 数据访问工作组在 RDF 数据访问用例和要求 [UCNR] 和 SPARQL 新特性和基本原理 [UCNR2] 中确定的用例和要求。</p><h3 id="1-1-文件大纲"><a href="#1-1-文件大纲" class="headerlink" title="1.1 文件大纲"></a>1.1 文件大纲</h3><p>除非章节标题中另有说明，否则本文件中的所有章节和附录均为规范性的。</p><p>文档的这一部分，即第 1 节，介绍了 SPARQL 查询语言规范。它介绍了本规范文档的组织以及整个规范中使用的约定。</p><p>规范的第 2 节通过一系列示例查询和查询结果介绍了 SPARQL 查询语言本身。第 3 节继续介绍 SPARQL 查询语言，并提供更多示例来展示 SPARQL 表达对出现在查询结果中的 RDF 术语的约束的能力。</p><p>第 4 节详细介绍了 SPARQL 查询语言的语法。它是语言完整语法的伴侣，并定义了语法结构如何表示 IRI、空白节点、文字和变量。第 4 节还定义了几个语法结构的含义，这些语法结构用作更详细表达的句法糖。</p><p>第 5 节介绍了基本图模式和组图模式，它们是构建更复杂 SPARQL 查询模式的基础。第 6、7 和 8 节介绍了将 SPARQL 图模式组合成更大图模式的结构。特别是，第 6 节介绍了使查询的某些部分成为可选的能力；第 7 节介绍了表达替代图形模式的析取的能力；第 8 节介绍了测试信息缺失的模式。</p><p>第 9 节为图形模式匹配添加了属性路径，给出了查询的紧凑表示，并且还能够匹配图形中任意长度的路径。</p><p>第 10 节描述了 SPARQL 中可能的赋值形式。</p><p>第 11 节介绍了对结果进行分组和聚合的机制，可以将其合并为第 12 节中描述的子查询。</p><p>第 13 节介绍了将查询的一部分约束到特定源图的能力。第 13 节还介绍了 SPARQL 为查询定义源图的机制。</p><p>第 14 节参考了单独的文档 SPARQL 1.1 Federated Query。</p><p>第 15 节定义了通过排序、切片、投影、限制和删除一系列解决方案中的重复项来影响查询解决方案的结构。</p><p>第 16 节定义了产生不同形式结果的四种类型的 SPARQL 查询。</p><p>第 17 节定义了 SPARQL 的可扩展值测试和表达框架。它提供了可用于约束查询结果中出现的值并计算查询返回的新值的函数和运算符。</p><p>第 18 节是 SPARQL 图模式和解决方案修饰符评估的正式定义。</p><p>第 19 节包含 SPARQL 查询和 SPARQL 更新语言语法的规范定义，由 EBNF 表示法表示的语法给出。</p><h3 id="1-2-文档约定-1"><a href="#1-2-文档约定-1" class="headerlink" title="1.2 文档约定"></a>1.2 文档约定</h3><p>在本文档中，除非另有说明，否则示例假定以下命名空间前缀绑定：</p><p><img src="https://gitee.com/chaoyuan-mao/img/raw/master//image-20220604161444997.png" alt="image-20220604161444997"></p><h4 id="1-2-2-数据说明"><a href="#1-2-2-数据说明" class="headerlink" title="1.2.2 数据说明"></a>1.2.2 数据说明</h4><p>本文档使用 Turtle [TURTLE] 数据格式明确显示每个三元组。 Turtle 允许使用前缀缩写 IRI：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .</span><br><span class="line">@prefix :     &lt;http://example.org/book/&gt; .</span><br><span class="line">:book1  dc:title  &quot;SPARQL Tutorial&quot; .</span><br></pre></td></tr></table></figure><h4 id="1-2-3-结果说明"><a href="#1-2-3-结果说明" class="headerlink" title="1.2.3 结果说明"></a>1.2.3 结果说明</h4><p>结果集以表格形式显示。</p><p><img src="image/image-20220604161639223.png" alt="image-20220604161639223"></p><p>“绑定”是一对（变量，RDF 术语）。在此结果集中，存在三个变量：x、y 和 z（显示为列标题）。每个解决方案在表格正文中显示为一行。这里有一个单一的解决方案，其中变量 x 绑定到“Alice”，变量 y 绑定到<code>&lt;http://example/a&gt;</code>，变量 z 不绑定到 RDF 项。变量不需要绑定在解决方案中。</p><h4 id="1-2-4-术语-1"><a href="#1-2-4-术语-1" class="headerlink" title="1.2.4 术语"></a>1.2.4 术语</h4><p>SPARQL 语言包括 IRI，它是省略空格的 RDF URI 引用的子集。请注意，SPARQL 查询中的所有 IRI 都是绝对的；它们可能包含也可能不包含片段标识符 [RFC3987，第 3.1 节]。 IRI 包括 URI [RFC3986] 和 URL。 SPARQL 语法中的缩写形式（相对 IRI 和前缀名称）被解析为生成绝对 IRI。</p><p>以下术语在 RDF 概念和抽象语法 [CONCEPTS] 中定义并在 SPARQL 中使用：</p><ul><li>IRI (corresponds to the Concepts and Abstract Syntax term “RDF URI reference”)  RDF 图内的 URI 引用（RDF URI 引用）是一个 Unicode 字符串</li><li>literal  RDF 图中的文字包含一个或两个命名组件。</li><li>lexical form 所有文字都有一个词法形式，即 Unicode [UNICODE] 字符串，它应该是 Normal Form C [NFC]。</li><li>plain literal  普通文字具有词汇形式和可选的语言标记，如 [RFC-3066] 定义的，标准化为小写。</li><li>language tag</li><li>typed literal  类型化文字有一个词法形式和一个作为 RDF URI 引用的数据类型 URI。</li><li>datatype IRI (corresponds to the Concepts and Abstract Syntax term “datatype URI”)</li><li>blank node  RDF 图中的空白节点是从无限集合中绘制的。这组空白节点、所有 RDF URI 引用的集合和所有文字的集合是成对不相交的。否则，这组空白节点是任意的。<br>RDF 不参考空白节点的任何内部结构。给定两个空白节点，可以确定它们是否相同。</li></ul><p>此外，我们定义了以下术语：</p><ul><li>RDF Term, which includes IRIs, blank nodes and literals</li><li>Simple Literal, which covers literals without language tag or datatype IRI</li></ul><hr><h2 id="2-制作简单的查询（信息性）"><a href="#2-制作简单的查询（信息性）" class="headerlink" title="2 制作简单的查询（信息性）"></a>2 制作简单的查询（信息性）</h2><p>大多数形式的 SPARQL 查询都包含一组三元组模式，称为基本图模式。三元组模式类似于 RDF 三元组，只是主语、谓语和宾语中的每一个都可以是一个变量。基本图模式匹配 RDF 数据的子图，当来自该子图的 RDF 项可以替换变量并且结果是与子图等效的 RDF 图时。</p><h3 id="2-1-编写一个简单的查询"><a href="#2-1-编写一个简单的查询" class="headerlink" title="2.1 编写一个简单的查询"></a>2.1 编写一个简单的查询</h3><p>下面的示例显示了一个 SPARQL 查询，用于从给定的数据图中查找书名。查询由两部分组成：SELECT 子句标识要出现在查询结果中的变量，WHERE 子句提供与数据图匹配的基本图模式。此示例中的基本图形模式由一个三元组模式组成，在对象位置有一个变量 (?title)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Data:</span><br><span class="line">&lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; &quot;SPARQL Tutorial&quot; .</span><br><span class="line"></span><br><span class="line">Query:</span><br><span class="line">SELECT ?title</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Query Result:</span><br><span class="line">title</span><br><span class="line">&quot;SPARQL Tutorial&quot;</span><br></pre></td></tr></table></figure><p>2.2 多重匹配</p><p>查询的结果是一个解决方案序列，对应于查询的图形模式匹配数据的方式。一个查询可能有零个、一个或多个解决方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Data:</span><br><span class="line">@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .</span><br><span class="line">_:a  foaf:name   &quot;Johnny Lee Outlaw&quot; .</span><br><span class="line">_:a  foaf:mbox   &lt;mailto:jlow@example.com&gt; .</span><br><span class="line">_:b  foaf:name   &quot;Peter Goodguy&quot; .</span><br><span class="line">_:b  foaf:mbox   &lt;mailto:peter@example.org&gt; .</span><br><span class="line">_:c  foaf:mbox   &lt;mailto:carol@example.org&gt; .</span><br><span class="line"></span><br><span class="line">Query:</span><br><span class="line">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;</span><br><span class="line">SELECT ?name ?mbox</span><br><span class="line">WHERE</span><br><span class="line">  &#123; ?x foaf:name ?name .</span><br><span class="line">    ?x foaf:mbox ?mbox &#125;</span><br><span class="line">    </span><br><span class="line">Query Result:</span><br><span class="line">namembox</span><br><span class="line">&quot;Johnny Lee Outlaw&quot;&lt;mailto:jlow@example.com&gt;</span><br><span class="line">&quot;Peter Goodguy&quot;&lt;mailto:peter@example.org&gt;</span><br></pre></td></tr></table></figure><p>每个解决方案都提供了一种方法，可以将所选变量绑定到 RDF 术语，以便查询模式与数据匹配。结果集给出了所有可能的解决方案。在上面的示例中，以下两个数据子集提供了两个匹配项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_:a foaf:name  &quot;Johnny Lee Outlaw&quot; .</span><br><span class="line">_:a foaf:box   &lt;mailto:jlow@example.com&gt; .</span><br><span class="line"></span><br><span class="line">_:b foaf:name  &quot;Peter Goodguy&quot; .</span><br><span class="line">_:b foaf:box   &lt;mailto:peter@example.org&gt; .</span><br></pre></td></tr></table></figure><p>这是一个基本的图形模式匹配；查询模式中使用的所有变量都必须在每个解决方案中绑定。</p><h3 id="2-3-匹配-RDF-文字-1"><a href="#2-3-匹配-RDF-文字-1" class="headerlink" title="2.3 匹配 RDF 文字"></a>2.3 匹配 RDF 文字</h3><p>下面的数据包含三个 RDF 文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@prefix dt:   &lt;http://example.org/datatype#&gt; .</span><br><span class="line">@prefix ns:   &lt;http://example.org/ns#&gt; .</span><br><span class="line">@prefix :     &lt;http://example.org/ns#&gt; .</span><br><span class="line">@prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt; .</span><br><span class="line"></span><br><span class="line">:x   ns:p     &quot;cat&quot;@en .</span><br><span class="line">:y   ns:p     &quot;42&quot;^^xsd:integer .</span><br><span class="line">:z   ns:p     &quot;abc&quot;^^dt:specialDatatype .</span><br></pre></td></tr></table></figure><p>请注意，在 Turtle 中，“cat”@en 是一个 RDF 文字，具有词汇形式“cat”和语言标记“en”；</p><p><code>&quot;42&quot;^^xsd:integer</code> 是数据类型为 <code>http://www.w3.org/2001/XMLSchema#integer</code> 的类型化文字； </p><p><code>&quot;abc&quot;^^dt:specialDatatype</code> 是一个类型化的文字，数据类型为 <code>http://example.org/datatype#specialDatatype</code>。</p><p>此 RDF 数据是 2.3.1-2.3.3 节中查询示例的数据图。</p><h4 id="2-3-1-用语言标签匹配文字"><a href="#2-3-1-用语言标签匹配文字" class="headerlink" title="2.3.1 用语言标签匹配文字"></a>2.3.1 用语言标签匹配文字</h4><p>SPARQL 中的语言标签使用 @ 和语言标签表示，如<a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">Best Common Practice 47</a> [<a href="https://www.w3.org/TR/sparql11-query/#BCP47">BCP47</a>] 中所定义。</p><p>以下查询没有解决方案，因为“cat”与“cat”@en 不是同一个 RDF 文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT ?v WHERE &#123; ?v ?p &quot;cat&quot; &#125;  # 无结果</span><br><span class="line">SELECT ?v WHERE &#123; ?v ?p &quot;cat&quot;@en &#125;</span><br><span class="line"></span><br><span class="line">v</span><br><span class="line">&lt;http://example.org/ns#x&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇blog</title>
      <link href="/2022/06/19/blog/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2022/06/19/blog/%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>第一次哦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读</title>
      <link href="/2022/04/17/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/WenXianZongJie/"/>
      <url>/2022/04/17/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/WenXianZongJie/</url>
      
        <content type="html"><![CDATA[<p>文献阅读笔记</p><span id="more"></span><hr><hr><h1 id="Attention-Based-Vandalism-Detection-in-OpenStreetMap（OpenStreetMap中基于注意的破坏检测）"><a href="#Attention-Based-Vandalism-Detection-in-OpenStreetMap（OpenStreetMap中基于注意的破坏检测）" class="headerlink" title="Attention-Based Vandalism Detection in OpenStreetMap（OpenStreetMap中基于注意的破坏检测）"></a>Attention-Based Vandalism Detection in OpenStreetMap（OpenStreetMap中基于注意的破坏检测）</h1><ul><li><p>任务：OpenStreetMap破坏检测</p></li><li><p>模型：OVID</p></li><li><p>数据集：构建的OSM-Reverts和OSM-Manual</p><ul><li>数据来源：OpenStreetMap</li></ul></li><li><p>其他：</p></li></ul><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>针对于OSM协作众包Web地图，破坏行为检测是支持信任和维护 OSM 透明度的一项关键任务。提出了一种基于注意力的新型 OSM 破坏检测方法OVID，体系结构采用多头注意机制来有效地汇总指示OSM变更集的破坏行为的信息。同时首次从OSM编辑历史中提取了一个真实世界的故意破坏事件数据集。</p><hr><h1 id="A-review-of-location-encoding-for-GeoAI-methods-and-applications（GeoAI的位置编码回顾：方法和应用）"><a href="#A-review-of-location-encoding-for-GeoAI-methods-and-applications（GeoAI的位置编码回顾：方法和应用）" class="headerlink" title="A review of location encoding for GeoAI: methods and applications（GeoAI的位置编码回顾：方法和应用）"></a>A review of location encoding for GeoAI: methods and applications（GeoAI的位置编码回顾：方法和应用）</h1><ul><li>任务：</li><li>模型：</li><li>数据集：</li><li>其他：综述</li></ul><p>对位置编码、潜在应用以及需要解决的关键挑战的系统评价。在隐藏的嵌入空间中对各种类型的空间数据（例如点、折线、多边形、图形或栅格）进行编码，才能使它们可以很容易地整合到深度学习模型中。首先提出了位置编码的定义，并讨论其在GeoAI研究中的必要性。然后，对位置编码研究的现状进行了全面调研。根据输入和编码方法将位置编码模型分为不同的类别，并根据它们是否是参数、多尺度、距离保持和方向感知进行比较。证明了现有的位置编码器可以在一个框架下统一。最后讨论了位置编码的应用，指出了未来需要解决挑战。</p><p>未来研究方向：</p><ul><li>区域表示学习</li><li>时空点编码</li><li>球面位置编码</li><li>位置编码的无监督学习</li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 文献阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode_c++</title>
      <link href="/2022/03/31/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/vscode-c/"/>
      <url>/2022/03/31/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/vscode-c/</url>
      
        <content type="html"><![CDATA[<p>在VSCode中配置C/C++环境。</p><span id="more"></span><h2 id="1-调试环境的步骤。"><a href="#1-调试环境的步骤。" class="headerlink" title="1. 调试环境的步骤。"></a>1. 调试环境的步骤。</h2><blockquote><p>主要参考：</p><p><a href="https://www.cnblogs.com/roger-yu/p/15348275.html">https://www.cnblogs.com/roger-yu/p/15348275.html</a></p></blockquote><h2 id="2-安装说明："><a href="#2-安装说明：" class="headerlink" title="2. 安装说明："></a>2. 安装说明：</h2><h3 id="2-1-VsCode插件作用"><a href="#2-1-VsCode插件作用" class="headerlink" title="2.1 VsCode插件作用"></a>2.1 VsCode插件作用</h3><p>实现自动补全、代码跳转以及代码调试等功能的支持。</p><h3 id="2-2-为什么要安装MinGW"><a href="#2-2-为什么要安装MinGW" class="headerlink" title="2.2 为什么要安装MinGW"></a>2.2 为什么要安装MinGW</h3><p>MinGW(Minimalist GNU For Windows)是个精简的Windows平台C/C++、ADA及Fortran编译器，相比Cygwin而言，体积要小很多，使用较为方便。</p><p>MinGW最大的特点就是编译出来的可执行文件能够独立在Windows上运行。</p><blockquote><p>参考：<a href="http://jianshu.com/p/e9ff7b654c4a">http://jianshu.com/p/e9ff7b654c4a</a></p></blockquote><h2 id="3-遇到的问题："><a href="#3-遇到的问题：" class="headerlink" title="3. 遇到的问题："></a>3. 遇到的问题：</h2><p>编辑 launch.json 配置文件</p><p>这个文件和它所说的不一样，我是创建了一个新的 launch.json，然后把内容全部换成了他所提供的那些内容。注意要把”miDebuggerPath”换成<strong>自己</strong>对应的路径！！</p><p>至此，基本完成！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Start</title>
      <link href="/2022/03/26/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Start/"/>
      <url>/2022/03/26/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Start/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++</title>
      <link href="/2022/03/09/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/c/"/>
      <url>/2022/03/09/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/c/</url>
      
        <content type="html"><![CDATA[<p>还没想好</p><span id="more"></span><p>C++用memset函数初始化</p><p><a href="https://www.cnblogs.com/see-you-again/p/14053252.html">https://www.cnblogs.com/see-you-again/p/14053252.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C必备</title>
      <link href="/2022/03/06/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/C%E5%BF%85%E5%A4%87/"/>
      <url>/2022/03/06/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/C%E5%BF%85%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.runoob.com/cprogramming/c-intro.html">https://www.runoob.com/cprogramming/c-intro.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>尚未解决的问题</title>
      <link href="/2022/03/04/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%B0%9A%E6%9C%AA%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/04/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%B0%9A%E6%9C%AA%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>乱七八糟的东西。</p><span id="more"></span><p>Hexo的markdown解析器会把英文的单(双)引号都自动转换成中文的单(双)引号，请问如何避免？</p><p><a href="https://www.zhihu.com/question/285274130">https://www.zhihu.com/question/285274130</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="/2022/03/03/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/vim/"/>
      <url>/2022/03/03/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/vim/</url>
      
        <content type="html"><![CDATA[<p>想起啥学啥，哈哈哈哈！</p><span id="more"></span><p>vim 块选择 多行操作</p><p>v</p><p>V</p><p><a href="https://blog.csdn.net/qiqiaiairen/article/details/51475951">https://blog.csdn.net/qiqiaiairen/article/details/51475951</a></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch高效调参</title>
      <link href="/2022/03/02/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Pytorch%E9%AB%98%E6%95%88%E8%B0%83%E5%8F%82/"/>
      <url>/2022/03/02/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Pytorch%E9%AB%98%E6%95%88%E8%B0%83%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<h1 id="1设置多组参数进行组合，然后迭代循环跑代码"><a href="#1设置多组参数进行组合，然后迭代循环跑代码" class="headerlink" title="1设置多组参数进行组合，然后迭代循环跑代码"></a>1设置多组参数进行组合，然后迭代循环跑代码</h1><p><a href="https://zhuanlan.zhihu.com/p/343760600">https://zhuanlan.zhihu.com/p/343760600</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>capability</title>
      <link href="/2022/03/02/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/capability/"/>
      <url>/2022/03/02/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/capability/</url>
      
        <content type="html"><![CDATA[<h1 id="GeForce-RTX-3090-with-CUDA-capability-sm-86-is-not-compatible-with-the-current-PyTorch-installation"><a href="#GeForce-RTX-3090-with-CUDA-capability-sm-86-is-not-compatible-with-the-current-PyTorch-installation" class="headerlink" title="GeForce RTX 3090 with CUDA capability sm_86 is not compatible with the current PyTorch installation."></a>GeForce RTX 3090 with CUDA capability sm_86 is not compatible with the current PyTorch installation.</h1><p><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=11.3</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Paramagnetism/article/details/115221478">https://blog.csdn.net/Paramagnetism/article/details/115221478</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zotero高级使用</title>
      <link href="/2022/03/01/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Zotero%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/01/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Zotero%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiangduixuexi/article/details/120930192">https://blog.csdn.net/xiangduixuexi/article/details/120930192</a></p><p><a href="https://blog.csdn.net/wwlswj/article/details/113416164">https://blog.csdn.net/wwlswj/article/details/113416164</a></p><p><a href="https://blog.csdn.net/fan_tanker/article/details/120194543">https://blog.csdn.net/fan_tanker/article/details/120194543</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch学习</title>
      <link href="/2022/02/27/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/PyTorch%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/27/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/PyTorch%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>总结学习到的新知识。</p><span id="more"></span><p><strong>F.normalize计算理解</strong></p><p>函数定义</p><p>torch.nn.functional.normalize(input, p=2.0, dim=1, eps=1e-12, out=None)</p><p>功能：将某一个维度除以那个维度对应的范数(默认是2范数)。</p><p>使用：</p><p>F.normalize(data, p=2/1, dim=0/1/-1) 将某一个维度除以那个维度对应的范数(默认是2范数)</p><p>data:输入的数据（tensor）</p><p>p:L2/L1_norm运算</p><p>dim:0表示按列操作，则每列都是除以该列下平方和的开方；1表示按行操作，则每行都是除以该行下所有元素平方和的开方</p><p><a href="https://blog.csdn.net/lj2048/article/details/118115681">https://blog.csdn.net/lj2048/article/details/118115681</a></p><hr><p><strong>torch.norm的理解</strong></p><p>对输入的Tensor求范数</p><p><a href="https://blog.csdn.net/goodxin_ie/article/details/84657975">https://blog.csdn.net/goodxin_ie/article/details/84657975</a></p><p><a href="https://www.cnblogs.com/wanghui-garcia/p/11266298.html">https://www.cnblogs.com/wanghui-garcia/p/11266298.html</a></p><hr><p><strong>关于torch.flatten的笔记</strong></p><p><a href="https://www.cnblogs.com/dilthey/p/12376179.html">https://www.cnblogs.com/dilthey/p/12376179.html</a></p><hr><p>Xavier均匀分布:<strong>nn.init.xavier_uniform_</strong></p><p><a href="https://blog.csdn.net/qq_32893343/article/details/103468874">https://blog.csdn.net/qq_32893343/article/details/103468874</a></p><p><a href="https://www.cnblogs.com/jfdwd/p/11269622.html">https://www.cnblogs.com/jfdwd/p/11269622.html</a></p><hr><p>爆内存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>] = <span class="string">&#x27;1&#x27;</span>  <span class="comment">#换卡</span></span><br></pre></td></tr></table></figure><hr><p>nn.Embedding.from_pretrained</p><p><a href="https://zhuanlan.zhihu.com/p/403474687">https://zhuanlan.zhihu.com/p/403474687</a></p><hr><p>torch.topk</p><p><a href="https://blog.csdn.net/qq_45193872/article/details/119878804">https://blog.csdn.net/qq_45193872/article/details/119878804</a></p><hr><p>torch之Dataloader详解</p><p><a href="https://blog.csdn.net/g11d111/article/details/81504637">https://blog.csdn.net/g11d111/article/details/81504637</a></p><hr><p>关于torch.nonzero() 详解</p><p><a href="https://blog.csdn.net/wangxuecheng666/article/details/120639138">https://blog.csdn.net/wangxuecheng666/article/details/120639138</a></p><hr><p>torch.eq()方法</p><p><a href="https://blog.csdn.net/dongjinkun/article/details/115254256">https://blog.csdn.net/dongjinkun/article/details/115254256</a></p><hr><p>numpy 和pytorch的矩阵/张量拼接</p><p><a href="https://www.jianshu.com/p/85d27161b981">https://www.jianshu.com/p/85d27161b981</a></p><hr><p>Pytorch对tensor求绝对值</p><p><a href="https://www.cnblogs.com/haifwu/p/12818143.html">https://www.cnblogs.com/haifwu/p/12818143.html</a></p><hr><p>Pytorch Tensor基本数学运算</p><p><a href="https://blog.csdn.net/weicao1990/article/details/93738722">https://blog.csdn.net/weicao1990/article/details/93738722</a></p><hr><p>将数组array转换为张量Tensor</p><p><a href="https://blog.csdn.net/weixin_47156261/article/details/116565884">https://blog.csdn.net/weixin_47156261/article/details/116565884</a></p><hr><p>PyTorch中的Variable变量详解</p><p><a href="https://www.jb51.net/article/177996.htm">https://www.jb51.net/article/177996.htm</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenKE问题</title>
      <link href="/2022/02/26/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/OpenKE%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/26/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/OpenKE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>ModuleNotFoundError: No module named ‘torch’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://pytorch.org/get-started/locally/</span></span><br><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=11.3  </span><br></pre></td></tr></table></figure><p>ModuleNotFoundError: No module named ‘tqdm’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tqdm</span><br></pre></td></tr></table></figure><p>ModuleNotFoundError: No module named ‘sklearn’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sklearn</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OpenKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode使用sftp快速同步服务器文件</title>
      <link href="/2022/02/26/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Vscode%E4%BD%BF%E7%94%A8sftp%E5%BF%AB%E9%80%9F%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6/"/>
      <url>/2022/02/26/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Vscode%E4%BD%BF%E7%94%A8sftp%E5%BF%AB%E9%80%9F%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_24798295/article/details/90228795">https://blog.csdn.net/qq_24798295/article/details/90228795</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> sftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode切换运行环境</title>
      <link href="/2022/02/25/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Vscode%E5%88%87%E6%8D%A2%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/02/25/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Vscode%E5%88%87%E6%8D%A2%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/Mr_Cat123/article/details/103036190">https://blog.csdn.net/Mr_Cat123/article/details/103036190</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看本地安装的所有npm包</title>
      <link href="/2022/02/23/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E7%9A%84%E6%89%80%E6%9C%89npm%E5%8C%85/"/>
      <url>/2022/02/23/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E7%9A%84%E6%89%80%E6%9C%89npm%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>各位肯定安装过很多的全局npm包。就是 npm install xxx -g，这样的，时间一久，完全记不得自己装过那些东西，有时你想看一下或者删除一些无用的包，下面就记录一下该操作。</p><span id="more"></span><ol><li>查看</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list -g --depth 0  // 若需要权限 请加上 sudo 命令</span><br></pre></td></tr></table></figure><ol start="2"><li>更新</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm update -g xxx</span><br></pre></td></tr></table></figure><ol start="3"><li>删除</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall -g xxx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Complex代码运行问题</title>
      <link href="/2022/02/23/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Complex%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/23/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Complex%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>解决运行complex源码中的一些问题。</p><span id="more"></span><p>1、报错：AttributeError: module ‘numpy.distutils.<strong>config</strong>‘ has no attribute ‘blas_opt_info’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">降级处理</span></span><br><span class="line">pip3 install --upgrade numpy==1.20.3</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/70839312/module-numpy-distutils-config-has-no-attribute-blas-opt-info">https://stackoverflow.com/questions/70839312/module-numpy-distutils-config-has-no-attribute-blas-opt-info</a></p><p>2、文档中 THEANO_FLAGS=’device=gpu’ python fb15k_run.py  GPU更新了，需要修改！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">THEANO_FLAGS=&#x27;device=cuda*&#x27; python fb15k_run.py</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nohop 实现后端运行</span></span><br><span class="line">THEANO_FLAGS=&#x27;device=cuda*&#x27; nohup  python   -u wn18_run.py &gt; wn18_complex.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> complex </tag>
            
            <tag> 解决bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不蒜子统计与live2d的冲突</title>
      <link href="/2022/02/22/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E4%B8%8Elive2d%E7%9A%84%E5%86%B2%E7%AA%81/"/>
      <url>/2022/02/22/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E4%B8%8Elive2d%E7%9A%84%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<p>不蒜子统计异常！！</p><span id="more"></span><p><a href="https://github.com/blinkfox/hexo-theme-matery/issues/458">https://github.com/blinkfox/hexo-theme-matery/issues/458</a></p><p><a href="https://blog.csdn.net/weixin_37891983/article/details/105362748">https://blog.csdn.net/weixin_37891983/article/details/105362748</a></p><p><a href="https://blog.csdn.net/qianghaohao/article/details/90736310">https://blog.csdn.net/qianghaohao/article/details/90736310</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda+PyTorch</title>
      <link href="/2022/02/21/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Anaconda-PyTorch/"/>
      <url>/2022/02/21/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Anaconda-PyTorch/</url>
      
        <content type="html"><![CDATA[<h1 id="Anaconda-PyTorch"><a href="#Anaconda-PyTorch" class="headerlink" title="Anaconda+PyTorch"></a>Anaconda+PyTorch</h1><p>Anaconda、PyTorch</p><span id="more"></span><p>下载Anaconda</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wegt https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-2021.05-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>#查看当前环境列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure><p>新建立环境,注意必须python和3.6之间不可以有空格，不加python版本号的话，不会生产bin等文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n test01 python=3.7</span><br></pre></td></tr></table></figure><p>test01 是 env_name<br>进入env_name环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda activate test01 </span><br><span class="line">source activate test01 </span><br><span class="line">pytorch</span><br></pre></td></tr></table></figure><p>删除虚拟环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n your_env_name --<span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>换清华源，提高下载速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes#下载时显示文件来源</span><br></pre></td></tr></table></figure><p>官网中，下载指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision cudatoolkit=10.1 -c pytorch</span><br></pre></td></tr></table></figure><p>去掉-c后面部分，（它指定默认地址下属路径，若不删掉，他就又去default地址找资源了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision cudatoolkit=10.1 </span><br></pre></td></tr></table></figure><p>换源也可参考：</p><p><a href="https://www.cnblogs.com/hmy-666/p/12485851.html">https://www.cnblogs.com/hmy-666/p/12485851.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> anaconda </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python必备</title>
      <link href="/2022/02/17/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Python%E5%BF%85%E5%A4%87/"/>
      <url>/2022/02/17/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Python%E5%BF%85%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>Python3</p><span id="more"></span><h2 id="Python3-基础语法"><a href="#Python3-基础语法" class="headerlink" title="Python3 基础语法"></a>Python3 基础语法</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp-1252 -*-</span></span><br></pre></td></tr></table></figure><p>上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。</p><h3 id="python保留字"><a href="#python保留字" class="headerlink" title="python保留字"></a>python保留字</h3><p>保留字即关键字，我们不能把它们用作任何标识符名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line">keyword.kwlist</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>多行注释可以用多个 <strong>#</strong> 号，还有 ‘’’ 和 “””：</p><h3 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h3><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <strong>{}</strong> 。</p><p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p><h3 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h3><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 *<em>\*</em> 来实现多行语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="comment"># 在 [], &#123;&#125;, 或 () 中的多行语句，不需要使用反斜杠 \ </span></span><br><span class="line"> total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h3><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p><ul><li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li><li><strong>bool</strong> (布尔), 如 True。</li><li><strong>float</strong> (浮点数), 如 1.23、3E-2</li><li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><ul><li>Python 中单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用完全相同。</li><li>使用三引号( ‘’’ 或 “”” )可以指定一个多行字符串。</li><li>转义符 \ 。</li><li>反斜杠可以用来转义，使用 <strong>r</strong> 可以让反斜杠不发生转义。 如 <strong>r”this is a line with \n”</strong> 则 <strong>\n</strong> 会显示，并不是换行。</li><li>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong>。</li><li>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始。</li><li>Python 中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落，</span></span><br><span class="line"><span class="string">可以由多行组成&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p><p><strong>记住：</strong>空行也是程序代码的一部分。</p><h3 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure><p>以上代码中 ，<strong>\n\n</strong> 在结果输出前会输出两个新的空行。一旦用户按下 <strong>enter</strong> 键时，程序将退出。</p><h3 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h3><p>Python 可以在同一行中使用多条语句，语句之间使用分号 <strong>;</strong> 分割。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h3><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p><p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p><p>我们将首行及后面的代码组称为一个子句(clause)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression : </span><br><span class="line">   suite</span><br><span class="line"><span class="keyword">elif</span> expression : </span><br><span class="line">   suite </span><br><span class="line"><span class="keyword">else</span> : </span><br><span class="line">   suite</span><br></pre></td></tr></table></figure><h3 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h3><p><strong>print</strong> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=””**：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">x=<span class="string">&quot;a&quot;</span></span><br><span class="line">y=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x )</span><br><span class="line"><span class="built_in">print</span>( y )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">---------</span></span><br><span class="line"><span class="string">a b </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h3><p>在 python 用 <strong>import</strong> 或者 <strong>from…import</strong> 来导入相应的模块。</p><p>将整个模块(somemodule)导入，格式为： <strong>import somemodule</strong></p><p>从某个模块中导入某个函数,格式为： <strong>from somemodule import somefunction</strong></p><p>从某个模块中导入多个函数,格式为： <strong>from somemodule import firstfunc, secondfunc, thirdfunc</strong></p><p>将某个模块中的全部函数导入，格式为： <strong>from somemodule import *</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 sys 模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================Python import mode==========================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;命令行参数为:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n python 路径为&#x27;</span>,sys.path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 sys 模块的 argv,path 成员</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv,path  <span class="comment">#  导入特定的成员</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================python from import===================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,path) <span class="comment"># 因为已经导入path成员，所以此处引用时不需要加sys.path</span></span><br></pre></td></tr></table></figure><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python -h</span></span><br><span class="line">usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...</span><br><span class="line">Options and arguments (and corresponding environment variables):</span><br><span class="line">-c cmd : program passed in as string (terminates option list)</span><br><span class="line">-d     : debug output from parser (also PYTHONDEBUG=x)</span><br><span class="line">-E     : ignore environment variables (such as PYTHONPATH)</span><br><span class="line">-h     : print this help message and exit</span><br><span class="line"></span><br><span class="line">[ etc. ]</span><br></pre></td></tr></table></figure><p>具体使用可以参照 <a href="https://www.runoob.com/python3/python3-command-line-arguments.html">Python 3 命令行参数</a>。</p><hr><h2 id="Python3-基本数据类型"><a href="#Python3-基本数据类型" class="headerlink" title="Python3 基本数据类型"></a>Python3 基本数据类型</h2><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><p>等号（=）用来给变量赋值。等号（=）运算符左边是一个变量名，右边是存储在变量中的值。</p><h3 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python允许同时为多个变量赋值</span></span><br><span class="line">a = b = c = <span class="number">1</span> </span><br><span class="line"><span class="comment"># 以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值</span></span><br><span class="line"><span class="comment"># 也可以为多个对象指定多个变量</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;runoob&quot;</span></span><br><span class="line"><span class="comment"># 以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 &quot;runoob&quot; 分配给变量 c</span></span><br></pre></td></tr></table></figure><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li><li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li></ul><h3 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h3><p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。</p><p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p><p>内置的 type() 函数可以用来查询变量所指的对象类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 此外还可以用 isinstance 来判断：</span></span><br><span class="line"><span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>isinstance 和 type 的区别在于：</p><ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="built_in">isinstance</span>(A(), A)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">type</span>(A()) == A </span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">isinstance</span>(B(), A)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">type</span>(B()) == A</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True==1、False==0 会返回 True，但可以通过 is 来判断类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>) </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span>==<span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span>==<span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span>+<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span>+<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当你指定一个值时，Number 对象就会被创建：</span></span><br><span class="line">var1 = <span class="number">1</span></span><br><span class="line"><span class="comment"># 可以通过使用del语句删除单个或多个对象</span></span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>1、Python可以同时为多个变量赋值，如a, b = 1, 2。</li><li>2、一个变量可以通过赋值指向不同类型的对象。</li><li>3、数值的除法包含两个运算符：**/** 返回一个浮点数，**//** 返回一个整数。</li><li>4、在混合计算时，Python会把整型转换成为浮点数。</li></ul><p>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示，复数的实部a和虚部b都是浮点型</p><hr><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>Python中的字符串用单引号 <strong>‘</strong> 或双引号 <strong>“</strong> 括起来，同时使用反斜杠 \ 转义特殊字符。</p><p>字符串的截取的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量[头下标:尾下标]  索引值以 0 为开始值，-1 为从末尾的开始位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加号 + 是字符串的连接符， 星号 * 表示复制当前字符串，与之结合的数字为复制的次数。</span></span><br><span class="line"><span class="comment"># 实例如下：</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>)          <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])    <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>])       <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])     <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:])      <span class="comment"># 输出从第三个开始的后的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> * <span class="number">2</span>)      <span class="comment"># 输出字符串两次，也可以写成 print (2 * str)</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>) <span class="comment"># 连接字符串</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Runoob</span></span><br><span class="line"><span class="string">Runoo</span></span><br><span class="line"><span class="string">R</span></span><br><span class="line"><span class="string">noo</span></span><br><span class="line"><span class="string">noob</span></span><br><span class="line"><span class="string">RunoobRunoob</span></span><br><span class="line"><span class="string">RunoobTEST</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 使用反斜杠 \ 转义特殊字符，如果你不想让反斜杠发生转义，</span></span><br><span class="line"><span class="comment"># 可以在字符串前面添加一个 r，表示原始字符串：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Ru\noob&#x27;</span>)</span><br><span class="line">Ru</span><br><span class="line">oob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;Ru\noob&#x27;</span>)</span><br><span class="line">Ru\noob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外，反斜杠(\)可以作为续行符，表示下一行是上一行的延续。</span></span><br><span class="line"><span class="comment"># 也可以使用 &quot;&quot;&quot;...&quot;&quot;&quot; 或者 &#x27;&#x27;&#x27;...&#x27;&#x27;&#x27; 跨越多行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(word[<span class="number">0</span>], word[<span class="number">5</span>])</span><br><span class="line">P n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(word[-<span class="number">1</span>], word[-<span class="number">6</span>])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure><p>与 C 字符串不同的是，Python 字符串<strong>不能被改变</strong>。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p><p><strong>注意：</strong></p><ul><li>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li><li>2、字符串可以用+运算符连接在一起，用*运算符重复。</li><li>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li><li>4、Python中的字符串不能改变。</li></ul><hr><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表。</p><p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><p>列表截取的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量[头下标:尾下标]  索引值以 0 为开始值，-1 为从末尾的开始位置。</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)            <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">0</span>])         <span class="comment"># 输出列表第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])       <span class="comment"># 从第二个开始输出到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">2</span>:])        <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinylist * <span class="number">2</span>)    <span class="comment"># 输出两次列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span> + tinylist) <span class="comment"># 连接列表</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2]</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">[786, 2.23]</span></span><br><span class="line"><span class="string">[2.23, &#x27;runoob&#x27;, 70.2]</span></span><br><span class="line"><span class="string">[123, &#x27;runoob&#x27;, 123, &#x27;runoob&#x27;]</span></span><br><span class="line"><span class="string">[&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2, 123, &#x27;runoob&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>与Python字符串不一样的是，列表中的元素是可以改变的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">5</span>] = []   <span class="comment"># 将对应的元素值设置为 []</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>List 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。</p><p><strong>注意：</strong></p><ul><li>1、List写在方括号之间，元素用逗号隔开。</li><li>2、和字符串一样，list可以被索引和切片。</li><li>3、List可以使用+操作符进行拼接。</li><li>4、List中的元素是可以改变的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 列表截取可以接收第三个参数，参数作用是截取的步长</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line"><span class="comment"># 如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like runoob&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(rw)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">runoob like I</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p><p>元组中的元素类型也可以不相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)             <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])          <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])        <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])         <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)     <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2)</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">(786, 2.23)</span></span><br><span class="line"><span class="string">(2.23, &#x27;runoob&#x27;, 70.2)</span></span><br><span class="line"><span class="string">(123, &#x27;runoob&#x27;, 123, &#x27;runoob&#x27;)</span></span><br><span class="line"><span class="string">(&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2, 123, &#x27;runoob&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p><p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure><p>string、list 和 tuple 都属于 sequence（序列）。</p><p><strong>注意：</strong></p><ul><li>1、与字符串一样，元组的元素<strong>不能修改</strong>。</li><li>2、元组也可以被索引和切片，方法一样。</li><li>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li><li>4、元组也可以使用+操作符进行拼接。</li></ul><hr><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>基本功能是进行<strong>成员关系测试</strong>和<strong>删除重复元素</strong>。</p><p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p><p>创建格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">set</span>(value)</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">sites = &#123;<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(sites)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;Zhihu&#x27;, &#x27;Baidu&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Runoob&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 不在集合中&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Runoob 在集合中</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;r&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;c&#x27;, &#x27;a&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;z&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p><p>键(key)必须使用不可变类型。</p><p>在同一个字典中，键(key)必须是唯一的。</p><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 - 菜鸟教程&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;2 - 菜鸟工具&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 - 菜鸟教程</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2 - 菜鸟工具</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;name&#x27;: &#x27;runoob&#x27;, &#x27;code&#x27;: 1, &#x27;site&#x27;: &#x27;www.runoob.com&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dict_keys([&#x27;name&#x27;, &#x27;code&#x27;, &#x27;site&#x27;])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dict_values([&#x27;runoob&#x27;, 1, &#x27;www.runoob.com&#x27;])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;Google&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;Taobao&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line">&#123;<span class="string">&#x27;Runoob&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Google&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(Runoob=<span class="number">1</span>, Google=<span class="number">2</span>, Taobao=<span class="number">3</span>)</span><br><span class="line">&#123;<span class="string">&#x27;Runoob&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Google&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>**{x: x*<em>2 for x in (2, 4, 6)}</em>* 该代码使用的是字典推导式，更多推导式内容可以参考：<a href="https://www.runoob.com/python3/python-comprehensions.html">Python 推导式</a>。</p><p>另外，字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。</p><p><strong>注意：</strong></p><ul><li>1、字典是一种映射类型，它的元素是键值对。</li><li>2、字典的关键字必须为不可变类型，且不能重复。</li><li>3、创建空字典使用 **{ }**。</li></ul><hr><h2 id="Python3-数据类型转换"><a href="#Python3-数据类型转换" class="headerlink" title="Python3 数据类型转换"></a>Python3 数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，一般情况下你只需要将数据类型作为函数名即可。</p><p>Python 数据类型转换可以分为两种：</p><ul><li>隐式类型转换 - 自动完成</li><li>显式类型转换 - 需要使用类型函数来转换</li></ul><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。</p><p>以下实例中，我们对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">num_int = <span class="number">123</span></span><br><span class="line">num_flo = <span class="number">1.23</span></span><br><span class="line"></span><br><span class="line">num_new = num_int + num_flo</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;datatype of num_int:&quot;</span>,<span class="built_in">type</span>(num_int))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_int 数据类型为: &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;datatype of num_flo:&quot;</span>,<span class="built_in">type</span>(num_flo))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_flo 数据类型为: &lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Value of num_new:&quot;</span>,num_new)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_new: 值为: 124.23</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;datatype of num_new:&quot;</span>,<span class="built_in">type</span>(num_new))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_new 数据类型为: &lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>代码解析：</p><ul><li>实例中我们对两个不同数据类型的变量 <code>num_int</code> 和 <code>num_flo</code> 进行相加运算，并存储在变量 <code>num_new</code> 中。</li><li>然后查看三个变量的数据类型。</li><li>在输出结果中，我们看到 <code>num_int</code> 是 <code>整型（integer）</code> ， <code>num_flo</code> 是 <code>浮点型（float）</code>。</li><li>同样，新的变量 <code>num_new</code> 是 <code>浮点型（float）</code>，这是因为 Python 会将较小的数据类型转换为较大的数据类型，以避免数据丢失。</li></ul><p>我们再看一个实例，整型数据与字符串类型的数据进行相加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">num_int = <span class="number">123</span></span><br><span class="line">num_str = <span class="string">&quot;456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Data type of num_int:&quot;</span>,<span class="built_in">type</span>(num_int))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_int 数据类型为: &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Data type of num_str:&quot;</span>,<span class="built_in">type</span>(num_str))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_str 数据类型为: &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(num_int+num_str)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;/runoob-test/test.py&quot;, line 7, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(num_int+num_str)</span></span><br><span class="line"><span class="string">TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>从输出中可以看出，整型和字符串类型运算结果会报错，输出 TypeError。 Python 在这种情况下无法使用隐式转换。</p><p>但是，Python 为这些类型的情况提供了一种解决方案，称为显式转换。</p><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p>在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># int() 强制转换为整型</span></span><br><span class="line">x = <span class="built_in">int</span>(<span class="number">1</span>)   <span class="comment"># x 输出结果为 1</span></span><br><span class="line">y = <span class="built_in">int</span>(<span class="number">2.8</span>) <span class="comment"># y 输出结果为 2</span></span><br><span class="line">z = <span class="built_in">int</span>(<span class="string">&quot;3&quot;</span>) <span class="comment"># z 输出结果为 3</span></span><br><span class="line"><span class="comment"># float() 强制转换为浮点型</span></span><br><span class="line">x = <span class="built_in">float</span>(<span class="number">1</span>)     <span class="comment"># x 输出结果为 1.0</span></span><br><span class="line">y = <span class="built_in">float</span>(<span class="number">2.8</span>)   <span class="comment"># y 输出结果为 2.8</span></span><br><span class="line">z = <span class="built_in">float</span>(<span class="string">&quot;3&quot;</span>)   <span class="comment"># z 输出结果为 3.0</span></span><br><span class="line">w = <span class="built_in">float</span>(<span class="string">&quot;4.2&quot;</span>) <span class="comment"># w 输出结果为 4.2</span></span><br><span class="line"><span class="comment"># str() 强制转换为字符串类型</span></span><br><span class="line">x = <span class="built_in">str</span>(<span class="string">&quot;s1&quot;</span>) <span class="comment"># x 输出结果为 &#x27;s1&#x27;</span></span><br><span class="line">y = <span class="built_in">str</span>(<span class="number">2</span>)    <span class="comment"># y 输出结果为 &#x27;2&#x27;</span></span><br><span class="line">z = <span class="built_in">str</span>(<span class="number">3.0</span>)  <span class="comment"># z 输出结果为 &#x27;3.0&#x27;</span></span><br><span class="line"><span class="comment"># 整型和字符串类型进行运算，就可以用强制类型转换来完成：</span></span><br><span class="line">num_int = <span class="number">123</span></span><br><span class="line">num_str = <span class="string">&quot;456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;num_int 数据类型为:&quot;</span>,<span class="built_in">type</span>(num_int))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;类型转换前，num_str 数据类型为:&quot;</span>,<span class="built_in">type</span>(num_str))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_int 数据类型为: &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">类型转换前，num_str 数据类型为: &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">num_str = <span class="built_in">int</span>(num_str)    <span class="comment"># 强制转换为整型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;类型转换后，num_str 数据类型为:&quot;</span>,<span class="built_in">type</span>(num_str))</span><br><span class="line">num_sum = num_int + num_str</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;num_int 与 num_str 相加结果为:&quot;</span>,num_sum)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum 数据类型为:&quot;</span>,<span class="built_in">type</span>(num_sum))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">类型转换后，num_str 数据类型为: &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">num_int 与 num_str 相加结果为: 579</span></span><br><span class="line"><span class="string">sum 数据类型为: &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Python-推导式"><a href="#Python-推导式" class="headerlink" title="Python 推导式"></a>Python 推导式</h2><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。</p><p>Python 支持各种数据结构的推导式：</p><ul><li>列表(list)推导式</li><li>字典(dict)推导式</li><li>集合(set)推导式</li><li>元组(tuple)推导式</li></ul><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>列表推导式格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表] </span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><ul><li>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</li><li>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</li><li>if condition：条件语句，可以过滤列表中不符合条件的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(new_names)</span><br><span class="line">[<span class="string">&#x27;ALICE&#x27;</span>, <span class="string">&#x27;JERRY&#x27;</span>, <span class="string">&#x27;WENDY&#x27;</span>, <span class="string">&#x27;SMITH&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 30 以内可以被 3 整除的整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>multiples = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(multiples)</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><p>字典推导基本格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字符串及其长度创建字典</span></span><br><span class="line">listdemo = [<span class="string">&#x27;Google&#x27;</span>,<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="comment"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newdict = &#123;key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newdict</span><br><span class="line">&#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供三个数字，以三个数字为键，三个数字的平方为值来创建字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(dic)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><p>集合推导式基本格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算数字 1,2,3 的平方数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setnew = &#123;i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setnew</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断不是 abc 的字母并输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h3><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p><p>元组推导式基本格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure><p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 <strong>()</strong> 圆括号将各部分括起来，而列表推导式用的是中括号 <strong>[]<strong>，另外元组推导式返回的结果是一个</strong>生成器对象</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个包含数字 1~9 的元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7faf6ee20a50</span>&gt;  <span class="comment"># 返回的是生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(a)       <span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="Python3-解释器"><a href="#Python3-解释器" class="headerlink" title="Python3 解释器"></a>Python3 解释器</h2><p>Linux/Unix的系统上，一般默认的 python 版本为 2.x，我们可以将 python3.x 安装在 <strong>/usr/local/python3</strong> 目录中。</p><p>安装完成后，我们可以将路径 <strong>/usr/local/python3/bin</strong> 添加到您的 Linux/Unix 操作系统的环境变量中，这样您就可以通过 shell 终端输入下面的命令来启动 Python3 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">PATH=<span class="variable">$PATH</span>:/usr/local/python3/bin/python3    <span class="comment"># 设置环境变量</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3 --version</span></span><br><span class="line">Python 3.4.0</span><br></pre></td></tr></table></figure><p>在Window系统下你可以通过以下命令来设置Python的环境变量，假设你的Python安装在 C:\Python34 下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set path=%path%;C:\python34</span><br></pre></td></tr></table></figure><h3 id="交互式编程"><a href="#交互式编程" class="headerlink" title="交互式编程"></a>交互式编程</h3><p>我们可以在命令提示符中输入”Python”命令来启动Python解释器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3</span></span><br></pre></td></tr></table></figure><p>执行以上命令后，出现如下窗口信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3</span></span><br><span class="line">Python 3.4.0 (default, Apr 11 2014, 13:05:11) </span><br><span class="line">[GCC 4.8.2] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span> </span><br></pre></td></tr></table></figure><p>在 python 提示符中输入以下语句，然后按回车键查看运行效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print (&quot;Hello, Python!&quot;);</span><br></pre></td></tr></table></figure><p>以上命令执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure><p>当键入一个多行结构时，续行是必须的。我们可以看下如下 if 语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; flag = True</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="keyword">if</span> flag :</span></span><br><span class="line">...     print(&quot;flag 条件为 True!&quot;)</span><br><span class="line">... </span><br><span class="line">flag 条件为 True!</span><br></pre></td></tr></table></figure><h3 id="脚本-式编程"><a href="#脚本-式编程" class="headerlink" title="脚本 式编程"></a>脚本 式编程</h3><p>将如下代码拷贝至 <strong>hello.py</strong>文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Hello, Python!&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过以下命令执行该脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 hello.py</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure><p>在Linux/Unix系统中，你可以在脚本顶部添加以下命令让Python脚本可以像SHELL脚本一样可直接执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br></pre></td></tr></table></figure><p>然后修改脚本权限，使其有执行权限，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x hello.py</span></span><br></pre></td></tr></table></figure><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello.py</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure><hr><h2 id="Python3-注释"><a href="#Python3-注释" class="headerlink" title="Python3 注释"></a>Python3 注释</h2><p>确保对模块, 函数, 方法和行内注释使用正确的风格</p><p>Python中的注释有单行注释和多行注释：</p><p>Python中单行注释以 <strong>#</strong> 开头，例如：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个注释 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>多行注释用三个单引号 <strong>‘’’</strong> 或者三个双引号 <strong>“””</strong> 将注释括起来，例如:</p><h3 id="1、单引号（’’’）"><a href="#1、单引号（’’’）" class="headerlink" title="1、单引号（’’’）"></a>1、单引号（’’’）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3 </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号 </span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2、双引号（”””）"><a href="#2、双引号（”””）" class="headerlink" title="2、双引号（”””）"></a>2、双引号（”””）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号 </span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="Python3-运算符"><a href="#Python3-运算符" class="headerlink" title="Python3 运算符"></a>Python3 运算符</h2><p>Python 语言支持以下类型的运算符:</p><ul><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf1">算术运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf2">比较（关系）运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf3">赋值运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf4">逻辑运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf5">位运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf6">成员运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf7">身份运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf8">运算符优先级</a></li></ul><h3 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h3><p>以下假设变量 <strong>a=10</strong>，变量 <strong>b=21</strong>：</p><table><thead><tr><th align="center">运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td align="center">+</td><td>加</td><td>a + b = 31</td></tr><tr><td align="center">-</td><td>减 - 得到负数或是一个数减去另一个数</td><td>a - b = -11</td></tr><tr><td align="center">*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td>a * b = 210</td></tr><tr><td align="center">/</td><td>除</td><td>b / a = 2.1</td></tr><tr><td align="center">%</td><td>取模 - 返回除法的余数</td><td>b % a = 1</td></tr><tr><td align="center">**</td><td>幂 - 返回x的y次幂</td><td>a**b =10的21次方</td></tr><tr><td align="center">//</td><td>取整除 - 向下取接近商的整数</td><td>9 // 2 = 4</td></tr></tbody></table><h3 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">==</td><td align="left">等于</td><td align="center">(a == b) 返回 False。</td></tr><tr><td align="center">!=</td><td align="left">不等于</td><td align="center">(a != b) 返回 True。</td></tr><tr><td align="center">&gt;</td><td align="left">大于</td><td align="center">(a &gt; b) 返回 False。</td></tr><tr><td align="center">&lt;</td><td align="left">小于 - 返回x是否小于y。</td><td align="center">(a &lt; b) 返回 True。</td></tr><tr><td align="center">&gt;=</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="center">(a &gt;= b) 返回 False。</td></tr><tr><td align="center">&lt;=</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="center">(a &lt;= b) 返回 True。</td></tr></tbody></table><p>所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的<strong>大小写</strong>。</p><h3 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="center">=</td><td align="left">简单的赋值运算符</td><td align="left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="center">+=</td><td align="left">加法赋值运算符</td><td align="left">c += a 等效于 c = c + a</td></tr><tr><td align="center">-=</td><td align="left">减法赋值运算符</td><td align="left">c -= a 等效于 c = c - a</td></tr><tr><td align="center">*=</td><td align="left">乘法赋值运算符</td><td align="left">c *= a 等效于 c = c * a</td></tr><tr><td align="center">/=</td><td align="left">除法赋值运算符</td><td align="left">c /= a 等效于 c = c / a</td></tr><tr><td align="center">%=</td><td align="left">取模赋值运算符</td><td align="left">c %= a 等效于 c = c % a</td></tr><tr><td align="center">**=</td><td align="left">幂赋值运算符</td><td align="left">c **= a 等效于 c = c ** a</td></tr><tr><td align="center">//=</td><td align="left">取整除赋值运算符</td><td align="left">c //= a 等效于 c = c // a</td></tr></tbody></table><p>:=   海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</p><p>在这个示例中，赋值表达式可以避免调用 len() 两次:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;List is too long (<span class="subst">&#123;n&#125;</span> elements, expected &lt;= 10)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h3><p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p><p>下表中变量 a 为 60，b 为 13二进制格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = 0011 1100</span><br><span class="line"></span><br><span class="line">b = 0000 1101</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">a&amp;b = 0000 1100</span><br><span class="line"></span><br><span class="line">a|b = 0011 1101</span><br><span class="line"></span><br><span class="line">a^b = 0011 0001</span><br><span class="line"></span><br><span class="line">~a  = 1100 0011</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td align="center">|</td><td align="left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td align="center">^</td><td align="left">按位异或运算符：当两对应的二进位相异时，结果为1</td><td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td align="center">~</td><td align="left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 <strong>-x-1</strong></td><td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td align="center">&lt;&lt;</td><td align="left">左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td align="center">&gt;&gt;</td><td align="left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td><td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">60</span>            <span class="comment"># 60 = 0011 1100 </span></span><br><span class="line">b = <span class="number">13</span>            <span class="comment"># 13 = 0000 1101 </span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">c = a &amp; b        <span class="comment"># 12 = 0000 1100</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;1 - c 的值为：&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">c = a | b        <span class="comment"># 61 = 0011 1101 </span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;2 - c 的值为：&quot;</span>, c)</span><br><span class="line"> </span><br><span class="line">c = a ^ b        <span class="comment"># 49 = 0011 0001</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;3 - c 的值为：&quot;</span>, c)</span><br><span class="line"> </span><br><span class="line">c = ~a           <span class="comment"># -61 = 1100 0011</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;4 - c 的值为：&quot;</span>, c)</span><br><span class="line"> </span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>       <span class="comment"># 240 = 1111 0000</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;5 - c 的值为：&quot;</span>, c)</span><br><span class="line"> </span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>       <span class="comment"># 15 = 0000 1111</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;6 - c 的值为：&quot;</span>, c)</span><br></pre></td></tr></table></figure><h3 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h3><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">and</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - 变量 a 和 b 都为 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - 变量 a 和 b 有一个不为 true&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 - 变量 a 和 b 都为 true</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">or</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - 变量 a 和 b 都不为 true&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2 - 变量 a 和 b 都为 true，或其中一个变量为 true</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">and</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - 变量 a 和 b 都为 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - 变量 a 和 b 有一个不为 true&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3 - 变量 a 和 b 有一个不为 true</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">or</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;4 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;4 - 变量 a 和 b 都不为 true&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4 - 变量 a 和 b 都为 true，或其中一个变量为 true</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span>( a <span class="keyword">and</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;5 - 变量 a 和 b 都为 false，或其中一个变量为 false&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;5 - 变量 a 和 b 都为 true&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">5 - 变量 a 和 b 都为 false，或其中一个变量为 false</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - 变量 a 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - 变量 a 不在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 - 变量 a 不在给定的列表中 list 中</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ( b <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - 变量 b 不在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - 变量 b 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2 - 变量 b 不在给定的列表中 list 中</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - 变量 a 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - 变量 a 不在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3 - 变量 a 在给定的列表中 list 中</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h3><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(x) != id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - a 和 b 有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;1 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 - a 和 b 有相同的标识</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">id</span>(a) == <span class="built_in">id</span>(b) ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - a 和 b 有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;2 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2 - a 和 b 有相同的标识</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 修改变量 b 的值</span></span><br><span class="line">b = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - a 和 b 有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;3 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3 - a 和 b 没有相同的标识</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> <span class="keyword">not</span> b ):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;4 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;4 - a 和 b 有相同的标识&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4 - a 和 b 没有相同的标识</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>is 与 == 区别：</p><p>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = [1, 2, 3]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; b = a</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; b is a</span> </span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; b == a</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; b = a[:] <span class="comment"># ???</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; b is a</span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; b == a</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">指数 (最高优先级)</td></tr><tr><td align="left">~ + -</td><td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td align="left">* / % //</td><td align="left">乘，除，求余数和取整除</td></tr><tr><td align="left">+ -</td><td align="left">加法减法</td></tr><tr><td align="left">&gt;&gt; &lt;&lt;</td><td align="left">右移，左移运算符</td></tr><tr><td align="left">&amp;</td><td align="left">位 ‘AND’</td></tr><tr><td align="left">^ |</td><td align="left">位运算符</td></tr><tr><td align="left">&lt;= &lt; &gt; &gt;=</td><td align="left">比较运算符</td></tr><tr><td align="left">== !=</td><td align="left">等于运算符</td></tr><tr><td align="left">= %= /= //= -= += *= **=</td><td align="left">赋值运算符</td></tr><tr><td align="left">is is not</td><td align="left">身份运算符</td></tr><tr><td align="left">in not in</td><td align="left">成员运算符</td></tr><tr><td align="left">not and or</td><td align="left">逻辑运算符</td></tr></tbody></table><p>and 拥有更高优先级</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="literal">True</span></span><br><span class="line">y = <span class="literal">False</span></span><br><span class="line">z = <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">or</span> y <span class="keyword">and</span> z:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>Pyhton3 已不支持 &lt;&gt; 运算符，可以使用 != 代替，如果你一定要使用这种比较运算符，可以使用以下的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> __future__ <span class="keyword">import</span> barry_as_FLUFL</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> &lt;&gt; <span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h2 id="Python3-数字-Number"><a href="#Python3-数字-Number" class="headerlink" title="Python3 数字(Number)"></a>Python3 数字(Number)</h2><p>Python 数字数据类型用于存储数值。</p><p>数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。</p><p>以下实例在变量赋值时 Number 对象将被创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>您也可以使用del语句删除一些数字对象的引用。</p><p>del语句的语法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var1[,var2[,var3[....,varN]]]</span><br></pre></td></tr></table></figure><p>您可以通过使用del语句删除单个或多个对象的引用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><p>Python 支持三种不同的数值类型：</p><ul><li><strong>整型(int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。</li><li><strong>浮点型(float)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5 $e^2$ = 2.5 x $10^2$ = 250）</li><li><strong>复数( (complex))</strong> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li></ul><p>我们可以使用十六进制和八进制来代表整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>number = <span class="number">0xA0F</span> <span class="comment"># 十六进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>number</span><br><span class="line"><span class="number">2575</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>number=<span class="number">0o37</span> <span class="comment"># 八进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>number</span><br><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure><h3 id="Python-数字类型转换"><a href="#Python-数字类型转换" class="headerlink" title="Python 数字类型转换"></a>Python 数字类型转换</h3><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p><ul><li><strong>int(x)</strong> 将x转换为一个整数。</li><li><strong>float(x)</strong> 将x转换到一个浮点数。</li><li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</li><li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li></ul><p>以下实例将浮点数变量 a 转换为整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(a)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Python-数字运算"><a href="#Python-数字运算" class="headerlink" title="Python 数字运算"></a>Python 数字运算</h3><p>Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。</p><p>表达式的语法很直白： <strong>+</strong>, <strong>-</strong>, ***** 和 <strong>/</strong>, 和其它语言（如Pascal或C）里一样。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span>) / <span class="number">4</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span> / <span class="number">5</span>  <span class="comment"># 总是返回一个浮点数</span></span><br><span class="line"><span class="number">1.6</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在不同的机器上浮点运算的结果可能会不一样。</p><p>在整数除法中，除法 <strong>/</strong> 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 <strong>//</strong> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> / <span class="number">3</span>  <span class="comment"># 整数除法返回浮点型</span></span><br><span class="line"><span class="number">5.666666666666667</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> // <span class="number">3</span>  <span class="comment"># 整数除法返回向下取整后的结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span>  <span class="comment"># ％操作符返回除法的余数</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> * <span class="number">3</span> + <span class="number">2</span> </span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：**//** 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span>//<span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7.0</span>//<span class="number">2</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span>//<span class="number">2.0</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>等号 <strong>=</strong> 用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>width = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>height = <span class="number">5</span>*<span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>width * height</span><br><span class="line"><span class="number">900</span></span><br></pre></td></tr></table></figure><p>Python 可以使用 <strong>*</strong>* 操作来进行幂运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> ** <span class="number">2</span>  <span class="comment"># 5 的平方</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">7</span>  <span class="comment"># 2的7次方</span></span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure><p>变量在使用前必须先”定义”（即赋予变量一个值），否则会出现错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n   <span class="comment"># 尝试访问一个未定义的变量</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;n&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>不同类型的数混合运算时会将整数转换为浮点数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">3.75</span> / <span class="number">1.5</span></span><br><span class="line"><span class="number">7.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7.0</span> / <span class="number">2</span></span><br><span class="line"><span class="number">3.5</span></span><br></pre></td></tr></table></figure><p>在交互模式中，最后被输出的表达式结果被赋值给变量 <strong>_</strong> 。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tax = <span class="number">12.5</span> / <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price = <span class="number">100.50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price * tax</span><br><span class="line"><span class="number">12.5625</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price + _</span><br><span class="line"><span class="number">113.0625</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(_, <span class="number">2</span>)</span><br><span class="line"><span class="number">113.06</span></span><br></pre></td></tr></table></figure><p>此处， <strong>_</strong> 变量应被用户视为只读变量。</p><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><table><thead><tr><th align="left">函数</th><th align="left">返回值 ( 描述 )</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td align="left">返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td><td align="left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td align="left">cmp(x, y)</td><td align="left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td><td align="left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td align="left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td><td align="left">返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td><td align="left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td><td align="left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…)</a></td><td align="left">返回给定参数的最大值，参数可以为序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…)</a></td><td align="left">返回给定参数的最小值，参数可以为序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td><td align="left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td align="left">x**y 运算后的值。</td></tr><tr><td align="left">[round(x <a href="https://www.runoob.com/python3/python3-func-number-round.html">,n])</a></td><td align="left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td><td align="left">返回数字x的平方根。</td></tr></tbody></table><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p><p>Python包含以下常用随机数函数：</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-choice.html">choice(seq)</a></td><td align="left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td align="left">[randrange (<a href="https://www.runoob.com/python3/python3-func-number-randrange.html">start,] stop [,step])</a></td><td align="left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-random.html">random()</a></td><td align="left">随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td align="left">[seed(<a href="https://www.runoob.com/python3/python3-func-number-seed.html">x])</a></td><td align="left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-shuffle.html">shuffle(lst)</a></td><td align="left">将序列的所有元素随机排序</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-uniform.html">uniform(x, y)</a></td><td align="left">随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>Python包括以下三角函数：</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-acos.html">acos(x)</a></td><td align="left">返回x的反余弦弧度值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-asin.html">asin(x)</a></td><td align="left">返回x的反正弦弧度值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-atan.html">atan(x)</a></td><td align="left">返回x的反正切弧度值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-atan2.html">atan2(y, x)</a></td><td align="left">返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-cos.html">cos(x)</a></td><td align="left">返回x的弧度的余弦值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-hypot.html">hypot(x, y)</a></td><td align="left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-sin.html">sin(x)</a></td><td align="left">返回的x弧度的正弦值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-tan.html">tan(x)</a></td><td align="left">返回x弧度的正切值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-degrees.html">degrees(x)</a></td><td align="left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-number-radians.html">radians(x)</a></td><td align="left">将角度转换为弧度</td></tr></tbody></table><h3 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h3><table><thead><tr><th align="left">常量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">pi</td><td align="left">数学常量 pi（圆周率，一般以π来表示）</td></tr><tr><td align="left">e</td><td align="left">数学常量 e，e即自然常数（自然常数）。</td></tr></tbody></table><hr><h2 id="Python3-字符串"><a href="#Python3-字符串" class="headerlink" title="Python3 字符串"></a>Python3 字符串</h2><p>字符串是 Python 中最常用的数据类型。我们可以使用引号( <strong>‘</strong> 或 <strong>“</strong> )来创建字符串。</p><p>创建字符串很简单，只要为变量分配一个值即可。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">var2 = <span class="string">&quot;Runoob&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Python-访问字符串中的值"><a href="#Python-访问字符串中的值" class="headerlink" title="Python 访问字符串中的值"></a>Python 访问字符串中的值</h3><p>Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。</p><p>Python 访问子字符串，可以使用方括号 <strong>[ ]</strong> 来截取字符串，字符串的截取的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure><p>索引值以 <strong>0</strong> 为开始值，**-1** 为从末尾的开始位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">var1 = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">var2 = <span class="string">&quot;Runoob&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;var1[0]: &quot;</span>, var1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;var2[1:5]: &quot;</span>, var2[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">var1[0]:  H</span></span><br><span class="line"><span class="string">var2[1:5]:  unoo</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Python-字符串更新"><a href="#Python-字符串更新" class="headerlink" title="Python 字符串更新"></a>Python 字符串更新</h3><p>你可以截取字符串的一部分并与其他字段拼接，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">var1 = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;已更新字符串 : &quot;</span>, var1[:<span class="number">6</span>] + <span class="string">&#x27;Runoob!&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">已更新字符串 :  Hello Runoob!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Python转义字符"><a href="#Python转义字符" class="headerlink" title="Python转义字符"></a>Python转义字符</h3><p>在需要在字符中使用特殊字符时，python 用反斜杠 *<em>\*</em> 转义字符。</p><h3 id="Python字符串运算符"><a href="#Python字符串运算符" class="headerlink" title="Python字符串运算符"></a>Python字符串运算符</h3><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">字符串连接</td><td align="left">a + b 输出结果： HelloPython</td></tr><tr><td align="left">*</td><td align="left">重复输出字符串</td><td align="left">a*2 输出结果：HelloHello</td></tr><tr><td align="left">[]</td><td align="left">通过索引获取字符串中字符</td><td align="left">a[1] 输出结果 <strong>e</strong></td></tr><tr><td align="left">[ : ]</td><td align="left">截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td><td align="left">a[1:4] 输出结果 <strong>ell</strong></td></tr><tr><td align="left">in</td><td align="left">成员运算符 - 如果字符串中包含给定的字符返回 True</td><td align="left"><strong>‘H’ in a</strong> 输出结果 True</td></tr><tr><td align="left">not in</td><td align="left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td align="left"><strong>‘M’ not in a</strong> 输出结果 True</td></tr><tr><td align="left">r/R</td><td align="left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 <strong>r</strong>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td align="left"><code>print( r&#39;\n&#39; ) print( R&#39;\n&#39; )</code></td></tr><tr><td align="left">%</td><td align="left">格式字符串</td><td align="left">请看下一节内容。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">b = <span class="string">&quot;Python&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a + b 输出结果：&quot;</span>, a + b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a * 2 输出结果：&quot;</span>, a * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a[1] 输出结果：&quot;</span>, a[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a[1:4] 输出结果：&quot;</span>, a[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( <span class="string">&quot;H&quot;</span> <span class="keyword">in</span> a) :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;H 在变量 a 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;H 不在变量 a 中&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( <span class="string">&quot;M&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> a) :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;M 不在变量 a 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;M 在变量 a 中&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">r&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">R&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a + b 输出结果： HelloPython</span></span><br><span class="line"><span class="string">a * 2 输出结果： HelloHello</span></span><br><span class="line"><span class="string">a[1] 输出结果： e</span></span><br><span class="line"><span class="string">a[1:4] 输出结果： ell</span></span><br><span class="line"><span class="string">H 在变量 a 中</span></span><br><span class="line"><span class="string">M 不在变量 a 中</span></span><br><span class="line"><span class="string">\n</span></span><br><span class="line"><span class="string">\n</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Python-字符串格式化"><a href="#Python-字符串格式化" class="headerlink" title="Python 字符串格式化"></a>Python 字符串格式化</h3><p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。</p><p>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;我叫 %s 今年 %d 岁!&quot;</span> % (<span class="string">&#x27;小明&#x27;</span>, <span class="number">10</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">我叫 小明 今年 10 岁!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>python字符串格式化符号:</p><table><thead><tr><th align="center">符  号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">%c</td><td align="left">格式化字符及其ASCII码</td></tr><tr><td align="center">%s</td><td align="left">格式化字符串</td></tr><tr><td align="center">%d</td><td align="left">格式化整数</td></tr><tr><td align="center">%u</td><td align="left">格式化无符号整型</td></tr><tr><td align="center">%o</td><td align="left">格式化无符号八进制数</td></tr><tr><td align="center">%x</td><td align="left">格式化无符号十六进制数</td></tr><tr><td align="center">%X</td><td align="left">格式化无符号十六进制数（大写）</td></tr><tr><td align="center">%f</td><td align="left">格式化浮点数字，可指定小数点后的精度</td></tr><tr><td align="center">%e</td><td align="left">用科学计数法格式化浮点数</td></tr><tr><td align="center">%E</td><td align="left">作用同%e，用科学计数法格式化浮点数</td></tr><tr><td align="center">%g</td><td align="left">%f和%e的简写</td></tr><tr><td align="center">%G</td><td align="left">%f 和 %E 的简写</td></tr><tr><td align="center">%p</td><td align="left">用十六进制数格式化变量的地址</td></tr></tbody></table><p>格式化操作符辅助指令:</p><table><thead><tr><th align="center">符号</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">*</td><td align="left">定义宽度或者小数点精度</td></tr><tr><td align="center">-</td><td align="left">用做左对齐</td></tr><tr><td align="center">+</td><td align="left">在正数前面显示加号( + )</td></tr><tr><td align="center"><sp></td><td align="left">在正数前面显示空格</td></tr><tr><td align="center">#</td><td align="left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td align="center">0</td><td align="left">显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td align="center">%</td><td align="left">‘%%’输出一个单一的’%’</td></tr><tr><td align="center">(var)</td><td align="left">映射变量(字典参数)</td></tr><tr><td align="center">m.n.</td><td align="left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><p>Python2.6 开始，新增了一种格式化字符串的函数 <a href="https://www.runoob.com/python/att-string-format.html">str.format()</a>，它增强了字符串格式化的功能。</p><h3 id="Python三引号"><a href="#Python三引号" class="headerlink" title="Python三引号"></a>Python三引号</h3><p>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">para_str = <span class="string">&quot;&quot;&quot;这是一个多行字符串的实例</span></span><br><span class="line"><span class="string">多行字符串可以使用制表符</span></span><br><span class="line"><span class="string">TAB ( \t )。</span></span><br><span class="line"><span class="string">也可以使用换行符 [ \n ]。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> (para_str)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是一个多行字符串的实例</span></span><br><span class="line"><span class="string">多行字符串可以使用制表符</span></span><br><span class="line"><span class="string">TAB (    )。</span></span><br><span class="line"><span class="string">也可以使用换行符 [ </span></span><br><span class="line"><span class="string"> ]。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。</p><p>一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">errHTML = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span></span><br><span class="line"><span class="string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span></span><br><span class="line"><span class="string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span></span><br><span class="line"><span class="string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span></span><br><span class="line"><span class="string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span></span><br><span class="line"><span class="string">ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;</span></span><br><span class="line"><span class="string">&lt;/BODY&gt;&lt;/HTML&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">CREATE TABLE users (  </span></span><br><span class="line"><span class="string">login VARCHAR(8), </span></span><br><span class="line"><span class="string">uid INTEGER,</span></span><br><span class="line"><span class="string">prid INTEGER)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h3><p>f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。</p><p>之前我们习惯用百分号 (%):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hello %s&#x27;</span> % name</span><br><span class="line"><span class="string">&#x27;Hello Runoob&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>f-string</strong> 格式化字符串以 <strong>f</strong> 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span>  <span class="comment"># 替换变量</span></span><br><span class="line"><span class="string">&#x27;Hello Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&#x27;</span>         <span class="comment"># 使用表达式</span></span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;w[<span class="string">&quot;name&quot;</span>]&#125;</span>: <span class="subst">&#123;w[<span class="string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Runoob: www.runoob.com&#x27;</span></span><br></pre></td></tr></table></figure><p>用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。</p><p>在 Python 3.8 的版本中可以使用 <strong>=</strong> 符号来拼接运算表达式与结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>&#125;</span>&#x27;</span>)   <span class="comment"># Python 3.6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;x+<span class="number">1</span>=&#125;</span>&#x27;</span>)   <span class="comment"># Python 3.8</span></span><br><span class="line">x+<span class="number">1</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h3><p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 <strong>u</strong>。</p><p>在Python3中，所有的字符串都是Unicode字符串。</p><h3 id="Python-的字符串内建函数"><a href="#Python-的字符串内建函数" class="headerlink" title="Python 的字符串内建函数"></a>Python 的字符串内建函数</h3><p>Python 的字符串常用内建函数如下：</p><table><thead><tr><th align="center">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()</a> 将字符串的第一个字符转换为大写</td></tr><tr><td align="center">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)</a>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td align="center">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="center">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=”utf-8”, errors=”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td align="center">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding=’UTF-8’,errors=’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="center">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))</a> 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="center">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)</a> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td align="center">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))</a> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td align="center">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))</a> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td align="center">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()</a> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td align="center">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()</a> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td align="center">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()</a> 如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td align="center">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-islower.html">islower()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="center">14</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()</a> 如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="center">15</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()</a> 如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td align="center">16</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()</a> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="center">17</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="center">18</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-join.html">join(seq)</a> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="center">19</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-len.html">len(string)</a> 返回字符串长度</td></tr><tr><td align="center">20</td><td align="left">[ljust(width<a href="https://www.runoob.com/python3/python3-string-ljust.html">, fillchar])</a> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td align="center">21</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-lower.html">lower()</a> 转换字符串中所有大写字符为小写.</td></tr><tr><td align="center">22</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()</a> 截掉字符串左边的空格或指定字符。</td></tr><tr><td align="center">23</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()</a> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="center">24</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-max.html">max(str)</a> 返回字符串 str 中最大的字母。</td></tr><tr><td align="center">25</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-min.html">min(str)</a> 返回字符串 str 中最小的字母。</td></tr><tr><td align="center">26</td><td align="left">[replace(old, new <a href="https://www.runoob.com/python3/python3-string-replace.html">, max])</a> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td align="center">27</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))</a> 类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td align="center">28</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))</a> 类似于 index()，不过是从右边开始.</td></tr><tr><td align="center">29</td><td align="left">[rjust(width,<a href="https://www.runoob.com/python3/python3-string-rjust.html">, fillchar])</a> 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td align="center">30</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()</a> 删除字符串末尾的空格或指定字符。</td></tr><tr><td align="center">31</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-split.html">split(str=””, num=string.count(str))</a> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td align="center">32</td><td align="left">[splitlines(<a href="https://www.runoob.com/python3/python3-string-splitlines.html">keepends])</a> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="center">33</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))</a> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td align="center">34</td><td align="left">[strip(<a href="https://www.runoob.com/python3/python3-string-strip.html">chars])</a> 在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td align="center">35</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()</a> 将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td align="center">36</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-title.html">title()</a> 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="center">37</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=””)</a> 根据 table 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td align="center">38</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-upper.html">upper()</a> 转换字符串中的小写字母为大写</td></tr><tr><td align="center">39</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)</a> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td align="center">40</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()</a> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><hr><h2 id="Python3-列表"><a href="#Python3-列表" class="headerlink" title="Python3 列表"></a>Python3 列表</h2><p>序列是 Python 中最基本的数据结构。</p><p>序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。</p><p>Python 有 6 个序列的内置类型，但最常见的是列表和元组。</p><p>列表都可以进行的操作包括索引，切片，加，乘，检查成员。</p><p>此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。</p><p>列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。</p><p>列表的数据项<strong>不需要具有相同的类型</strong></p><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">list3 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">list4 = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h3><p>与字符串的索引一样，列表索引从 <strong>0</strong> 开始，第二个索引是 <strong>1</strong>，依此类推。</p><p>通过索引列表可以进行截取、组合等操作。</p><p>索引也可以从尾部开始，最后一个元素的索引为 <strong>-1</strong>，往前一位为 <strong>-2</strong>，以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>[<span class="number">0</span>] )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>[<span class="number">1</span>] )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>[<span class="number">2</span>] )</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>[-<span class="number">1</span>] )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>[-<span class="number">2</span>] )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>[-<span class="number">3</span>] )</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">red</span></span><br><span class="line"><span class="string">green</span></span><br><span class="line"><span class="string">blue</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">black</span></span><br><span class="line"><span class="string">white</span></span><br><span class="line"><span class="string">yellow</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>使用下标索引来访问列表中的值，同样你也可以使用方括号 <strong>[]</strong> 的形式截取字符，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">nums = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]</span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[10, 20, 30, 40]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>使用负数索引值截取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&quot;Zhihu&quot;</span>, <span class="string">&quot;Taobao&quot;</span>, <span class="string">&quot;Wiki&quot;</span>]</span><br><span class="line"><span class="comment"># 读取第二位</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1]: &quot;</span>, <span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 从第二位开始（包含）截取到倒数第二位（不包含）</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list[1:-2]: &quot;</span>, <span class="built_in">list</span>[<span class="number">1</span>:-<span class="number">2</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">list[1]:  Runoob</span></span><br><span class="line"><span class="string">list[1:-2]:  [&#x27;Runoob&#x27;, &#x27;Zhihu&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h3><p>你可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">2001</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">list1.append(<span class="string">&#x27;Baidu&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的列表 : &quot;</span>, list1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第三个元素为 :  1997</span></span><br><span class="line"><span class="string">更新后的第三个元素为 :  2001</span></span><br><span class="line"><span class="string">更新后的列表 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Baidu&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><p>可以使用 del 语句来删除列表的的元素，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;原始列表 : &quot;</span>, <span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;删除第三个元素 : &quot;</span>, <span class="built_in">list</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">原始列表 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]</span></span><br><span class="line"><span class="string">删除第三个元素 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 2000]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h3><p>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。</p><p>如下所示：</p><table><thead><tr><th align="left">Python 表达式</th><th align="left">结果</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">len([1, 2, 3])</td><td align="left">3</td><td align="left">长度</td></tr><tr><td align="left">[1, 2, 3] + [4, 5, 6]</td><td align="left">[1, 2, 3, 4, 5, 6]</td><td align="left">组合</td></tr><tr><td align="left">[‘Hi!’] * 4</td><td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td align="left">重复</td></tr><tr><td align="left">3 in [1, 2, 3]</td><td align="left">True</td><td align="left">元素是否存在于列表中</td></tr><tr><td align="left">for x in [1, 2, 3]: print(x, end=” “)</td><td align="left">1 2 3</td><td align="left">迭代</td></tr></tbody></table><h3 id="Python列表截取与拼接"><a href="#Python列表截取与拼接" class="headerlink" title="Python列表截取与拼接"></a>Python列表截取与拼接</h3><p>Python的列表截取与字符串操作类型，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L=[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">2</span>] <span class="comment">#读取第三个元素</span></span><br><span class="line"><span class="string">&#x27;Taobao&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">2</span>] <span class="comment">#从右侧开始读取倒数第二个元素</span></span><br><span class="line"><span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:]</span><br><span class="line">[<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>] <span class="comment">#输出从第二个元素开始后的所有元素</span></span><br></pre></td></tr></table></figure><p>列表还支持拼接操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares += [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>使用嵌套列表即在列表里创建其它列表，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a, n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Python列表函数-amp-方法"><a href="#Python列表函数-amp-方法" class="headerlink" title="Python列表函数&amp;方法"></a>Python列表函数&amp;方法</h3><p>Python包含以下函数:</p><table><thead><tr><th align="center">序号</th><th align="left">函数</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td align="center">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td align="center">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td align="center">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th align="center">序号</th><th align="left">方法</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td align="center">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td align="center">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="center">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="center">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td align="center">6</td><td align="left">list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="center">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td align="center">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td align="center">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key=None, reverse=False)</a> 对原列表进行排序</td></tr><tr><td align="center">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr><tr><td align="center">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr></tbody></table><hr><h2 id="Python3-元组"><a href="#Python3-元组" class="headerlink" title="Python3 元组"></a>Python3 元组</h2><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组使用小括号 **( )**，列表使用方括号 **[ ]**。</p><p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3 = <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>   <span class="comment">#  不需要括号也可以</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(tup3)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = ()  <span class="comment">#创建空元组</span></span><br></pre></td></tr></table></figure><p>元组中只包含一个元素时，需要在元素后面添加逗号 <strong>,</strong> ，否则括号会被当作运算符使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(tup1)     <span class="comment"># 不加逗号，类型为整型</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">50</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(tup1)     <span class="comment"># 加上逗号，类型为元组</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>元组与字符串类似，下标索引从 0 开始，可以进行截取，组合等。</p><h3 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h3><p>元组可以使用下标索引来访问元组中的值，如下实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">tup1 = (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tup1[0]: &quot;</span>, tup1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tup2[1:5]: &quot;</span>, tup2[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tup1[0]:  Google</span></span><br><span class="line"><span class="string">tup2[1:5]:  (2, 3, 4, 5)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h3><p>元组中的元素值是不允许修改的，但我们可以对元组进行<strong>连接组合</strong>，如下实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line">tup2 = (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></span><br><span class="line"><span class="comment"># tup1[0] = 100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span> (tup3)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(12, 34.56, &#x27;abc&#x27;, &#x27;xyz&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">tup = (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">print</span> (tup)</span><br><span class="line"><span class="keyword">del</span> tup</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;删除后的元组 tup : &quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (tup)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">删除后的元组 tup : </span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;test.py&quot;, line 8, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print (tup)</span></span><br><span class="line"><span class="string">NameError: name &#x27;tup&#x27; is not defined</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h3><p>与字符串一样，元组之间可以使用 <strong>+</strong> 号和 ***** 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p><table><thead><tr><th align="left">Python 表达式</th><th align="left">结果</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>len((1, 2, 3))</code></td><td align="left">3</td><td align="left">计算元素个数</td></tr><tr><td align="left"><code>(1, 2, 3) + (4, 5, 6)</code></td><td align="left">(1, 2, 3, 4, 5, 6)</td><td align="left">连接</td></tr><tr><td align="left"><code>(&#39;Hi!&#39;,) * 4</code></td><td align="left">(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td align="left">复制</td></tr><tr><td align="left"><code>3 in (1, 2, 3)</code></td><td align="left">True</td><td align="left">元素是否存在</td></tr><tr><td align="left"><code>for x in (1, 2, 3):     print (x, end=&quot; &quot;)</code></td><td align="left">1 2 3</td><td align="left">迭代</td></tr></tbody></table><h3 id="元组索引，截取"><a href="#元组索引，截取" class="headerlink" title="元组索引，截取"></a>元组索引，截取</h3><p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：</p><table><thead><tr><th align="left">Python 表达式</th><th align="left">结果</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">tup[1]</td><td align="left">‘Runoob’</td><td align="left">读取第二个元素</td></tr><tr><td align="left">tup[-2]</td><td align="left">‘Weibo’</td><td align="left">反向读取，读取倒数第二个元素</td></tr><tr><td align="left">tup[1:]</td><td align="left">(‘Runoob’, ‘Taobao’, ‘Wiki’, ‘Weibo’, ‘Weixin’)</td><td align="left">截取元素，从第二个开始后的所有元素。</td></tr><tr><td align="left">tup[1:4]</td><td align="left">(‘Runoob’, ‘Taobao’, ‘Wiki’)</td><td align="left">截取元素，从第二个开始到第四个元素（索引为 3）。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tup = (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Wiki&#x27;</span>, <span class="string">&#x27;Weibo&#x27;</span>,<span class="string">&#x27;Weixin&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tup[1]</span></span><br><span class="line">&#x27;Runoob&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tup[-2]</span></span><br><span class="line">&#x27;Weibo&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tup[1:]</span></span><br><span class="line">(&#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Wiki&#x27;, &#x27;Weibo&#x27;, &#x27;Weixin&#x27;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tup[1:4]</span></span><br><span class="line">(&#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Wiki&#x27;)</span><br></pre></td></tr></table></figure><h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><p>Python元组包含了以下内置函数</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">len(tuple) 计算元组元素个数。</td><td align="left"><code>&gt;&gt;&gt; tuple1 = (&#39;Google&#39;, &#39;Runoob&#39;, &#39;Taobao&#39;) &gt;&gt;&gt; len(tuple1) 3 &gt;&gt;&gt; </code></td></tr><tr><td align="left">2</td><td align="left">max(tuple) 返回元组中元素最大值。</td><td align="left"><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; max(tuple2) &#39;8&#39; &gt;&gt;&gt; </code></td></tr><tr><td align="left">3</td><td align="left">min(tuple) 返回元组中元素最小值。</td><td align="left"><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; min(tuple2) &#39;4&#39; &gt;&gt;&gt; </code></td></tr><tr><td align="left">4</td><td align="left">tuple(iterable) 将可迭代系列转换为元组。</td><td align="left"><code>&gt;&gt;&gt; list1= [&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;] &gt;&gt;&gt; tuple1=tuple(list1) &gt;&gt;&gt; tuple1 (&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;)</code></td></tr></tbody></table><h3 id="关于元组是不可变的"><a href="#关于元组是不可变的" class="headerlink" title="关于元组是不可变的"></a>关于元组是不可变的</h3><p>所谓元组的不可变指的是元组所指向的内存中的内容不可变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tup = (<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tup[0] = <span class="string">&#x27;g&#x27;</span>     <span class="comment"># 不支持修改元素</span></span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">id</span>(tup)     <span class="comment"># 查看内存地址</span></span></span><br><span class="line">4440687904</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tup = (1,2,3)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">id</span>(tup)</span></span><br><span class="line">4441088800    # 内存地址不一样了</span><br></pre></td></tr></table></figure><p>从以上实例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象。</p><hr><h2 id="Python3-字典"><a href="#Python3-字典" class="headerlink" title="Python3 字典"></a>Python3 字典</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p><p>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>dict 作为 Python 的关键字和内置函数，变量名不建议命名为 <strong>dict</strong>。</p><p>键必须是唯一的，但值则不必。</p><p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字。</p><p>一个简单的字典实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;likes&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>也可如此创建字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tinydict1 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">456</span> &#125;</span><br><span class="line">tinydict2 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="number">98.6</span>: <span class="number">37</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h3><p>使用大括号 <strong>{ }</strong> 创建空字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用大括号 &#123;&#125; 来创建空字典</span></span><br><span class="line">emptyDict = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打印字典</span></span><br><span class="line"><span class="built_in">print</span>(emptyDict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看字典的数量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Length:&quot;</span>, <span class="built_in">len</span>(emptyDict))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(emptyDict))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">Length: 0</span></span><br><span class="line"><span class="string">&lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h3><p>把相应的键放入到方括号中，如下实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tinydict[&#x27;Name&#x27;]:  Runoob</span></span><br><span class="line"><span class="string">tinydict[&#x27;Age&#x27;]:  7</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>如果用字典里没有的键访问数据，会输出错误如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Alice&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Alice&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;test.py&quot;, line 5, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print (&quot;tinydict[&#x27;Alice&#x27;]: &quot;, tinydict[&#x27;Alice&#x27;])</span></span><br><span class="line"><span class="string">KeyError: &#x27;Alice&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h3><p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line">tinydict[<span class="string">&#x27;Age&#x27;</span>] = <span class="number">8</span>               <span class="comment"># 更新 Age</span></span><br><span class="line">tinydict[<span class="string">&#x27;School&#x27;</span>] = <span class="string">&quot;菜鸟教程&quot;</span>  <span class="comment"># 添加信息</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tinydict[&#x27;Age&#x27;]:  8</span></span><br><span class="line"><span class="string">tinydict[&#x27;School&#x27;]:  菜鸟教程</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>能删单一的元素也能清空字典，清空只需一项操作。</p><p>显式删除一个字典用del命令，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> tinydict[<span class="string">&#x27;Name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27;</span></span><br><span class="line">tinydict.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> tinydict         <span class="comment"># 删除字典</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但这会引发一个异常，因为用执行 del 操作后字典不再存在：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;/runoob-test/test.py&quot;, line 9, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;])</span></span><br><span class="line"><span class="string">NameError: name &#x27;tinydict&#x27; is not defined</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h3><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><p>两个重要的点需要记住：</p><p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;小菜鸟&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tinydict[&#x27;Name&#x27;]:  小菜鸟</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">tinydict = &#123;[<span class="string">&#x27;Name&#x27;</span>]: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;test.py&quot;, line 3, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    tinydict = &#123;[&#x27;Name&#x27;]: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7&#125;</span></span><br><span class="line"><span class="string">TypeError: unhashable type: &#x27;list&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h3><p>Python字典包含了以下内置函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">len(dict) 计算字典元素个数，即键的总数。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td></tr><tr><td align="left">2</td><td align="left">str(dict) 输出字典，可以打印的字符串表示。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td></tr><tr><td align="left">3</td><td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">dict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">dict.get(key, default=None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">dict.items()</a> 以列表返回一个视图对象</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">dict.keys()</a> 返回一个视图对象</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">dict.setdefault(key, default=None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键/值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">dict.values()</a> 返回一个视图对象</td></tr><tr><td align="left">11</td><td align="left">[pop(key<a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 随机返回并删除字典中的最后一对键和值。</td></tr></tbody></table><hr><h2 id="Python3-集合"><a href="#Python3-集合" class="headerlink" title="Python3 集合"></a>Python3 集合</h2><p>集合（set）是一个无序的不重复元素序列。</p><p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p><p>创建格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line">set(value)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                      <span class="comment"># 这里演示的是去重功能</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                 <span class="comment"># 快速判断元素是否在集合内</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 下面展示两个集合间的运算.</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># 集合a中包含而集合b中不包含的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># 集合a或b中包含的所有元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># 集合a和b中都包含了的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># 不同时包含于a和b的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>类似列表推导式，同样集合支持集合推导式(Set comprehension):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="集合的基本操作"><a href="#集合的基本操作" class="headerlink" title="集合的基本操作"></a>集合的基本操作</h3><h3 id="1、添加元素"><a href="#1、添加元素" class="headerlink" title="1、添加元素"></a>1、添加元素</h3><p><strong>语法格式如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.add( x )</span><br></pre></td></tr></table></figure><p>将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.add(<span class="string">&quot;Facebook&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.update( x )</span><br></pre></td></tr></table></figure><p>x 可以有多个，用逗号分开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.update(&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.update([<span class="number">1</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>])  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="2、移除元素"><a href="#2、移除元素" class="headerlink" title="2、移除元素"></a>2、移除元素</h3><p><strong>语法格式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.remove( x )</span><br></pre></td></tr></table></figure><p>将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.remove(<span class="string">&quot;Taobao&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.remove(<span class="string">&quot;Facebook&quot;</span>)   <span class="comment"># 不存在会发生错误</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;Facebook&#x27;</span></span><br></pre></td></tr></table></figure><p>此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.discard( x )</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.discard(<span class="string">&quot;Facebook&quot;</span>)  <span class="comment"># 不存在不会发生错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>我们也可以设置随机删除集合中的一个元素，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.pop() </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>, <span class="string">&quot;Facebook&quot;</span>))</span><br><span class="line">x = thisset.pop()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Runoob</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>多次执行测试结果都不一样。</p><p>set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。</p><h3 id="3、计算集合元素个数"><a href="#3、计算集合元素个数" class="headerlink" title="3、计算集合元素个数"></a>3、计算集合元素个数</h3><p><strong>语法格式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(s)</span><br></pre></td></tr></table></figure><p>计算集合 s 元素个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(thisset)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="4、清空集合"><a href="#4、清空集合" class="headerlink" title="4、清空集合"></a>4、清空集合</h3><p><strong>语法格式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure><p>清空集合 s。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(thisset)</span><br><span class="line"><span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><h3 id="5、判断元素是否在集合中存在"><a href="#5、判断元素是否在集合中存在" class="headerlink" title="5、判断元素是否在集合中存在"></a>5、判断元素是否在集合中存在</h3><p><strong>语法格式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x in s</span><br></pre></td></tr></table></figure><p>判断元素 x 是否在集合 s 中，存在返回 True，不存在返回 False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Runoob&quot;</span> <span class="keyword">in</span> thisset</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Facebook&quot;</span> <span class="keyword">in</span> thisset</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="集合内置方法完整列表"><a href="#集合内置方法完整列表" class="headerlink" title="集合内置方法完整列表"></a>集合内置方法完整列表</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td><td align="left">为集合添加元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td><td align="left">移除集合中的所有元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td><td align="left">拷贝一个集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td><td align="left">返回多个集合的差集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td><td align="left">移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td><td align="left">删除集合中指定的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td><td align="left">返回集合的交集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td><td align="left">返回集合的交集。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td><td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td><td align="left">判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td><td align="left">判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td><td align="left">随机移除元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td><td align="left">移除指定元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td><td align="left">返回两个集合中不重复的元素集合。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td><td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td><td align="left">返回两个集合的并集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td><td align="left">给集合添加元素</td></tr></tbody></table><hr><h2 id="Python3-编程第一步"><a href="#Python3-编程第一步" class="headerlink" title="Python3 编程第一步"></a>Python3 编程第一步</h2><p>下面我们尝试来写一个斐波纳契数列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Fibonacci series: 斐波纳契数列</span></span><br><span class="line"><span class="comment"># 两个元素的总和确定了下一个数</span></span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>其中代码 <strong>a, b = b, a+b</strong> 的计算方式为先计算右边表达式，然后同时赋值给左边，等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=b</span><br><span class="line">m=a+b</span><br><span class="line">a=n</span><br><span class="line">b=m</span><br></pre></td></tr></table></figure><p>这个例子介绍了几个新特征。</p><p>第一行包含了一个复合赋值：变量 a 和 b 同时得到新值 0 和 1。最后一行再次使用了同样的方法，可以看到，右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。</p><p><strong>输出变量值:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">256</span>*<span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;i 的值为：&#x27;</span>, i)</span><br><span class="line">i 的值为： <span class="number">65536</span></span><br></pre></td></tr></table></figure><h3 id="end-关键字"><a href="#end-关键字" class="headerlink" title="end 关键字"></a>end 关键字</h3><p>关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符，实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Fibonacci series: 斐波纳契数列</span></span><br><span class="line"><span class="comment"># 两个元素的总和确定了下一个数</span></span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; <span class="number">1000</span>:</span><br><span class="line">    <span class="built_in">print</span>(b, end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    a, b = b, a+b</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Python3-条件控制"><a href="#Python3-条件控制" class="headerlink" title="Python3 条件控制"></a>Python3 条件控制</h2><p>Python 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。</p><p>可以通过下图来简单了解条件语句的执行过程:</p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>Python中if语句的一般形式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure><ul><li>如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句</li><li>如果 “condition_1” 为False，将判断 “condition_2”<ul><li>如果”condition_2” 为 True 将执行 “statement_block_2” 块语句</li><li>如果 “condition_2” 为False，将执行”statement_block_3”块语句</li></ul></li></ul><p>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong>。</p><p><strong>注意：</strong></p><ul><li>1、每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。</li><li>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li><li>3、在Python中<strong>没有</strong>switch – case语句。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">var1 = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> var1:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;1 - if 表达式条件为 true&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (var1)</span><br><span class="line"> </span><br><span class="line">var2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> var2:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;2 - if 表达式条件为 true&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (var2)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 - if 表达式条件为 true</span></span><br><span class="line"><span class="string">100</span></span><br><span class="line"><span class="string">Good bye!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>从结果可以看到由于变量 var2 为 0，所以对应的 if 内的语句没有执行。</p><p>以下实例演示了狗的年龄计算判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你家狗狗的年龄: &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &lt;= <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你是在逗我吧!&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;相当于 14 岁的人。&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age == <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;相当于 22 岁的人。&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt; <span class="number">2</span>:</span><br><span class="line">    human = <span class="number">22</span> + (age -<span class="number">2</span>)*<span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对应人类年龄: &quot;</span>, human)</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 退出提示</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;点击 enter 键退出&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">请输入你家狗狗的年龄: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">相当于 14 岁的人。</span></span><br><span class="line"><span class="string">点击 enter 键退出</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>以下为if中常用的操作运算符:</p><table><thead><tr><th align="center">操作符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>&lt;</code></td><td align="left">小于</td></tr><tr><td align="center"><code>&lt;=</code></td><td align="left">小于或等于</td></tr><tr><td align="center"><code>&gt;</code></td><td align="left">大于</td></tr><tr><td align="center"><code>&gt;=</code></td><td align="left">大于或等于</td></tr><tr><td align="center"><code>==</code></td><td align="left">等于，比较两个值是否相等</td></tr><tr><td align="center"><code>!=</code></td><td align="left">不等于</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 程序演示了 == 操作符</span></span><br><span class="line"><span class="comment"># 使用数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> == <span class="number">6</span>)</span><br><span class="line"><span class="comment"># 使用变量</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(x == y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>下面演示了数字的比较运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 该实例演示了数字猜谜游戏</span></span><br><span class="line">number = <span class="number">7</span></span><br><span class="line">guess = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字猜谜游戏!&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> guess != number:</span><br><span class="line">    guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你猜的数字：&quot;</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> guess == number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;恭喜，你猜对了！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> guess &lt; number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猜的数字小了...&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> guess &gt; number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猜的数字大了...&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">数字猜谜游戏!</span></span><br><span class="line"><span class="string">请输入你猜的数字：1</span></span><br><span class="line"><span class="string">猜的数字小了...</span></span><br><span class="line"><span class="string">请输入你猜的数字：9</span></span><br><span class="line"><span class="string">猜的数字大了...</span></span><br><span class="line"><span class="string">请输入你猜的数字：7</span></span><br><span class="line"><span class="string">恭喜，你猜对了！</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="if-嵌套"><a href="#if-嵌套" class="headerlink" title="if 嵌套"></a>if 嵌套</h3><p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">if</span> 表达式<span class="number">2</span>:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">elif</span> 表达式<span class="number">3</span>:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">elif</span> 表达式<span class="number">4</span>:</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">num=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入一个数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">3</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;你输入的数字可以整除 2 和 3&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;你输入的数字可以整除 2，但不能整除 3&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">3</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;你输入的数字可以整除 3，但不能整除 2&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>  (<span class="string">&quot;你输入的数字不能整除 2 和 3&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输入一个数字：6</span></span><br><span class="line"><span class="string">你输入的数字可以整除 2 和 3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Python3-循环语句"><a href="#Python3-循环语句" class="headerlink" title="Python3 循环语句"></a>Python3 循环语句</h2><p>本章节将为大家介绍 Python 循环语句的使用。</p><p>Python 中的循环语句有 for 和 while。</p><p>Python 循环语句的控制结构图如下所示：</p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>Python 中 while 语句的一般形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure><p>同样需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环。</p><p>以下实例使用了 while 来计算 1 到 100 的总和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"> </span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> counter &lt;= n:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + counter</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1 到 %d 之和为: %d&quot;</span> % (n,<span class="built_in">sum</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 到 100 之和为: 5050</span></span><br></pre></td></tr></table></figure><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">var = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> var == <span class="number">1</span> :  <span class="comment"># 表达式永远为 true</span></span><br><span class="line">   num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入一个数字  :&quot;</span>))</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;你输入的数字是: &quot;</span>, num)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输入一个数字  :5</span></span><br><span class="line"><span class="string">你输入的数字是:  5</span></span><br><span class="line"><span class="string">输入一个数字  :</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>你可以使用 <strong>CTRL+C</strong> 来退出当前的无限循环。</p><p>无限循环在服务器上客户端的实时请求非常有用。</p><h3 id="while-循环使用-else-语句"><a href="#while-循环使用-else-语句" class="headerlink" title="while 循环使用 else 语句"></a>while 循环使用 else 语句</h3><p>如果 while 后面的条件语句为 false 时，则执行 else 的语句块。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure><p>expr 条件语句为 true 则执行 statement(s) 语句块，如果为 false，则执行 additional_statement(s)。</p><p>循环输出数字，并判断大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="built_in">print</span> (count, <span class="string">&quot; 小于 5&quot;</span>)</span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (count, <span class="string">&quot; 大于或等于 5&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0  小于 5</span></span><br><span class="line"><span class="string">1  小于 5</span></span><br><span class="line"><span class="string">2  小于 5</span></span><br><span class="line"><span class="string">3  小于 5</span></span><br><span class="line"><span class="string">4  小于 5</span></span><br><span class="line"><span class="string">5  大于或等于 5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="简单语句组"><a href="#简单语句组" class="headerlink" title="简单语句组"></a>简单语句组</h3><p>类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (flag): <span class="built_in">print</span> (<span class="string">&#x27;欢迎访问菜鸟教程!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">欢迎访问菜鸟教程!</span></span><br><span class="line"><span class="string">欢迎访问菜鸟教程!</span></span><br><span class="line"><span class="string">……</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>以上的无限循环你可以使用 CTRL+C 来中断循环。</p><p>执行以上脚本，输出结果如下：</p><h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>Python for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。</p><p>for循环的一般格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for &lt;variable&gt; in &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Python <span class="keyword">for</span> 循环实例</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;languages = [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Perl&quot;</span>, <span class="string">&quot;Python&quot;</span>]</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="keyword">for</span> x <span class="keyword">in</span> languages:</span></span><br><span class="line">...     print (x)</span><br><span class="line">... </span><br><span class="line">C</span><br><span class="line">C++</span><br><span class="line">Perl</span><br><span class="line">Python</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行脚本后，在循环到 &quot;Runoob&quot;时会跳出循环体</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">sites = [<span class="string">&quot;Baidu&quot;</span>, <span class="string">&quot;Google&quot;</span>,<span class="string">&quot;Runoob&quot;</span>,<span class="string">&quot;Taobao&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> site <span class="keyword">in</span> sites:</span><br><span class="line">    <span class="keyword">if</span> site == <span class="string">&quot;Runoob&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;菜鸟教程!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环数据 &quot;</span> + site)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有循环数据!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;完成循环!&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">循环数据 Baidu</span></span><br><span class="line"><span class="string">循环数据 Google</span></span><br><span class="line"><span class="string">菜鸟教程!</span></span><br><span class="line"><span class="string">完成循环!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>你也可以使用range指定区间的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">9</span>) :</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(i)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>负数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>, -<span class="number">100</span>, -<span class="number">30</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">-<span class="number">10</span></span><br><span class="line">-<span class="number">40</span></span><br><span class="line">-<span class="number">70</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>您可以结合range()和len()函数以遍历一个序列的索引,如下所示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;QQ&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span></span><br><span class="line">...     print(i, a[i])</span><br><span class="line">... </span><br><span class="line">0 Google</span><br><span class="line">1 Baidu</span><br><span class="line">2 Runoob</span><br><span class="line">3 Taobao</span><br><span class="line">4 QQ</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>还可以使用range()函数来创建一个列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;list(range(5))</span></span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="break-和-continue-语句及循环中的-else-子句"><a href="#break-和-continue-语句及循环中的-else-子句" class="headerlink" title="break 和 continue 语句及循环中的 else 子句"></a>break 和 continue 语句及循环中的 else 子句</h3><p><strong>break</strong> 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。</p><p><strong>continue</strong> 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># while 中使用 break</span></span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;循环结束。&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">循环结束。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># while 中使用 continue</span></span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;循环结束。&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">循环结束。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>更多实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Runoob&#x27;</span>:     <span class="comment"># 第一个实例</span></span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前字母为 :&#x27;</span>, letter)</span><br><span class="line">  </span><br><span class="line">var = <span class="number">10</span>                    <span class="comment"># 第二个实例</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:              </span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前变量值为 :&#x27;</span>, var)</span><br><span class="line">   var = var -<span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> var == <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当前字母为 : R</span></span><br><span class="line"><span class="string">当前字母为 : u</span></span><br><span class="line"><span class="string">当前字母为 : n</span></span><br><span class="line"><span class="string">当前字母为 : o</span></span><br><span class="line"><span class="string">当前字母为 : o</span></span><br><span class="line"><span class="string">当前变量值为 : 10</span></span><br><span class="line"><span class="string">当前变量值为 : 9</span></span><br><span class="line"><span class="string">当前变量值为 : 8</span></span><br><span class="line"><span class="string">当前变量值为 : 7</span></span><br><span class="line"><span class="string">当前变量值为 : 6</span></span><br><span class="line"><span class="string">Good bye!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下实例循环字符串 Runoob，碰到字母 o 跳过输出：</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Runoob&#x27;</span>:     <span class="comment"># 第一个实例</span></span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;o&#x27;</span>:        <span class="comment"># 字母为 o 时跳过输出</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前字母 :&#x27;</span>, letter)</span><br><span class="line"> </span><br><span class="line">var = <span class="number">10</span>                    <span class="comment"># 第二个实例</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:              </span><br><span class="line">   var = var -<span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> var == <span class="number">5</span>:             <span class="comment"># 变量为 5 时跳过输出</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前变量值 :&#x27;</span>, var)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当前字母 : R</span></span><br><span class="line"><span class="string">当前字母 : u</span></span><br><span class="line"><span class="string">当前字母 : n</span></span><br><span class="line"><span class="string">当前字母 : b</span></span><br><span class="line"><span class="string">当前变量值 : 9</span></span><br><span class="line"><span class="string">当前变量值 : 8</span></span><br><span class="line"><span class="string">当前变量值 : 7</span></span><br><span class="line"><span class="string">当前变量值 : 6</span></span><br><span class="line"><span class="string">当前变量值 : 4</span></span><br><span class="line"><span class="string">当前变量值 : 3</span></span><br><span class="line"><span class="string">当前变量值 : 2</span></span><br><span class="line"><span class="string">当前变量值 : 1</span></span><br><span class="line"><span class="string">当前变量值 : 0</span></span><br><span class="line"><span class="string">Good bye!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于查询质数的循环例子</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(n, <span class="string">&#x27;等于&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n//x)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 循环中没有找到元素</span></span><br><span class="line">        <span class="built_in">print</span>(n, <span class="string">&#x27; 是质数&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2  是质数</span></span><br><span class="line"><span class="string">3  是质数</span></span><br><span class="line"><span class="string">4 等于 2 * 2</span></span><br><span class="line"><span class="string">5  是质数</span></span><br><span class="line"><span class="string">6 等于 2 * 3</span></span><br><span class="line"><span class="string">7  是质数</span></span><br><span class="line"><span class="string">8 等于 2 * 4</span></span><br><span class="line"><span class="string">9 等于 3 * 3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h3><p>Python pass是空语句，是为了保持程序结构的完整性。</p><p>pass 不做任何事情，一般用做占位语句，如下实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;<span class="keyword">while</span> True:</span></span><br><span class="line">...     pass  # 等待键盘中断 (Ctrl+C)</span><br></pre></td></tr></table></figure><p>最小的类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">class</span> <span class="title class_">MyEmptyClass</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下实例在字母为 o 时 执行 pass 语句块</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Runoob&#x27;</span>: </span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;执行 pass 块&#x27;</span>)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前字母 :&#x27;</span>, letter)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当前字母 : R</span></span><br><span class="line"><span class="string">当前字母 : u</span></span><br><span class="line"><span class="string">当前字母 : n</span></span><br><span class="line"><span class="string">执行 pass 块</span></span><br><span class="line"><span class="string">当前字母 : o</span></span><br><span class="line"><span class="string">执行 pass 块</span></span><br><span class="line"><span class="string">当前字母 : o</span></span><br><span class="line"><span class="string">当前字母 : b</span></span><br><span class="line"><span class="string">Good bye!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Python3-迭代器与生成器"><a href="#Python3-迭代器与生成器" class="headerlink" title="Python3 迭代器与生成器"></a>Python3 迭代器与生成器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p><p>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</p><p>字符串，列表或元组对象都可用于创建迭代器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; list=[1,2,3,4]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; it = iter(list)    <span class="comment"># 创建迭代器对象</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span> (next(it))   <span class="comment"># 输出迭代器的下一个元素</span></span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span> (next(it))</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>迭代器对象可以使用常规for语句进行遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 2 3 4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>也可以使用 next() 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h3><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p><p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p><p>更多内容查阅：<a href="https://www.runoob.com/python3/python3-class.html">Python3 面向对象</a></p><p><strong>iter</strong>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</p><p><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p><p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h3><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p><p>在 20 次迭代后停止执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">11</span></span><br><span class="line"><span class="string">12</span></span><br><span class="line"><span class="string">13</span></span><br><span class="line"><span class="string">14</span></span><br><span class="line"><span class="string">15</span></span><br><span class="line"><span class="string">16</span></span><br><span class="line"><span class="string">17</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在 Python 中，使用了 yield 的函数被称为<strong>生成器</strong>（generator）。</p><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会<strong>暂停并保存当前所有的运行信息</strong>，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><p>以下实例使用 yield 实现斐波那契数列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>): <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span></span><br></pre></td></tr></table></figure><hr><h2 id="Python3-函数"><a href="#Python3-函数" class="headerlink" title="Python3 函数"></a>Python3 函数</h2><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p><p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p><h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p><ul><li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 **()**。</li><li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号 <strong>:</strong> 起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> a &gt; b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Python 定义函数使用 def 关键字，一般格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def 函数名（参数列表）:</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> a &gt; b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"> </span><br><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a, b))  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 计算面积函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">width, height</span>):</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_welcome</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome&quot;</span>, name)</span><br><span class="line"> </span><br><span class="line">print_welcome(<span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">w = <span class="number">4</span></span><br><span class="line">h = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;width =&quot;</span>, w, <span class="string">&quot; height =&quot;</span>, h, <span class="string">&quot; area =&quot;</span>, area(w, h))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Welcome Runoob</span></span><br><span class="line"><span class="string">width = 4  height = 5  area = 20</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p><p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。</p><p>如下实例调用了 <strong>printme()</strong> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span><br><span class="line">   <span class="comment"># 打印任何传入的字符串</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">printme(<span class="string">&quot;我要调用用户自定义函数!&quot;</span>)</span><br><span class="line">printme(<span class="string">&quot;再次调用同一函数&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">我要调用用户自定义函数!</span></span><br><span class="line"><span class="string">再次调用同一函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a=<span class="string">&quot;Runoob&quot;</span></span><br></pre></td></tr></table></figure><p>以上代码中，**[1,2,3]** 是 List 类型，**”Runoob”** 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p><h4 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h4><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li><strong>不可变类型：</strong>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li><li><strong>可变类型：</strong>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li><strong>不可变类型：</strong>类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</li><li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li></ul><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h4 id="python-传不可变对象实例"><a href="#python-传不可变对象实例" class="headerlink" title="python 传不可变对象实例"></a>python 传不可变对象实例</h4><p>通过 <strong>id()</strong> 函数来查看内存地址变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))   <span class="comment"># 指向的是同一个对象</span></span><br><span class="line">    a=<span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))   <span class="comment"># 一个新对象</span></span><br><span class="line"> </span><br><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">change(a)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4379369136</span></span><br><span class="line"><span class="string">4379369136</span></span><br><span class="line"><span class="string">4379369424</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看见在调用函数前后，形参和实参指向的是同一个对象（对象 id 相同），在函数内部修改形参后，形参指向的是不同的 id。</p><h4 id="传可变对象实例"><a href="#传可变对象实例" class="headerlink" title="传可变对象实例"></a>传可变对象实例</h4><p>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changeme</span>(<span class="params"> mylist </span>):</span><br><span class="line">   <span class="string">&quot;修改传入的列表&quot;</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;函数内取值: &quot;</span>, mylist)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用changeme函数</span></span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">changeme( mylist )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;函数外取值: &quot;</span>, mylist)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">函数内取值:  [10, 20, 30, [1, 2, 3, 4]]</span></span><br><span class="line"><span class="string">函数外取值:  [10, 20, 30, [1, 2, 3, 4]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>以下是调用函数时可使用的正式参数类型：</p><ul><li>必需参数</li><li>关键字参数</li><li>默认参数</li><li>不定长参数</li></ul><h4 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h4><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p><p>调用 printme() 函数，你必须传入一个参数，不然会出现语法错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用 printme 函数，不加参数会报错</span></span><br><span class="line">printme()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;test.py&quot;, line 10, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    printme()</span></span><br><span class="line"><span class="string">TypeError: printme() missing 1 required positional argument: &#x27;str&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><p>以下实例在函数 printme() 调用时使用参数名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( <span class="built_in">str</span> = <span class="string">&quot;菜鸟教程&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">菜鸟教程</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">名字:  runoob</span></span><br><span class="line"><span class="string">年龄:  50</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">printinfo( name=<span class="string">&quot;runoob&quot;</span> )</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">名字:  runoob</span></span><br><span class="line"><span class="string">年龄:  50</span></span><br><span class="line"><span class="string">------------------------</span></span><br><span class="line"><span class="string">名字:  runoob</span></span><br><span class="line"><span class="string">年龄:  35</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><p>加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出: </span></span><br><span class="line"><span class="string">70</span></span><br><span class="line"><span class="string">(60, 50)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="built_in">print</span> (var)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">10</span> )</span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出:</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">输出:</span></span><br><span class="line"><span class="string">70</span></span><br><span class="line"><span class="string">60</span></span><br><span class="line"><span class="string">50</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>还有一种就是参数带两个星号 <strong>*</strong>* 基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] **var_args_dict </span>):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><p>加了两个星号 <strong>*</strong>* 的参数会以<strong>字典</strong>的形式导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(<span class="number">1</span>, a=<span class="number">2</span>,b=<span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出: </span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 3&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>声明函数时，参数中星号 ***** 可以单独出现，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,*,c</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br></pre></td></tr></table></figure><p>如果单独出现星号 ***** 后的参数必须用<strong>关键字传入</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def f(a,b,*,c):</span></span><br><span class="line">...     return a+b+c</span><br><span class="line">... </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f(1,2,3)   <span class="comment"># 报错</span></span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: f() takes 2 positional arguments but 3 were given</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f(1,2,c=3) <span class="comment"># 正常</span></span></span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Python 使用 <strong>lambda</strong> 来创建匿名函数。</p><p>所谓匿名，意即不再使用 <strong>def</strong> 语句这样标准的形式定义一个函数。</p><ul><li><strong>lambda</strong> 只是一个表达式，函数体比 <strong>def</strong> 简单很多。</li><li>lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。</li><li>lambda 函数拥有自己的命名空间，且<strong>不能</strong>访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而<strong>增加</strong>运行效率。</li></ul><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p>lambda 函数的语法只包含一个语句，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure><p>设置参数 a 加上 10:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">lambda</span> a : a + <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">5</span>)) <span class="comment"># 15</span></span><br></pre></td></tr></table></figure><p>以下实例匿名函数设置两个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">相加后的值为 :  30</span></span><br><span class="line"><span class="string">相加后的值为 :  40</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。</p><p>以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">lambda</span> a : a * n</span><br><span class="line"> </span><br><span class="line">mydoubler = myfunc(<span class="number">2</span>)</span><br><span class="line">mytripler = myfunc(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(mydoubler(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(mytripler(<span class="number">11</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">22</span></span><br><span class="line"><span class="string">33</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><p><strong>return [表达式]</strong> 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params"> arg1, arg2 </span>):</span><br><span class="line">   <span class="comment"># 返回2个参数的和.&quot;</span></span><br><span class="line">   total = arg1 + arg2</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;函数内 : &quot;</span>, total)</span><br><span class="line">   <span class="keyword">return</span> total</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line">total = <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;函数外 : &quot;</span>, total)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">函数内 :  30</span></span><br><span class="line"><span class="string">函数外 :  30</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h3><p>Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p><p>在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, /, c, d, *, e, f</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d, e, f)</span><br></pre></td></tr></table></figure><p>以下使用方法是正确的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>以下使用方法会发生错误:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">10</span>, b=<span class="number">20</span>, c=<span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)   <span class="comment"># b 不能使用关键字参数的形式</span></span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, f=<span class="number">60</span>)           <span class="comment"># e 必须使用关键字参数的形式</span></span><br></pre></td></tr></table></figure><hr><h2 id="Python3-数据结构"><a href="#Python3-数据结构" class="headerlink" title="Python3 数据结构"></a>Python3 数据结构</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。</p><p>以下是 Python 中列表的方法：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">list.append(x)</td><td align="left">把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。</td></tr><tr><td align="left">list.extend(L)</td><td align="left">通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。</td></tr><tr><td align="left">list.insert(i, x)</td><td align="left">在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。</td></tr><tr><td align="left">list.remove(x)</td><td align="left">删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</td></tr><tr><td align="left">list.pop([i])</td><td align="left">从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）</td></tr><tr><td align="left">list.clear()</td><td align="left">移除列表中的所有项，等于del a[:]。</td></tr><tr><td align="left">list.index(x)</td><td align="left">返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</td></tr><tr><td align="left">list.count(x)</td><td align="left">返回 x 在列表中出现的次数。</td></tr><tr><td align="left">list.sort()</td><td align="left">对列表中的元素进行排序。</td></tr><tr><td align="left">list.reverse()</td><td align="left">倒排列表中的元素。</td></tr><tr><td align="left">list.copy()</td><td align="left">返回列表的浅复制，等于a[:]。</td></tr></tbody></table><p>下面示例演示了列表的大部分方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a.count(<span class="number">333</span>), a.count(<span class="number">66.25</span>), a.count(<span class="string">&#x27;x&#x27;</span>))</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.insert(<span class="number">2</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">333</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">66.25</span>, <span class="number">333</span>, -<span class="number">1</span>, <span class="number">333</span>, <span class="number">1</span>, <span class="number">1234.5</span>, <span class="number">333</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.index(<span class="number">333</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="number">333</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">66.25</span>, -<span class="number">1</span>, <span class="number">333</span>, <span class="number">1</span>, <span class="number">1234.5</span>, <span class="number">333</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">333</span>, <span class="number">1234.5</span>, <span class="number">1</span>, <span class="number">333</span>, -<span class="number">1</span>, <span class="number">66.25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[-<span class="number">1</span>, <span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span><br></pre></td></tr></table></figure><p>注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。</p><hr><h3 id="将列表当做堆栈使用"><a href="#将列表当做堆栈使用" class="headerlink" title="将列表当做堆栈使用"></a>将列表当做堆栈使用</h3><p>列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="将列表当作队列使用"><a href="#将列表当作队列使用" class="headerlink" title="将列表当作队列使用"></a>将列表当作队列使用</h3><p>也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue = deque([<span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Michael&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">&quot;Terry&quot;</span>)           <span class="comment"># Terry arrives</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">&quot;Graham&quot;</span>)          <span class="comment"># Graham arrives</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()                 <span class="comment"># The first to arrive now leaves</span></span><br><span class="line"><span class="string">&#x27;Eric&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()                 <span class="comment"># The second to arrive now leaves</span></span><br><span class="line"><span class="string">&#x27;John&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue                           <span class="comment"># Remaining queue in order of arrival</span></span><br><span class="line">deque([<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Terry&#x27;</span>, <span class="string">&#x27;Graham&#x27;</span>])</span><br></pre></td></tr></table></figure><hr><h3 id="列表推导式-1"><a href="#列表推导式-1" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p><p>每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。</p><p>这里我们将列表中每个数值乘三，获得一个新的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">3</span>*x <span class="keyword">for</span> x <span class="keyword">in</span> vec]</span><br><span class="line">[<span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]</span><br><span class="line"><span class="comment"># 现在我们玩一点小花样：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[x, x**<span class="number">2</span>] <span class="keyword">for</span> x <span class="keyword">in</span> vec]</span><br><span class="line">[[<span class="number">2</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">16</span>], [<span class="number">6</span>, <span class="number">36</span>]]</span><br><span class="line"><span class="comment"># 这里我们对序列里每一个元素逐个调用某方法：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>freshfruit = [<span class="string">&#x27;  banana&#x27;</span>, <span class="string">&#x27;  loganberry &#x27;</span>, <span class="string">&#x27;passion fruit  &#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[weapon.strip() <span class="keyword">for</span> weapon <span class="keyword">in</span> freshfruit]</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;loganberry&#x27;</span>, <span class="string">&#x27;passion fruit&#x27;</span>]</span><br><span class="line"><span class="comment"># 我们可以用 if 子句作为过滤器：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">3</span>*x <span class="keyword">for</span> x <span class="keyword">in</span> vec <span class="keyword">if</span> x &gt; <span class="number">3</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">18</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">3</span>*x <span class="keyword">for</span> x <span class="keyword">in</span> vec <span class="keyword">if</span> x &lt; <span class="number">2</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="comment"># 以下是一些关于循环和其它技巧的演示：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec1 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec2 = [<span class="number">4</span>, <span class="number">3</span>, -<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*y <span class="keyword">for</span> x <span class="keyword">in</span> vec1 <span class="keyword">for</span> y <span class="keyword">in</span> vec2]</span><br><span class="line">[<span class="number">8</span>, <span class="number">6</span>, -<span class="number">18</span>, <span class="number">16</span>, <span class="number">12</span>, -<span class="number">36</span>, <span class="number">24</span>, <span class="number">18</span>, -<span class="number">54</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x+y <span class="keyword">for</span> x <span class="keyword">in</span> vec1 <span class="keyword">for</span> y <span class="keyword">in</span> vec2]</span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, -<span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, -<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[vec1[i]*vec2[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vec1))]</span><br><span class="line">[<span class="number">8</span>, <span class="number">12</span>, -<span class="number">54</span>]</span><br><span class="line"><span class="comment"># 列表推导式可以使用复杂表达式或嵌套函数：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">str</span>(<span class="built_in">round</span>(<span class="number">355</span>/<span class="number">113</span>, i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line">[<span class="string">&#x27;3.1&#x27;</span>, <span class="string">&#x27;3.14&#x27;</span>, <span class="string">&#x27;3.142&#x27;</span>, <span class="string">&#x27;3.1416&#x27;</span>, <span class="string">&#x27;3.14159&#x27;</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="嵌套列表解析"><a href="#嵌套列表解析" class="headerlink" title="嵌套列表解析"></a>嵌套列表解析</h3><p>Python的列表还可以嵌套。</p><p>以下实例展示了3X4的矩阵列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure><p>以下实例将3X4的矩阵列表转换为4X3列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>以下实例也可以使用以下方法来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>另外一种实现方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># the following 3 lines implement the nested listcomp</span></span><br><span class="line"><span class="meta">... </span>    transposed_row = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line"><span class="meta">... </span>        transposed_row.append(row[i])</span><br><span class="line"><span class="meta">... </span>    transposed.append(transposed_row)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><hr><h3 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h3><p>使用 del 语句可以从一个列表中根据索引来删除一个元素，而不是值来删除元素。这与使用 pop() 返回一个值不同。可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">66.25</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[]</span><br><span class="line"><span class="comment"># 也可以用 del 删除实体变量：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure><hr><h3 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h3><p>元组由若干逗号分隔的值组成，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples may be nested:</span></span><br><span class="line"><span class="meta">... </span>u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">((<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号， 不过括号通常是必须的（如果元组是更大的表达式的一部分）。</p><hr><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。</p><p>可以用大括号({})创建集合。注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典，下一节我们会介绍这个数据结构。</p><p>以下是一个简单的演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                      <span class="comment"># 删除重复的</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                 <span class="comment"># 检测成员</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 以下演示了两个集合的操作</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  <span class="comment"># a 中唯一的字母</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># 在 a 中的字母，但不在 b 中</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># 在 a 或 b 中的字母</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># 在 a 和 b 中都有的字母</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># 在 a 或 b 中的字母，但不同时在 a 和 b 中</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>集合也支持推导式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>另一个非常有用的 Python 内建数据类型是字典。</p><p>序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。</p><p>理解字典的最佳方式是把它看做无序的键=&gt;值对集合。在同一个字典之内，关键字必须是互不相同。</p><p>一对大括号创建一个空的字典：{}。</p><p>这是一个字典运用的简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;guido&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="number">4098</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> tel[<span class="string">&#x27;sape&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;irv&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;irv&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(tel.keys())</span><br><span class="line">[<span class="string">&#x27;irv&#x27;</span>, <span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(tel.keys())</span><br><span class="line">[<span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;irv&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;guido&#x27;</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;jack&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>构造函数 dict() 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="string">&#x27;sape&#x27;</span>, <span class="number">4139</span>), (<span class="string">&#x27;guido&#x27;</span>, <span class="number">4127</span>), (<span class="string">&#x27;jack&#x27;</span>, <span class="number">4098</span>)])</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure><p>此外，字典推导可以用来创建任意键和值的表达式词典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure><p>如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>)</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历技巧"><a href="#遍历技巧" class="headerlink" title="遍历技巧"></a>遍历技巧</h3><p>在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knights = &#123;<span class="string">&#x27;gallahad&#x27;</span>: <span class="string">&#x27;the pure&#x27;</span>, <span class="string">&#x27;robin&#x27;</span>: <span class="string">&#x27;the brave&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure><p>在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;tic&#x27;</span>, <span class="string">&#x27;tac&#x27;</span>, <span class="string">&#x27;toe&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br></pre></td></tr></table></figure><p>同时遍历两个或更多的序列，可以使用 zip() 组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a))</span><br><span class="line">...</span><br><span class="line">What <span class="keyword">is</span> your name?  It <span class="keyword">is</span> lancelot.</span><br><span class="line">What <span class="keyword">is</span> your quest?  It <span class="keyword">is</span> the holy grail.</span><br><span class="line">What <span class="keyword">is</span> your favorite color?  It <span class="keyword">is</span> blue.</span><br></pre></td></tr></table></figure><p>要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(basket)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure><hr><h2 id="Python3-模块"><a href="#Python3-模块" class="headerlink" title="Python3 模块"></a>Python3 模块</h2><p>在前面的几个章节中我们基本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p><p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p><p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p><p>下面是一个使用 python 标准库中模块的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 文件名: using_sys.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;命令行参数如下:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\nPython 路径为：&#x27;</span>, sys.path, <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python using_sys.py 参数<span class="number">1</span> 参数<span class="number">2</span></span><br><span class="line">命令行参数如下:</span><br><span class="line">using_sys.py</span><br><span class="line">参数<span class="number">1</span></span><br><span class="line">参数<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python 路径为： [<span class="string">&#x27;/root&#x27;</span>, <span class="string">&#x27;/usr/lib/python3.4&#x27;</span>, <span class="string">&#x27;/usr/lib/python3.4/plat-x86_64-linux-gnu&#x27;</span>, <span class="string">&#x27;/usr/lib/python3.4/lib-dynload&#x27;</span>, <span class="string">&#x27;/usr/local/lib/python3.4/dist-packages&#x27;</span>, <span class="string">&#x27;/usr/lib/python3/dist-packages&#x27;</span>] </span><br></pre></td></tr></table></figure><ul><li>1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。</li><li>2、sys.argv 是一个包含命令行参数的列表。</li><li>3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</li></ul><hr><h3 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h3><p>想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1[, module2[,... moduleN]</span><br></pre></td></tr></table></figure><p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p><p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: support.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_func</span>(<span class="params"> par </span>):</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Hello : &quot;</span>, par)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>test.py 引入 support 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: test.py</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> support</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 现在可以调用模块里包含的函数了</span></span><br><span class="line">support.print_func(<span class="string">&quot;Runoob&quot;</span>)</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 test.py </span><br><span class="line">Hello :  Runoob</span><br></pre></td></tr></table></figure><p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p><p>当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？</p><p>这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。</p><p>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p><p>搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/usr/lib/python3.4&#x27;</span>, <span class="string">&#x27;/usr/lib/python3.4/plat-x86_64-linux-gnu&#x27;</span>, <span class="string">&#x27;/usr/lib/python3.4/lib-dynload&#x27;</span>, <span class="string">&#x27;/usr/local/lib/python3.4/dist-packages&#x27;</span>, <span class="string">&#x27;/usr/lib/python3/dist-packages&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>sys.path 输出是一个列表，其中第一项是空串’’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p><p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p><p>了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p><p>现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 斐波那契(fibonacci)数列模块</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):    <span class="comment"># 定义到 n 的斐波那契数列</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        <span class="built_in">print</span>(b, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib2</span>(<span class="params">n</span>): <span class="comment"># 返回到 n 的斐波那契数列</span></span><br><span class="line">    result = []</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        result.append(b)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>然后进入Python解释器，使用下面的命令导入这个模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br></pre></td></tr></table></figure><p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p><p>可以使用模块名称来访问函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;fibo.fib(<span class="number">1000</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fib2(<span class="number">100</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.__name__</span><br><span class="line"><span class="string">&#x27;fibo&#x27;</span></span><br></pre></td></tr></table></figure><p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure><hr><h3 id="from-…-import-语句"><a href="#from-…-import-语句" class="headerlink" title="from … import 语句"></a>from … import 语句</h3><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure><p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure><p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p><hr><h3 id="from-…-import-语句-1"><a href="#from-…-import-语句-1" class="headerlink" title="from … import * 语句"></a>from … import * 语句</h3><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p><hr><h3 id="深入模块"><a href="#深入模块" class="headerlink" title="深入模块"></a>深入模块</h3><p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。</p><p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。</p><p>所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。</p><p>从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。</p><p>模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。</p><p>还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure><p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。</p><p>这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure><p>这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p><hr><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="__name__属性"></a>__name__属性</h2><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python using_name.py</span><br><span class="line">程序自身在运行</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> using_name</span><br><span class="line">我来自另一模块</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 每个模块都有一个__name__属性，当其值是’<strong>main</strong>‘时，表明该模块自身在运行，否则是被引入。</p><p>说明：**<strong>name</strong>** 与 <strong><strong>main</strong></strong> 底下是双下划线， <strong>_ _</strong> 是这样去掉中间的那个空格。</p><hr><h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a>dir() 函数</h3><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo, sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(fibo)</span><br><span class="line">[<span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;fib&#x27;</span>, <span class="string">&#x27;fib2&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(sys)  </span><br><span class="line">[<span class="string">&#x27;__displayhook__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__excepthook__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__stderr__&#x27;</span>, <span class="string">&#x27;__stdin__&#x27;</span>, <span class="string">&#x27;__stdout__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;_clear_type_cache&#x27;</span>, <span class="string">&#x27;_current_frames&#x27;</span>, <span class="string">&#x27;_debugmallocstats&#x27;</span>, <span class="string">&#x27;_getframe&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;_home&#x27;</span>, <span class="string">&#x27;_mercurial&#x27;</span>, <span class="string">&#x27;_xoptions&#x27;</span>, <span class="string">&#x27;abiflags&#x27;</span>, <span class="string">&#x27;api_version&#x27;</span>, <span class="string">&#x27;argv&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;base_exec_prefix&#x27;</span>, <span class="string">&#x27;base_prefix&#x27;</span>, <span class="string">&#x27;builtin_module_names&#x27;</span>, <span class="string">&#x27;byteorder&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;call_tracing&#x27;</span>, <span class="string">&#x27;callstats&#x27;</span>, <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;displayhook&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;dont_write_bytecode&#x27;</span>, <span class="string">&#x27;exc_info&#x27;</span>, <span class="string">&#x27;excepthook&#x27;</span>, <span class="string">&#x27;exec_prefix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;executable&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>, <span class="string">&#x27;flags&#x27;</span>, <span class="string">&#x27;float_info&#x27;</span>, <span class="string">&#x27;float_repr_style&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getcheckinterval&#x27;</span>, <span class="string">&#x27;getdefaultencoding&#x27;</span>, <span class="string">&#x27;getdlopenflags&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getfilesystemencoding&#x27;</span>, <span class="string">&#x27;getobjects&#x27;</span>, <span class="string">&#x27;getprofile&#x27;</span>, <span class="string">&#x27;getrecursionlimit&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getrefcount&#x27;</span>, <span class="string">&#x27;getsizeof&#x27;</span>, <span class="string">&#x27;getswitchinterval&#x27;</span>, <span class="string">&#x27;gettotalrefcount&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;gettrace&#x27;</span>, <span class="string">&#x27;hash_info&#x27;</span>, <span class="string">&#x27;hexversion&#x27;</span>, <span class="string">&#x27;implementation&#x27;</span>, <span class="string">&#x27;int_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;intern&#x27;</span>, <span class="string">&#x27;maxsize&#x27;</span>, <span class="string">&#x27;maxunicode&#x27;</span>, <span class="string">&#x27;meta_path&#x27;</span>, <span class="string">&#x27;modules&#x27;</span>, <span class="string">&#x27;path&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;path_hooks&#x27;</span>, <span class="string">&#x27;path_importer_cache&#x27;</span>, <span class="string">&#x27;platform&#x27;</span>, <span class="string">&#x27;prefix&#x27;</span>, <span class="string">&#x27;ps1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;setcheckinterval&#x27;</span>, <span class="string">&#x27;setdlopenflags&#x27;</span>, <span class="string">&#x27;setprofile&#x27;</span>, <span class="string">&#x27;setrecursionlimit&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;setswitchinterval&#x27;</span>, <span class="string">&#x27;settrace&#x27;</span>, <span class="string">&#x27;stderr&#x27;</span>, <span class="string">&#x27;stdin&#x27;</span>, <span class="string">&#x27;stdout&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;thread_info&#x27;</span>, <span class="string">&#x27;version&#x27;</span>, <span class="string">&#x27;version_info&#x27;</span>, <span class="string">&#x27;warnoptions&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>() <span class="comment"># 得到一个当前模块中定义的属性列表</span></span><br><span class="line">[<span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;fib&#x27;</span>, <span class="string">&#x27;fibo&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span> <span class="comment"># 建立一个新的变量 &#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a <span class="comment"># 删除变量名a</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h3><p>Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的”库参考文档”）。</p><p>有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。</p><p>这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。</p><p>应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1</span><br><span class="line"><span class="string">&#x27;&gt;&gt;&gt; &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps2</span><br><span class="line"><span class="string">&#x27;... &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1 = <span class="string">&#x27;C&gt; &#x27;</span></span><br><span class="line">C&gt; <span class="built_in">print</span>(<span class="string">&#x27;Runoob!&#x27;</span>)</span><br><span class="line">Runoob!</span><br><span class="line">C&gt; </span><br></pre></td></tr></table></figure><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p><p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p><p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p><p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p><p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p><p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p><p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。</p><p>这里给出了一种可能的包结构（在分层的文件系统中）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sound/                          顶层包</span><br><span class="line">      __init__.py               初始化 sound 包</span><br><span class="line">      formats/                  文件格式转换子包</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  声音效果子包</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  filters 子包</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure><p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p><p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p><p>最简单的情况，放一个空的 :file:<code>__init__.py</code>就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） <code>__all__</code>变量赋值。</p><p>用户可以每次只导入一个包里面的特定模块，比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br></pre></td></tr></table></figure><p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sound.effects.echo.echofilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>还有一种导入子模块的方法是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure><p>这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo.echofilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>还有一种变化就是直接导入一个函数或者变量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter</span><br></pre></td></tr></table></figure><p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echofilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>注意当使用 <strong>from package import item</strong> 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p><p>import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <strong>:exc:ImportError</strong> 异常。</p><p>反之，如果使用形如 <strong>import item.subitem.subsubitem</strong> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p><h3 id="从一个包中导入"><a href="#从一个包中导入" class="headerlink" title="从一个包中导入*"></a>从一个包中导入*</h3><p>如果我们使用 <strong>from sound.effects import *</strong> 会发生什么呢？</p><p>Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。</p><p>但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。</p><p>在 Windows 平台上，我们无法确定一个叫做 ECHO.py 的文件导入为模块是 echo 还是 Echo，或者是 ECHO。</p><p>为了解决这个问题，我们只需要提供一个精确包的索引。</p><p>导入语句遵循如下规则：如果包定义文件 <strong><code>__init__.py</code></strong> 存在一个叫做 <strong><code>__all__</code></strong> 的列表变量，那么在使用 <strong>from package import *</strong> 的时候就把这个列表中的所有名字作为包内容导入。</p><p>作为包的作者，可别忘了在更新包之后保证 <strong><code>__all__</code></strong> 也更新了啊。</p><p>以下实例在 file:<code>sounds/effects/__init__.py</code> 中包含如下代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]</span><br></pre></td></tr></table></figure><p>这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。</p><p>如果 <strong><code>__all__</code></strong> 真的没有定义，那么使用**from sound.effects import ***这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行<code>__init__.py</code>里定义的初始化代码）。</p><p>这会把 <code>__init__.py</code> 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"><span class="keyword">import</span> sound.effects.surround</span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>这个例子中，在执行 from…import 前，包 sound.effects 中的 echo 和 surround 模块都被导入到当前的命名空间中了。（当然如果定义了 <code>__all__</code> 就更没问题了）</p><p>通常我们并不主张使用 ***** 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p><p>记住，使用 <strong>from Package import specific_submodule</strong> 这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p><p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包 sound.effects 中的模块 echo，你就要写成 from sound.effects import echo。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> echo</span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> formats</span><br><span class="line"><span class="keyword">from</span> ..filters <span class="keyword">import</span> equalizer</span><br></pre></td></tr></table></figure><p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”<strong>main</strong>“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p><p>包还提供一个额外的属性<code>__path__</code>。这是一个目录列表，里面每一个包含的目录都有为这个包服务的<code>__init__.py</code>，你得在其他<code>__init__.py</code>被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p><p>这个功能并不常用，一般用来扩展包里面的模块。</p><hr><h2 id="Python3-输入和输出"><a href="#Python3-输入和输出" class="headerlink" title="Python3 输入和输出"></a>Python3 输入和输出</h2><p>在前面几个章节中，我们其实已经接触了 Python 的输入输出的功能。本章节我们将具体介绍 Python 的输入输出。</p><h3 id="输出格式美化"><a href="#输出格式美化" class="headerlink" title="输出格式美化"></a>输出格式美化</h3><p>Python两种输出值的方式: 表达式语句和 print() 函数。</p><p>第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。</p><p>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</p><p>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。</p><ul><li><strong>str()：</strong> 函数返回一个用户易读的表达形式。</li><li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li></ul><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;Hello, Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(s)</span><br><span class="line"><span class="string">&#x27;Hello, Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;Hello, Runoob&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">1</span>/<span class="number">7</span>)</span><br><span class="line"><span class="string">&#x27;0.14285714285714285&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span> * <span class="number">3.25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">200</span> * <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;x 的值为： &#x27;</span> + <span class="built_in">repr</span>(x) + <span class="string">&#x27;,  y 的值为：&#x27;</span> + <span class="built_in">repr</span>(y) + <span class="string">&#x27;...&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">x 的值为： <span class="number">32.5</span>,  y 的值为：<span class="number">40000.</span>..</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#  repr() 函数可以转义字符串中的特殊字符</span></span><br><span class="line"><span class="meta">... </span>hello = <span class="string">&#x27;hello, runoob\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hellos = <span class="built_in">repr</span>(hello)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(hellos)</span><br><span class="line"><span class="string">&#x27;hello, runoob\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># repr() 的参数可以是 Python 的任何对象</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">repr</span>((x, y, (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>)))</span><br><span class="line"><span class="string">&quot;(32.5, 40000, (&#x27;Google&#x27;, &#x27;Runoob&#x27;))&quot;</span></span><br></pre></td></tr></table></figure><p>这里有两种方式输出一个平方与立方的表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="built_in">repr</span>(x).rjust(<span class="number">2</span>), <span class="built_in">repr</span>(x*x).rjust(<span class="number">3</span>), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># 注意前一行 &#x27;end&#x27; 的使用</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="built_in">repr</span>(x*x*x).rjust(<span class="number">4</span>))</span><br><span class="line">...</span><br><span class="line"> <span class="number">1</span>   <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"> <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> <span class="number">3</span>   <span class="number">9</span>   <span class="number">27</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">16</span>   <span class="number">64</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">25</span>  <span class="number">125</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">36</span>  <span class="number">216</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">49</span>  <span class="number">343</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">64</span>  <span class="number">512</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">81</span>  <span class="number">729</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;&#x27;</span>.<span class="built_in">format</span>(x, x*x, x*x*x))</span><br><span class="line">...</span><br><span class="line"> <span class="number">1</span>   <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"> <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> <span class="number">3</span>   <span class="number">9</span>   <span class="number">27</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">16</span>   <span class="number">64</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">25</span>  <span class="number">125</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">36</span>  <span class="number">216</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">49</span>  <span class="number">343</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">64</span>  <span class="number">512</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">81</span>  <span class="number">729</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在第一个例子中, 每列间的空格由 print() 添加。</p><p>这个例子展示了字符串对象的 rjust() 方法, 它可以将字符串靠右, 并在左边填充空格。</p><p>还有类似的方法, 如 ljust() 和 center()。 这些方法并不会写任何东西, 它们仅仅返回新的字符串。</p><p>另一个方法 zfill(), 它会在数字的左边填充 0，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;12&#x27;</span>.zfill(<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;00012&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;-3.14&#x27;</span>.zfill(<span class="number">7</span>)</span><br><span class="line"><span class="string">&#x27;-003.14&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;3.14159265359&#x27;</span>.zfill(<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;3.14159265359&#x27;</span></span><br></pre></td></tr></table></figure><p>str.format() 的基本使用如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;网址： &quot;&#123;&#125;!&quot;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;菜鸟教程&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>))</span><br><span class="line">菜鸟教程网址： <span class="string">&quot;www.runoob.com!&quot;</span></span><br></pre></td></tr></table></figure><p>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。</p><p>在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>))</span><br><span class="line">Google 和 Runoob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;1&#125; 和 &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>))</span><br><span class="line">Runoob 和 Google</span><br></pre></td></tr></table></figure><p>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;name&#125;网址： &#123;site&#125;&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;菜鸟教程&#x27;</span>, site=<span class="string">&#x27;www.runoob.com&#x27;</span>))</span><br><span class="line">菜鸟教程网址： www.runoob.com</span><br></pre></td></tr></table></figure><p>位置及关键字参数可以任意的结合:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;站点列表 &#123;0&#125;, &#123;1&#125;, 和 &#123;other&#125;。&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, other=<span class="string">&#x27;Taobao&#x27;</span>))</span><br><span class="line">站点列表 Google, Runoob, 和 Taobao。</span><br></pre></td></tr></table></figure><p><strong>!a</strong> (使用 <strong>ascii()</strong>), <strong>!s</strong> (使用 <strong>str()</strong>) 和 <strong>!r</strong> (使用 <strong>repr()</strong>) 可以用于在格式化某个值之前对其进行转化:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为： &#123;&#125;。&#x27;</span>.<span class="built_in">format</span>(math.pi))</span><br><span class="line">常量 PI 的值近似为： <span class="number">3.141592653589793</span>。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为： &#123;!r&#125;。&#x27;</span>.<span class="built_in">format</span>(math.pi))</span><br><span class="line">常量 PI 的值近似为： <span class="number">3.141592653589793</span>。</span><br></pre></td></tr></table></figure><p>可选项 <strong>:</strong> 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;</span>.<span class="built_in">format</span>(math.pi))</span><br><span class="line">常量 PI 的值近似为 <span class="number">3.142</span>。</span><br></pre></td></tr></table></figure><p>在 <strong>:</strong> 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = &#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, number <span class="keyword">in</span> table.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;</span>.<span class="built_in">format</span>(name, number))</span><br><span class="line">...</span><br><span class="line">Google     ==&gt;          <span class="number">1</span></span><br><span class="line">Runoob     ==&gt;          <span class="number">2</span></span><br><span class="line">Taobao     ==&gt;          <span class="number">3</span></span><br></pre></td></tr></table></figure><p>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。</p><p>最简单的就是传入一个字典, 然后使用方括号 <strong>[ ]</strong> 来访问键值 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = &#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Runoob: &#123;0[Runoob]:d&#125;; Google: &#123;0[Google]:d&#125;; Taobao: &#123;0[Taobao]:d&#125;&#x27;</span>.<span class="built_in">format</span>(table))</span><br><span class="line">Runoob: <span class="number">2</span>; Google: <span class="number">1</span>; Taobao: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>也可以通过在 table 变量前使用 ****** 来实现相同的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = &#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Runoob: &#123;Runoob:d&#125;; Google: &#123;Google:d&#125;; Taobao: &#123;Taobao:d&#125;&#x27;</span>.<span class="built_in">format</span>(**table))</span><br><span class="line">Runoob: <span class="number">2</span>; Google: <span class="number">1</span>; Taobao: <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="旧式字符串格式化"><a href="#旧式字符串格式化" class="headerlink" title="旧式字符串格式化"></a>旧式字符串格式化</h3><p><strong>%</strong> 操作符也可以实现字符串格式化。 它将左边的参数作为类似 <strong>sprintf()</strong> 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为：%5.3f。&#x27;</span> % math.pi)</span><br><span class="line">常量 PI 的值近似为：<span class="number">3.142</span>。</span><br></pre></td></tr></table></figure><p>因为 str.format() 是比较新的函数， 大多数的 Python 代码仍然使用 % 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format().</p><h3 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h3><p>Python 提供了 <a href="https://www.runoob.com/python3/python3-func-input.html">input() 内置函数</a>从标准输入读入一行文本，默认的标准输入是键盘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;你输入的内容是: &quot;</span>, <span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><p>这会产生如下的对应着输入的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入：菜鸟教程</span><br><span class="line">你输入的内容是:  菜鸟教程</span><br></pre></td></tr></table></figure><h3 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h3><p>open() 将会返回一个 file 对象，基本语法格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(filename, mode)</span><br></pre></td></tr></table></figure><ul><li>filename：包含了你要访问的文件名称的字符串值。</li><li>mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li></ul><p>不同模式打开文件的完全列表：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td align="left">rb</td><td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">rb+</td><td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">w</td><td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb</td><td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb+</td><td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">a</td><td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">ab</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td align="left">ab+</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><table><thead><tr><th align="center">模式</th><th align="center">r</th><th align="center">r+</th><th align="center">w</th><th align="center">w+</th><th align="center">a</th><th align="center">a+</th></tr></thead><tbody><tr><td align="center">读</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center">+</td></tr><tr><td align="center">写</td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="center">创建</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="center">覆盖</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">指针在开始</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">指针在结尾</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">+</td></tr></tbody></table><p>以下实例将字符串写入到文件 foo.txt 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.write( <span class="string">&quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><ul><li>第一个参数为要打开的文件名。</li><li>第二个参数描述文件如何使用的字符。 mode 可以是 ‘r’ 如果文件只读, ‘w’ 只用于写 (如果存在同名文件则将被删除), 和 ‘a’ 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. ‘r+’ 同时用于读写。 mode 参数是可选的; ‘r’ 将是默认值。</li></ul><p>此时打开文件 foo.txt,显示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /tmp/foo.txt </span><br><span class="line">Python 是一个非常好的语言。</span><br><span class="line">是的，的确非常好!!</span><br></pre></td></tr></table></figure><h3 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h3><p>本节中剩下的例子假设已经创建了一个称为 f 的文件对象。</p><h4 id="f-read"><a href="#f-read" class="headerlink" title="f.read()"></a>f.read()</h4><p>为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。</p><p>size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。</p><p>以下实例假定文件 foo.txt 已存在（上面实例中已创建）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python 是一个非常好的语言。</span><br><span class="line">是的，的确非常好!!</span><br></pre></td></tr></table></figure><h4 id="f-readline"><a href="#f-readline" class="headerlink" title="f.readline()"></a>f.readline()</h4><p>f.readline() 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = f.readline()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python 是一个非常好的语言。</span><br></pre></td></tr></table></figure><h4 id="f-readlines"><a href="#f-readlines" class="headerlink" title="f.readlines()"></a>f.readlines()</h4><p>f.readlines() 将返回该文件中包含的所有行。</p><p>如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;Python 是一个非常好的语言。\n&#x27;, &#x27;是的，的确非常好!!\n&#x27;]</span><br></pre></td></tr></table></figure><p>另一种方式是迭代一个文件对象然后读取每行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python 是一个非常好的语言。</span><br><span class="line">是的，的确非常好!!</span><br></pre></td></tr></table></figure><p>这个方法很简单, 但是并没有提供一个很好的控制。 因为两者的处理机制不同, 最好不要混用。</p><h4 id="f-write"><a href="#f-write" class="headerlink" title="f.write()"></a>f.write()</h4><p>f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">num = f.write( <span class="string">&quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29</span><br></pre></td></tr></table></figure><p>如果要写入一些不是字符串的东西, 那么将需要先进行转换:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">value = (<span class="string">&#x27;www.runoob.com&#x27;</span>, <span class="number">14</span>)</span><br><span class="line">s = <span class="built_in">str</span>(value)</span><br><span class="line">f.write(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>执行以上程序，打开 foo1.txt 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /tmp/foo1.txt </span><br><span class="line">(<span class="string">&#x27;www.runoob.com&#x27;</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure><h4 id="f-tell"><a href="#f-tell" class="headerlink" title="f.tell()"></a>f.tell()</h4><p>f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。</p><h4 id="f-seek"><a href="#f-seek" class="headerlink" title="f.seek()"></a>f.seek()</h4><p>如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。</p><p>from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：</p><ul><li>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符</li><li>seek(x,1) ： 表示从当前位置往后移动x个字符</li><li>seek(-x,2)：表示从文件的结尾往前移动x个字符</li></ul><p>from_what 值为默认为0，即文件开头。下面给出一个完整的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/tmp/foo.txt&#x27;</span>, <span class="string">&#x27;rb+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b&#x27;0123456789abcdef&#x27;</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">5</span>)     <span class="comment"># 移动到文件的第六个字节</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</span><br><span class="line"><span class="string">b&#x27;5&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(-<span class="number">3</span>, <span class="number">2</span>) <span class="comment"># 移动到文件的倒数第三字节</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</span><br><span class="line"><span class="string">b&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="f-close"><a href="#f-close" class="headerlink" title="f.close()"></a>f.close()</h4><p>在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。</p><p>当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">ValueError: I/O operation on closed file</span><br></pre></td></tr></table></figure><p>当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/foo.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    read_data = f.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>文件对象还有其他方法, 如 isatty() 和 trucate(), 但这些通常比较少用。</p><h3 id="pickle-模块"><a href="#pickle-模块" class="headerlink" title="pickle 模块"></a>pickle 模块</h3><p>python的pickle模块实现了基本的数据序列和反序列化。</p><p>通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。</p><p>通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p><p>基本接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pickle.dump(obj, file, [,protocol])</span><br></pre></td></tr></table></figure><p>有了 pickle 这个对象, 就能对 file 以读取的形式打开:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = pickle.load(file)</span><br></pre></td></tr></table></figure><p><strong>注解：</strong>从 file 中读取一个字符串，并将它重构为原来的python对象。</p><p><strong>file:</strong> 类文件对象，有read()和readline()接口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pickle模块将数据对象保存到文件</span></span><br><span class="line">data1 = &#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4</span>+<span class="number">6j</span>],</span><br><span class="line">         <span class="string">&#x27;b&#x27;</span>: (<span class="string">&#x27;string&#x27;</span>, <span class="string">u&#x27;Unicode string&#x27;</span>),</span><br><span class="line">         <span class="string">&#x27;c&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">selfref_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">selfref_list.append(selfref_list)</span><br><span class="line"></span><br><span class="line">output = <span class="built_in">open</span>(<span class="string">&#x27;data.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pickle dictionary using protocol 0.</span></span><br><span class="line">pickle.dump(data1, output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pickle the list using the highest protocol available.</span></span><br><span class="line">pickle.dump(selfref_list, output, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> pprint, pickle</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用pickle模块从文件中重构python对象</span></span><br><span class="line">pkl_file = <span class="built_in">open</span>(<span class="string">&#x27;data.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data1 = pickle.load(pkl_file)</span><br><span class="line">pprint.pprint(data1)</span><br><span class="line"></span><br><span class="line">data2 = pickle.load(pkl_file)</span><br><span class="line">pprint.pprint(data2)</span><br><span class="line"></span><br><span class="line">pkl_file.close()</span><br></pre></td></tr></table></figure><hr><h2 id="Python3-File-文件-方法"><a href="#Python3-File-文件-方法" class="headerlink" title="Python3 File(文件) 方法"></a>Python3 File(文件) 方法</h2><h3 id="open-方法"><a href="#open-方法" class="headerlink" title="open() 方法"></a>open() 方法</h3><p>Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。</p><p><strong>注意：</strong>使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。</p><p>open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p>完整的语法格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>file: 必需，文件路径（相对或者绝对路径）。</li><li>mode: 可选，文件打开模式</li><li>buffering: 设置缓冲</li><li>encoding: 一般使用utf8</li><li>errors: 报错级别</li><li>newline: 区分换行符</li><li>closefd: 传入的file参数类型</li><li>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</li></ul><p>mode 参数有：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">t</td><td align="left">文本模式 (默认)。</td></tr><tr><td align="left">x</td><td align="left">写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td align="left">b</td><td align="left">二进制模式。</td></tr><tr><td align="left">+</td><td align="left">打开一个文件进行更新(可读可写)。</td></tr><tr><td align="left">U</td><td align="left">通用换行模式（<strong>Python 3 不支持</strong>）。</td></tr><tr><td align="left">r</td><td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td align="left">rb</td><td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">rb+</td><td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td align="left">w</td><td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb</td><td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb+</td><td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="left">a</td><td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">ab</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td align="left">ab+</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>默认为文本模式，如果要以二进制模式打开，加上 <strong>b</strong> 。</p><h3 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h3><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-next.html">file.next()</a><strong>Python 3 中的 File 对象不支持 next() 方法。</strong>返回文件下一行。</td></tr><tr><td align="left">6</td><td align="left">[file.read(<a href="https://www.runoob.com/python3/python3-file-read.html">size])</a>从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td align="left">7</td><td align="left">[file.readline(<a href="https://www.runoob.com/python3/python3-file-readline.html">size])</a>读取整行，包括 “\n” 字符。</td></tr><tr><td align="left">8</td><td align="left">[file.readlines(<a href="https://www.runoob.com/python3/python3-file-readlines.html">sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td align="left">9</td><td align="left">[file.seek(offset<a href="https://www.runoob.com/python3/python3-file-seek.html">, whence])</a>移动文件读取指针到指定位置</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a>返回文件当前位置。</td></tr><tr><td align="left">11</td><td align="left">[file.truncate(<a href="https://www.runoob.com/python3/python3-file-truncate.html">size])</a>从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table><hr><h2 id="Python3-OS-文件-目录方法"><a href="#Python3-OS-文件-目录方法" class="headerlink" title="Python3 OS 文件/目录方法"></a>Python3 OS 文件/目录方法</h2><p><strong>os</strong> 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-access.html">os.access(path, mode)</a> 检验权限模式</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chdir.html">os.chdir(path)</a> 改变当前工作目录</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chflags.html">os.chflags(path, flags)</a> 设置路径的标记为数字标记。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chmod.html">os.chmod(path, mode)</a> 更改权限</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chown.html">os.chown(path, uid, gid)</a> 更改文件所有者</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chroot.html">os.chroot(path)</a> 改变当前进程的根目录</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-close.html">os.close(fd)</a> 关闭文件描述符 fd</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-closerange.html">os.closerange(fd_low, fd_high)</a> 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-dup.html">os.dup(fd)</a> 复制文件描述符 fd</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-dup2.html">os.dup2(fd, fd2)</a> 将一个文件描述符 fd 复制到另一个 fd2</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fchdir.html">os.fchdir(fd)</a> 通过文件描述符改变当前工作目录</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fchmod.html">os.fchmod(fd, mode)</a> 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fchown.html">os.fchown(fd, uid, gid)</a> 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fdatasync.html">os.fdatasync(fd)</a> 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td></tr><tr><td align="left">15</td><td align="left">[os.fdopen(fd<a href="https://www.runoob.com/python3/python3-os-fdopen.html">, mode[, bufsize]])</a> 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fpathconf.html">os.fpathconf(fd, name)</a> 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fstat.html">os.fstat(fd)</a> 返回文件描述符fd的状态，像stat()。</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fstatvfs.html">os.fstatvfs(fd)</a> 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fsync.html">os.fsync(fd)</a> 强制将文件描述符为fd的文件写入硬盘。</td></tr><tr><td align="left">20</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-ftruncate.html">os.ftruncate(fd, length)</a> 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td></tr><tr><td align="left">21</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-getcwd.html">os.getcwd()</a> 返回当前工作目录</td></tr><tr><td align="left">22</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-getcwdb.html">os.getcwdb()</a> 返回一个当前工作目录的Unicode对象</td></tr><tr><td align="left">23</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-isatty.html">os.isatty(fd)</a> 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td></tr><tr><td align="left">24</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lchflags.html">os.lchflags(path, flags)</a> 设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td></tr><tr><td align="left">25</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lchmod.html">os.lchmod(path, mode)</a> 修改连接文件权限</td></tr><tr><td align="left">26</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lchown.html">os.lchown(path, uid, gid)</a> 更改文件所有者，类似 chown，但是不追踪链接。</td></tr><tr><td align="left">27</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-link.html">os.link(src, dst)</a> 创建硬链接，名为参数 dst，指向参数 src</td></tr><tr><td align="left">28</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-listdir.html">os.listdir(path)</a> 返回path指定的文件夹包含的文件或文件夹的名字的列表。</td></tr><tr><td align="left">29</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lseek.html">os.lseek(fd, pos, how)</a> 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td></tr><tr><td align="left">30</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lstat.html">os.lstat(path)</a> 像stat(),但是没有软链接</td></tr><tr><td align="left">31</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-major.html">os.major(device)</a> 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td></tr><tr><td align="left">32</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-makedev.html">os.makedev(major, minor)</a> 以major和minor设备号组成一个原始设备号</td></tr><tr><td align="left">33</td><td align="left">[os.makedirs(path<a href="https://www.runoob.com/python3/python3-os-makedirs.html">, mode])</a> 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td></tr><tr><td align="left">34</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-minor.html">os.minor(device)</a> 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td></tr><tr><td align="left">35</td><td align="left">[os.mkdir(path<a href="https://www.runoob.com/python3/python3-os-mkdir.html">, mode])</a> 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td></tr><tr><td align="left">36</td><td align="left">[os.mkfifo(path<a href="https://www.runoob.com/python3/python3-os-mkfifo.html">, mode])</a> 创建命名管道，mode 为数字，默认为 0666 (八进制)</td></tr><tr><td align="left">37</td><td align="left">[os.mknod(filename<a href="https://www.runoob.com/python3/python3-os-mknod.html">, mode=0600, device])</a> 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td></tr><tr><td align="left">38</td><td align="left">[os.open(file, flags<a href="https://www.runoob.com/python3/python3-os-open.html">, mode])</a> 打开一个文件，并且设置需要的打开选项，mode参数是可选的</td></tr><tr><td align="left">39</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-openpty.html">os.openpty()</a> 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td></tr><tr><td align="left">40</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-pathconf.html">os.pathconf(path, name)</a> 返回相关文件的系统配置信息。</td></tr><tr><td align="left">41</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-pipe.html">os.pipe()</a> 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td></tr><tr><td align="left">42</td><td align="left">[os.popen(command<a href="https://www.runoob.com/python3/python3-os-popen.html">, mode[, bufsize]])</a> 从一个 command 打开一个管道</td></tr><tr><td align="left">43</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-read.html">os.read(fd, n)</a> 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td></tr><tr><td align="left">44</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-readlink.html">os.readlink(path)</a> 返回软链接所指向的文件</td></tr><tr><td align="left">45</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-remove.html">os.remove(path)</a> 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td></tr><tr><td align="left">46</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-removedirs.html">os.removedirs(path)</a> 递归删除目录。</td></tr><tr><td align="left">47</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-rename.html">os.rename(src, dst)</a> 重命名文件或目录，从 src 到 dst</td></tr><tr><td align="left">48</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-renames.html">os.renames(old, new)</a> 递归地对目录进行更名，也可以对文件进行更名。</td></tr><tr><td align="left">49</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-rmdir.html">os.rmdir(path)</a> 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td></tr><tr><td align="left">50</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-stat.html">os.stat(path)</a> 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td></tr><tr><td align="left">51</td><td align="left">[os.stat_float_times(<a href="https://www.runoob.com/python3/python3-os-stat_float_times.html">newvalue])</a> 决定stat_result是否以float对象显示时间戳</td></tr><tr><td align="left">52</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-statvfs.html">os.statvfs(path)</a> 获取指定路径的文件系统统计信息</td></tr><tr><td align="left">53</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-symlink.html">os.symlink(src, dst)</a> 创建一个软链接</td></tr><tr><td align="left">54</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-tcgetpgrp.html">os.tcgetpgrp(fd)</a> 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td></tr><tr><td align="left">55</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-tcsetpgrp.html">os.tcsetpgrp(fd, pg)</a> 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td></tr><tr><td align="left">56</td><td align="left">os.tempnam([dir[, prefix]]) <strong>Python3 中已删除。</strong>返回唯一的路径名用于创建临时文件。</td></tr><tr><td align="left">57</td><td align="left">os.tmpfile() <strong>Python3 中已删除。</strong>返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td></tr><tr><td align="left">58</td><td align="left">os.tmpnam() <strong>Python3 中已删除。</strong>为创建一个临时文件返回一个唯一的路径</td></tr><tr><td align="left">59</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-ttyname.html">os.ttyname(fd)</a> 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td></tr><tr><td align="left">60</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-unlink.html">os.unlink(path)</a> 删除文件路径</td></tr><tr><td align="left">61</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-utime.html">os.utime(path, times)</a> 返回指定的path文件的访问和修改的时间。</td></tr><tr><td align="left">62</td><td align="left">[os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])](<a href="https://www.runoob.com/python3/python3-os-walk.html">https://www.runoob.com/python3/python3-os-walk.html</a>) 输出在文件夹中的文件名通过在树中游走，向上或者向下。</td></tr><tr><td align="left">63</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-write.html">os.write(fd, str)</a> 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td></tr><tr><td align="left">64</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-path.html">os.path 模块</a> 获取文件的属性信息。</td></tr><tr><td align="left">65</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-pardir.html">os.pardir()</a> 获取当前目录的父目录，以字符串形式显示目录名。</td></tr></tbody></table><hr><h2 id="Python3-错误和异常"><a href="#Python3-错误和异常" class="headerlink" title="Python3 错误和异常"></a>Python3 错误和异常</h2><p>作为 Python 初学者，在刚学习 Python 编程时，经常会看到一些报错信息，在前面我们没有提及，这章节我们会专门介绍。</p><p>Python 有两种错误很容易辨认：语法错误和异常。</p><p>Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。</p><h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span> <span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> <span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号 <strong>:</strong> 。</p><p>语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。</p><p>大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)             <span class="comment"># 0 不能作为除数，触发异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> + spam*<span class="number">3</span>             <span class="comment"># spam 未定义，触发异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">NameError: name <span class="string">&#x27;spam&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;2&#x27;</span> + <span class="number">2</span>               <span class="comment"># int 不能与 str 相加，触发异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate <span class="built_in">str</span> (<span class="keyword">not</span> <span class="string">&quot;int&quot;</span>) to <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。</p><p>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="try-except"><a href="#try-except" class="headerlink" title="try/except"></a>try/except</h4><p>异常捕捉可以使用 <strong>try/except</strong> 语句。</p><p>以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字: &quot;</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;您输入的不是数字，请再次尝试输入！&quot;</span>)</span><br></pre></td></tr></table></figure><p>try 语句按照如下方式工作；</p><ul><li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。</li><li>如果没有异常发生，忽略 except 子句，try 子句执行后结束。</li><li>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。</li><li>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。</li></ul><p>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><p>处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。</p><p>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = <span class="built_in">int</span>(s.strip())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;OS error: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(err))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Could not convert data to an integer.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unexpected error:&quot;</span>, sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><h4 id="try-except…else"><a href="#try-except…else" class="headerlink" title="try/except…else"></a>try/except…else</h4><p><strong>try/except</strong> 语句还有一个可选的 <strong>else</strong> 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。</p><p>else 子句将在 try 子句没有发生任何异常的时候执行。</p><p>以下实例在 try 语句中判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(arg, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cannot open&#x27;</span>, arg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(arg, <span class="string">&#x27;has&#x27;</span>, <span class="built_in">len</span>(f.readlines()), <span class="string">&#x27;lines&#x27;</span>)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。</p><p>异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">this_fails</span>():</span><br><span class="line">        x = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        this_fails()</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Handling run-time error:&#x27;</span>, err)</span><br><span class="line">   </span><br><span class="line">Handling run-time error: <span class="built_in">int</span> division <span class="keyword">or</span> modulo by zero</span><br></pre></td></tr></table></figure><h4 id="try-finally-语句"><a href="#try-finally-语句" class="headerlink" title="try-finally 语句"></a>try-finally 语句</h4><p>try-finally 语句无论是否发生异常都将执行最后的代码。</p><p>以下实例中 finally 语句无论异常是否发生都会执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    runoob()</span><br><span class="line"><span class="keyword">except</span> AssertionError <span class="keyword">as</span> error:</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.log&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            read_data = file.read()</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> fnf_error:</span><br><span class="line">        <span class="built_in">print</span>(fnf_error)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这句话，无论异常是否发生都会执行。&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>Python 使用 raise 语句抛出一个指定的异常。</p><p>raise语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> [Exception [, args [, traceback]]]</span><br></pre></td></tr></table></figure><p>以下实例如果 x 大于 5 就触发异常:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br></pre></td></tr></table></figure><p>执行以上代码会触发异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">Exception: x 不能大于 <span class="number">5</span>。x 的值为: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。</p><p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameError(<span class="string">&#x27;HiThere&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;An exception flew by!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">   </span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure><h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><p>你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">MyError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">            self.value = value</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">repr</span>(self.value)</span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> MyError(<span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;My exception occurred, value:&#x27;</span>, e.value)</span><br><span class="line">   </span><br><span class="line">My exception occurred, value: <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> MyError(<span class="string">&#x27;oops!&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">__main__.MyError: <span class="string">&#x27;oops!&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，类 Exception 默认的 <code>__init__()</code> 被覆盖。</p><p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputError</span>(<span class="title class_ inherited__">Error</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Exception raised for errors in the input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        expression -- input expression in which the error occurred</span></span><br><span class="line"><span class="string">        message -- explanation of the error</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, expression, message</span>):</span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransitionError</span>(<span class="title class_ inherited__">Error</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not</span></span><br><span class="line"><span class="string">    allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        previous -- state at beginning of transition</span></span><br><span class="line"><span class="string">        next -- attempted new state</span></span><br><span class="line"><span class="string">        message -- explanation of why the specific transition is not allowed</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, previous, <span class="built_in">next</span>, message</span>):</span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure><p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。</p><h3 id="定义清理行为"><a href="#定义清理行为" class="headerlink" title="定义清理行为"></a>定义清理行为</h3><p>try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> KeyboardInterrupt</span><br><span class="line"><span class="meta">... </span><span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Goodbye, world!&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">Goodbye, world!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure><p>以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。</p><p>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。</p><p>下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = x / y</span><br><span class="line">        <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;division by zero!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;result is&quot;</span>, result)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;executing finally clause&quot;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divide(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">result <span class="keyword">is</span> <span class="number">2.0</span></span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divide(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">division by zero!</span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divide(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> divide</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> /: <span class="string">&#x27;str&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="预定义的清理行为"><a href="#预定义的清理行为" class="headerlink" title="预定义的清理行为"></a>预定义的清理行为</h3><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。</p><p>这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。</p><p>关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line, end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。</p><p>更多 with 关键字内容参考：<a href="https://www.runoob.com/python3/python-with.html">Python with 关键字</a></p><h3 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h3><p><a href="https://www.runoob.com/python3/python3-assert.html">Python assert（断言）</a></p><p><a href="https://www.runoob.com/python3/python-with.html">Python with 关键字</a></p><hr><h2 id="Python3-面向对象"><a href="#Python3-面向对象" class="headerlink" title="Python3 面向对象"></a>Python3 面向对象</h2><p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。</p><p>如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。</p><p>接下来我们先来简单的了解下面向对象的一些基本特征。</p><h3 id="面向对象技术简介"><a href="#面向对象技术简介" class="headerlink" title="面向对象技术简介"></a>面向对象技术简介</h3><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><p>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。</p><p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p><p>对象可以包含任意数量和类型的数据。</p><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>类对象支持两种操作：属性引用和实例化。</p><p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong>obj.name</strong>。</p><p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())</span><br></pre></td></tr></table></figure><p>以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</p><p>执行以上程序输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass 类的属性 i 为： <span class="number">12345</span></span><br><span class="line">MyClass 类的方法 f 输出为： hello world</span><br></pre></td></tr></table></figure><p>类有一个名为 <code>__init__()</code> 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用，像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.data = []</span><br></pre></td></tr></table></figure><p>类定义了 <code>__init__()</code> 方法，类的实例化操作会自动调用 <code>__init__()</code> 方法。如下实例化类 MyClass，对应的 <code>__init__()</code> 方法就会被调用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure><p>当然， <code>__init__()</code> 方法可以有参数，参数通过 <code>__init__()</code> 传递到类的实例化操作上。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, realpart, imagpart</span>):</span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line">x = Complex(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br><span class="line"><span class="built_in">print</span>(x.r, x.i)   <span class="comment"># 输出结果：3.0 -4.5</span></span><br></pre></td></tr></table></figure><h4 id="self代表类的实例，而非类"><a href="#self代表类的实例，而非类" class="headerlink" title="self代表类的实例，而非类"></a>self代表类的实例，而非类</h4><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>, 按照惯例它的名称是 self。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test instance at <span class="number">0x100771878</span>&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure><p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。</p><p>self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>(<span class="params">runoob</span>):</span><br><span class="line">        <span class="built_in">print</span>(runoob)</span><br><span class="line">        <span class="built_in">print</span>(runoob.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test instance at <span class="number">0x100771878</span>&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">p = people(<span class="string">&#x27;runoob&#x27;</span>,<span class="number">10</span>,<span class="number">30</span>)</span><br><span class="line">p.speak()</span><br></pre></td></tr></table></figure><p>执行以上程序输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob 说: 我 <span class="number">10</span> 岁。</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(<span class="title class_ inherited__">BaseClassName</span>):</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><p>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(modname.BaseClassName):</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure><p>执行以上程序输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ken 说: 我 <span class="number">10</span> 岁了，我在读 <span class="number">3</span> 年级</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(Base1, Base2, Base3):</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">speaker</span>():</span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,t</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sample</span>(speaker,student):</span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中参数位置排前父类的方法</span></span><br></pre></td></tr></table></figure><p>执行以上程序输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我叫 Tim，我是一个演说家，我演讲的主题是 Python</span><br></pre></td></tr></table></figure><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">myMethod</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用父类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>): <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">myMethod</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用子类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br><span class="line"><span class="built_in">super</span>(Child,c).myMethod() <span class="comment">#用子类对象调用父类已被覆盖的方法</span></span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/python/python-func-super.html">super() 函数</a>是用于调用父类(超类)的一个方法。</p><p>执行以上程序输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用子类方法</span><br><span class="line">调用父类方法</span><br></pre></td></tr></table></figure><p><strong>更多文档：</strong></p><p><a href="https://www.runoob.com/w3cnote/python-extends-init.html">Python 子类继承父类构造函数说明</a></p><h3 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h3><h4 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h4><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p><h4 id="类的方法-1"><a href="#类的方法-1" class="headerlink" title="类的方法"></a>类的方法</h4><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且为第一个参数，<strong>self</strong> 代表的是类的实例。</p><p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p><h4 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h4><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>类的私有属性实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JustCounter</span>:</span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self</span>):</span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span> (self.__secretCount)</span><br><span class="line"> </span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="built_in">print</span> (counter.publicCount)</span><br><span class="line"><span class="built_in">print</span> (counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br></pre></td></tr></table></figure><p>执行以上程序输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 16, in &lt;module&gt;</span><br><span class="line">    print (counter.__secretCount)  # 报错，实例不能访问私有变量</span><br><span class="line">AttributeError: &#x27;JustCounter&#x27; object has no attribute &#x27;__secretCount&#x27;</span><br></pre></td></tr></table></figure><p>类的私有方法实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Site</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, url</span>):</span><br><span class="line">        self.name = name       <span class="comment"># public</span></span><br><span class="line">        self.__url = url   <span class="comment"># private</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;name  : &#x27;</span>, self.name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;url : &#x27;</span>, self.__url)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__foo</span>(<span class="params">self</span>):          <span class="comment"># 私有方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是私有方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):            <span class="comment"># 公共方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是公共方法&#x27;</span>)</span><br><span class="line">        self.__foo()</span><br><span class="line"> </span><br><span class="line">x = Site(<span class="string">&#x27;菜鸟教程&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>)</span><br><span class="line">x.who()        <span class="comment"># 正常输出</span></span><br><span class="line">x.foo()        <span class="comment"># 正常输出</span></span><br><span class="line">x.__foo()      <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><h3 id="类的专有方法："><a href="#类的专有方法：" class="headerlink" title="类的专有方法："></a>类的专有方法：</h3><ul><li><strong><strong>init</strong> :</strong> 构造函数，在生成对象时调用</li><li><strong><strong>del</strong> :</strong> 析构函数，释放对象时使用</li><li><strong><strong>repr</strong> :</strong> 打印，转换</li><li><strong><strong>setitem</strong> :</strong> 按照索引赋值</li><li><strong><strong>getitem</strong>:</strong> 按照索引获取值</li><li><strong><strong>len</strong>:</strong> 获得长度</li><li><strong><strong>cmp</strong>:</strong> 比较运算</li><li><strong><strong>call</strong>:</strong> 函数调用</li><li><strong><strong>add</strong>:</strong> 加运算</li><li><strong><strong>sub</strong>:</strong> 减运算</li><li><strong><strong>mul</strong>:</strong> 乘运算</li><li><strong><strong>truediv</strong>:</strong> 除运算</li><li><strong><strong>mod</strong>:</strong> 求余运算</li><li><strong><strong>pow</strong>:</strong> 乘方</li></ul><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"> </span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(7,8)</span><br></pre></td></tr></table></figure><hr><h2 id="Python3-命名空间和作用域"><a href="#Python3-命名空间和作用域" class="headerlink" title="Python3 命名空间和作用域"></a>Python3 命名空间和作用域</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>先看看官方文档的一段话：</p><blockquote><p><em>A namespace is a mapping from names to objects.Most namespaces are currently implemented as Python dictionaries。</em></p></blockquote><p>命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p><p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p><p>我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。</p><p>一般有三种命名空间：</p><ul><li><strong>内置名称（built-in names</strong>）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</li><li><strong>全局名称（global names）</strong>，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li><li><strong>局部名称（local names）</strong>，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</li></ul><p>命名空间查找顺序:</p><p>假设我们要使用变量 runoob，则 Python 的查找顺序为：<strong>局部的命名空间去 -&gt; 全局命名空间 -&gt; 内置命名空间</strong>。</p><p>如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NameError: name &#x27;runoob&#x27; is not defined。</span><br></pre></td></tr></table></figure><p>命名空间的生命周期：</p><p>命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。</p><p>因此，我们无法从外部命名空间访问内部命名空间的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># var1 是全局名称</span></span><br><span class="line">var1 = <span class="number">5</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_func</span>():</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># var2 是局部名称</span></span><br><span class="line">    var2 = <span class="number">6</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_inner_func</span>():</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># var3 是内嵌的局部名称</span></span><br><span class="line">        var3 = <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><blockquote><p>A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace.</p></blockquote><p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</p><p>在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。</p><p>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</p><p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有4种，分别是：</p><p>有四种作用域：</p><ul><li><strong>L（Local）</strong>：最内层，包含局部变量，比如一个函数/方法内部。</li><li><strong>E（Enclosing）</strong>：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</li><li><strong>G（Global）</strong>：当前脚本的最外层，比如当前模块的全局变量。</li><li><strong>B（Built-in）</strong>： 包含了内建的变量/关键字等，最后被搜索。</li></ul><p>规则顺序： <strong>L –&gt; E –&gt; G –&gt; B</strong>。</p><p>在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g_count = <span class="number">0</span>  <span class="comment"># 全局作用域</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    o_count = <span class="number">1</span>  <span class="comment"># 闭包函数外的函数中</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        i_count = <span class="number">2</span>  <span class="comment"># 局部作用域</span></span><br></pre></td></tr></table></figure><p>内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> builtins</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(builtins)</span><br></pre></td></tr></table></figure><p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span> msg = <span class="string">&#x27;I am from Runoob&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">&#x27;I am from Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。</p><p>如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"><span class="meta">... </span>    msg_inner = <span class="string">&#x27;I am from Runoob&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg_inner</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;msg_inner&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p><h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p><p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">total = <span class="number">0</span> <span class="comment"># 这是一个全局变量</span></span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params"> arg1, arg2 </span>):</span><br><span class="line">    <span class="comment">#返回2个参数的和.&quot;</span></span><br><span class="line">    total = arg1 + arg2 <span class="comment"># total在这里是局部变量.</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;函数内是局部变量 : &quot;</span>, total)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用sum函数</span></span><br><span class="line"><span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;函数外是全局变量 : &quot;</span>, total)</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数内是局部变量 :  30</span><br><span class="line">函数外是全局变量 :  0</span><br></pre></td></tr></table></figure><h4 id="global-和-nonlocal关键字"><a href="#global-和-nonlocal关键字" class="headerlink" title="global 和 nonlocal关键字"></a>global 和 nonlocal关键字</h4><p>当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了。</p><p>以下实例修改全局变量 num：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>():</span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 需要使用 global 关键字声明</span></span><br><span class="line">    <span class="built_in">print</span>(num) </span><br><span class="line">    num = <span class="number">123</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">fun1()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">123</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> num   <span class="comment"># nonlocal关键字声明</span></span><br><span class="line">        num = <span class="number">100</span></span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line">    inner()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>另外有一种特殊情况，假设下面这段代码被运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>以上程序执行，报错信息如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    test()</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">5</span>, <span class="keyword">in</span> test</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;a&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure><p>错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。</p><p>修改 a 为全局变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">test()  <span class="comment"># 11</span></span><br></pre></td></tr></table></figure><p>也可以通过函数参数传递：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a</span>):</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">test(a)  <span class="comment"># 11</span></span><br></pre></td></tr></table></figure><hr><h2 id="Python3-标准库概览"><a href="#Python3-标准库概览" class="headerlink" title="Python3 标准库概览"></a>Python3 标准库概览</h2><h3 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h3><p>os模块提供了不少与操作系统相关联的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()      <span class="comment"># 返回当前的工作目录</span></span><br><span class="line"><span class="string">&#x27;C:\\Python34&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.chdir(<span class="string">&#x27;/server/accesslogs&#x27;</span>)   <span class="comment"># 修改当前的工作目录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">&#x27;mkdir today&#x27;</span>)   <span class="comment"># 执行系统命令 mkdir </span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>建议使用 “import os” 风格而非 “from os import *”。这样可以保证随操作系统不同而有所变化的 os.open() 不会覆盖内置函数 open()。</p><p>在使用 os 这样的大型模块时内置的 dir() 和 help() 函数非常有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(os)</span><br><span class="line">&lt;returns a <span class="built_in">list</span> of <span class="built_in">all</span> module functions&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(os)</span><br><span class="line">&lt;returns an extensive manual page created <span class="keyword">from</span> the module<span class="string">&#x27;s docstrings&gt;</span></span><br></pre></td></tr></table></figure><p>针对日常的文件和目录管理任务，:mod:shutil 模块提供了一个易于使用的高级接口:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shutil</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shutil.copyfile(<span class="string">&#x27;data.db&#x27;</span>, <span class="string">&#x27;archive.db&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shutil.move(<span class="string">&#x27;/build/executables&#x27;</span>, <span class="string">&#x27;installdir&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="文件通配符"><a href="#文件通配符" class="headerlink" title="文件通配符"></a>文件通配符</h3><p>glob模块提供了一个函数用于从目录通配符搜索中生成文件列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">&#x27;*.py&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;primes.py&#x27;</span>, <span class="string">&#x27;random.py&#x27;</span>, <span class="string">&#x27;quote.py&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="命令行参数-1"><a href="#命令行参数-1" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 “python demo.py one two three” 后可以得到以下输出结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(sys.argv)</span><br><span class="line">[<span class="string">&#x27;demo.py&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="错误输出重定向和程序终止"><a href="#错误输出重定向和程序终止" class="headerlink" title="错误输出重定向和程序终止"></a>错误输出重定向和程序终止</h3><p>sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.write(<span class="string">&#x27;Warning, log file not found starting a new one\n&#x27;</span>)</span><br><span class="line">Warning, log file <span class="keyword">not</span> found starting a new one</span><br></pre></td></tr></table></figure><p>大多脚本的定向终止都使用 “sys.exit()”。</p><h3 id="字符串正则匹配"><a href="#字符串正则匹配" class="headerlink" title="字符串正则匹配"></a>字符串正则匹配</h3><p>re模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;\bf[a-z]*&#x27;</span>, <span class="string">&#x27;which foot or hand fell fastest&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;foot&#x27;</span>, <span class="string">&#x27;fell&#x27;</span>, <span class="string">&#x27;fastest&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;(\b[a-z]+) \1&#x27;</span>, <span class="string">r&#x27;\1&#x27;</span>, <span class="string">&#x27;cat in the the hat&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;cat in the hat&#x27;</span></span><br></pre></td></tr></table></figure><p>如果只需要简单的功能，应该首先考虑字符串方法，因为它们非常简单，易于阅读和调试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;tea for too&#x27;</span>.replace(<span class="string">&#x27;too&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;tea for two&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>math模块为浮点运算提供了对底层C函数库的访问:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.cos(math.pi / <span class="number">4</span>)</span><br><span class="line"><span class="number">0.70710678118654757</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.log(<span class="number">1024</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">10.0</span></span><br></pre></td></tr></table></figure><p>random提供了生成随机数的工具。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;apple&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)   <span class="comment"># sampling without replacement</span></span><br><span class="line">[<span class="number">30</span>, <span class="number">83</span>, <span class="number">16</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">81</span>, <span class="number">41</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">33</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()    <span class="comment"># random float</span></span><br><span class="line"><span class="number">0.17970987693706186</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randrange(<span class="number">6</span>)    <span class="comment"># random integer chosen from range(6)</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="访问-互联网"><a href="#访问-互联网" class="headerlink" title="访问 互联网"></a>访问 互联网</h3><p>有几个模块用于访问互联网以及处理网络通信协议。其中最简单的两个是用于处理从 urls 接收的数据的 urllib.request 以及用于发送电子邮件的 smtplib:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> urlopen(<span class="string">&#x27;http://tycho.usno.navy.mil/cgi-bin/timer.pl&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>    line = line.decode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># Decoding the binary data to text.</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="string">&#x27;EST&#x27;</span> <span class="keyword">in</span> line <span class="keyword">or</span> <span class="string">&#x27;EDT&#x27;</span> <span class="keyword">in</span> line:  <span class="comment"># look for Eastern Time</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line">&lt;BR&gt;Nov. <span class="number">25</span>, 09:<span class="number">43</span>:<span class="number">32</span> PM EST</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server = smtplib.SMTP(<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.sendmail(<span class="string">&#x27;soothsayer@example.org&#x27;</span>, <span class="string">&#x27;jcaesar@example.org&#x27;</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">&quot;&quot;&quot;To: jcaesar@example.org</span></span><br><span class="line"><span class="string"><span class="meta">... </span>From: soothsayer@example.org</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Beware the Ides of March.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.quit()</span><br></pre></td></tr></table></figure><p>注意第二个例子需要本地有一个在运行的邮件服务器。</p><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>datetime模块为日期和时间处理同时提供了简单和复杂的方法。</p><p>支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。</p><p>该模块还支持时区处理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># dates are easily constructed and formatted</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = date.today()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.date(<span class="number">2003</span>, <span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.strftime(<span class="string">&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;</span>)</span><br><span class="line"><span class="string">&#x27;12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># dates support calendar arithmetic</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>birthday = date(<span class="number">1964</span>, <span class="number">7</span>, <span class="number">31</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = now - birthday</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.days</span><br><span class="line"><span class="number">14368</span></span><br></pre></td></tr></table></figure><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> zlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">b&#x27;witch which has which witches wrist watch&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">41</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = zlib.compress(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(t)</span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zlib.decompress(t)</span><br><span class="line"><span class="string">b&#x27;witch which has which witches wrist watch&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zlib.crc32(s)</span><br><span class="line"><span class="number">226805979</span></span><br></pre></td></tr></table></figure><h3 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h3><p>有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。</p><p>例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多,timeit 证明了现代的方法更快一些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Timer(<span class="string">&#x27;t=a; a=b; b=t&#x27;</span>, <span class="string">&#x27;a=1; b=2&#x27;</span>).timeit()</span><br><span class="line"><span class="number">0.57535828626024577</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Timer(<span class="string">&#x27;a,b = b,a&#x27;</span>, <span class="string">&#x27;a=1; b=2&#x27;</span>).timeit()</span><br><span class="line"><span class="number">0.54962537085770791</span></span><br></pre></td></tr></table></figure><p>相对于 timeit 的细粒度，:mod:profile 和 pstats 模块提供了针对更大代码块的时间度量工具。</p><h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><p>开发高质量软件的方法之一是为每一个函数开发测试代码，并且在开发过程中经常进行测试</p><p>doctest模块提供了一个工具，扫描模块并根据程序中内嵌的文档字符串执行测试。</p><p>测试构造如同简单的将它的输出结果剪切并粘贴到文档字符串中。</p><p>通过用户提供的例子，它强化了文档，允许 doctest 模块确认代码的结果是否与文档一致:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">values</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Computes the arithmetic mean of a list of numbers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(average([20, 30, 70]))</span></span><br><span class="line"><span class="string">    40.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(values) / <span class="built_in">len</span>(values)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line">doctest.testmod()   <span class="comment"># 自动验证嵌入测试</span></span><br></pre></td></tr></table></figure><p>unittest模块不像 doctest模块那么容易使用，不过它可以在一个独立的文件里提供一个更全面的测试集:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestStatisticalFunctions</span>(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_average</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertEqual(average([<span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>]), <span class="number">40.0</span>)</span><br><span class="line">        self.assertEqual(<span class="built_in">round</span>(average([<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>]), <span class="number">1</span>), <span class="number">4.3</span>)</span><br><span class="line">        self.assertRaises(ZeroDivisionError, average, [])</span><br><span class="line">        self.assertRaises(TypeError, average, <span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">unittest.main() <span class="comment"># Calling from the command line invokes all tests</span></span><br></pre></td></tr></table></figure><hr><h2 id="Python3-实例"><a href="#Python3-实例" class="headerlink" title="Python3 实例"></a>Python3 实例</h2><p>以下实例在 Python3.4.3 版本下测试通过：</p><ul><li><a href="https://www.runoob.com/python3/python3-helloworld.html">Python Hello World 实例</a></li><li><a href="https://www.runoob.com/python3/python3-add-number.html">Python 数字求和</a></li><li><a href="https://www.runoob.com/python3/python3-square-root.html">Python 平方根</a></li><li><a href="https://www.runoob.com/python3/python3-quadratic-roots.html">Python 二次方程</a></li><li><a href="https://www.runoob.com/python3/python3-area-triangle.html">Python 计算三角形的面积</a></li><li><a href="https://www.runoob.com/python3/python3-area-of-a-circle.html">Python 计算圆的面积</a></li><li><a href="https://www.runoob.com/python3/python3-random-number.html">Python 随机数生成</a></li><li><a href="https://www.runoob.com/python3/python3-celsius-fahrenheit.html">Python 摄氏温度转华氏温度</a></li><li><a href="https://www.runoob.com/python3/python3-swap-variables.html">Python 交换变量</a></li><li><a href="https://www.runoob.com/python3/python3-if-example.html">Python if 语句</a></li><li><a href="https://www.runoob.com/python3/python3-check-is-number.html">Python 判断字符串是否为数字</a></li><li><a href="https://www.runoob.com/python3/python3-odd-even.html">Python 判断奇数偶数</a></li><li><a href="https://www.runoob.com/python3/python3-leap-year.html">Python 判断闰年</a></li><li><a href="https://www.runoob.com/python3/python3-largest-number.html">Python 获取最大值函数</a></li><li><a href="https://www.runoob.com/python3/python3-prime-number.html">Python 质数判断</a></li><li><a href="https://www.runoob.com/python3/python3-prime-number-intervals.html">Python 输出指定范围内的素数</a></li><li><a href="https://www.runoob.com/python3/python3-factorial.html">Python 阶乘实例</a></li><li><a href="https://www.runoob.com/python3/python3-99-table.html">Python 九九乘法表</a></li><li><a href="https://www.runoob.com/python3/python3-fibonacci-sequence.html">Python 斐波那契数列</a></li><li><a href="https://www.runoob.com/python3/python3-armstrong-number.html">Python 阿姆斯特朗数</a></li><li><a href="https://www.runoob.com/python3/python3-conversion-binary-octal-hexadecimal.html">Python 十进制转二进制、八进制、十六进制</a></li><li><a href="https://www.runoob.com/python3/python3-ascii-character.html">Python ASCII码与字符相互转换</a></li><li><a href="https://www.runoob.com/python3/python3-hcf.html">Python 最大公约数算法</a></li><li><a href="https://www.runoob.com/python3/python3-lcm.html">Python 最小公倍数算法</a></li><li><a href="https://www.runoob.com/python3/python3-calculator.html">Python 简单计算器实现</a></li><li><a href="https://www.runoob.com/python3/python3-calendar.html">Python 生成日历</a></li><li><a href="https://www.runoob.com/python3/python3-fibonacci-recursion.html">Python 使用递归斐波那契数列</a></li><li><a href="https://www.runoob.com/python3/python3-file-io.html">Python 文件 IO</a></li><li><a href="https://www.runoob.com/python3/python3-check-string.html">Python 字符串判断</a></li><li><a href="https://www.runoob.com/python3/python3-upper-lower.html">Python 字符串大小写转换</a></li><li><a href="https://www.runoob.com/python3/python3-month-days.html">Python 计算每个月天数</a></li><li><a href="https://www.runoob.com/python3/python3-get-yesterday.html">Python 获取昨天日期</a></li><li><a href="https://www.runoob.com/python3/python3-list-operator.html">Python list 常用操作</a></li><li><a href="https://www.runoob.com/python3/python-joseph-life-dead-game.html">Python 约瑟夫生者死者小游戏</a></li><li><a href="https://www.runoob.com/python3/python-five-fish.html">Python 五人分鱼</a></li><li><a href="https://www.runoob.com/python3/python-simplestopwatch.html">Python 实现秒表功能</a></li><li><a href="https://www.runoob.com/python3/python-cube-sum.html">Python 计算 n 个自然数的立方和</a></li><li><a href="https://www.runoob.com/python3/python3-sum-array.html">Python 计算数组元素之和</a></li><li><a href="https://www.runoob.com/python3/python3-array-rotation.html">Python 数组翻转指定个数的元素</a></li><li><a href="https://www.runoob.com/python3/python-list-interchange.html">Python 将列表中的头尾两个元素对调</a></li><li><a href="https://www.runoob.com/python3/python3-list-swap-two-elements.html">Python 将列表中的指定位置的两个元素对调</a></li><li><a href="https://www.runoob.com/python3/python-reversing-list.html">Python 翻转列表</a></li><li><a href="https://www.runoob.com/python3/python-check-element-exists-in-list.html">Python 判断元素是否在列表中存在</a></li><li><a href="https://www.runoob.com/python3/python-clear-list.html">Python 清空列表</a></li><li><a href="https://www.runoob.com/python3/python-remove-duplicate-from-list.html">Python 移除列表中重复的元素</a></li><li><a href="https://www.runoob.com/python3/python-copy-list.html">Python 复制列表</a></li><li><a href="https://www.runoob.com/python3/python-count-occurrences-element-list.html">Python 计算元素在列表中出现的次数</a></li><li><a href="https://www.runoob.com/python3/python-sum-list.html">Python 计算列表元素之和</a></li><li><a href="https://www.runoob.com/python3/python-multiply-list.html">Python 计算列表元素之积</a></li><li><a href="https://www.runoob.com/python3/python-min-list-element.html">Python 查找列表中最小元素</a></li><li><a href="https://www.runoob.com/python3/python-max-list-element.html">Python 查找列表中最大元素</a></li><li><a href="https://www.runoob.com/python3/pyhton-remove-ith-character-from-string.html">Python 移除字符串中的指定位置字符</a></li><li><a href="https://www.runoob.com/python3/python-check-substring-present-given-string.html">Python 判断字符串是否存在子字符串</a></li><li><a href="https://www.runoob.com/python3/python-string-length.html">Python 判断字符串长度</a></li><li><a href="https://www.runoob.com/python3/python-find-url-string.html">Python 使用正则表达式提取字符串中的 URL</a></li><li><a href="https://www.runoob.com/python3/python-execute-string-code.html">Python 将字符串作为代码执行</a></li><li><a href="https://www.runoob.com/python3/python-string-reverse.html">Python 字符串翻转</a></li><li><a href="https://www.runoob.com/python3/python-slicing-rotate-string.html">Python 对字符串切片及翻转</a></li><li><a href="https://www.runoob.com/python3/python-sort-dictionaries-by-key-or-value.html">Python 按键(key)或值(value)对字典进行排序</a></li><li><a href="https://www.runoob.com/python3/python-sum-dictionary.html">Python 计算字典值之和</a></li><li><a href="https://www.runoob.com/python3/python-remove-a-key-from-dictionary.html">Python 移除字典点键值(key/value)对</a></li><li><a href="https://www.runoob.com/python3/python-merging-two-dictionaries.html">Python 合并字典</a></li><li><a href="https://www.runoob.com/python3/python-str-timestamp.html">Python 将字符串的时间转换为时间戳</a></li><li><a href="https://www.runoob.com/python3/python-get-dayago.html">Python 获取几天前的时间</a></li><li><a href="https://www.runoob.com/python3/python-timstamp-str.html">Python 将时间戳转换为指定格式日期</a></li><li><a href="https://www.runoob.com/python3/python-your-font.html">Python 打印自己设计的字体</a></li><li><a href="https://www.runoob.com/python3/python-binary-search.html">Python 二分查找</a></li><li><a href="https://www.runoob.com/python3/python-linear-search.html">Python 线性查找</a></li><li><a href="https://www.runoob.com/python3/python-insertion-sort.html">Python 插入排序</a></li><li><a href="https://www.runoob.com/python3/python-quicksort.html">Python 快速排序</a></li><li><a href="https://www.runoob.com/python3/python-selection-sort.html">Python 选择排序</a></li><li><a href="https://www.runoob.com/python3/python-bubble-sort.html">Python 冒泡排序</a></li><li><a href="https://www.runoob.com/python3/python-merge-sort.html">Python 归并排序</a></li><li><a href="https://www.runoob.com/python3/python-heap-sort.html">Python 堆排序</a></li><li><a href="https://www.runoob.com/python3/python-counting-sort.html">Python 计数排序</a></li><li><a href="https://www.runoob.com/python3/python-shellsort.html">Python 希尔排序</a></li><li><a href="https://www.runoob.com/python3/python-topological-sorting.html">Python 拓扑排序</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据处理</title>
      <link href="/2022/02/16/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2022/02/16/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>数据处理过程中的相关操作整理。</p><span id="more"></span><p>加载数据处理包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np   <span class="comment"># pandas和numpy常常结合在一起使用，导入numpy库</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  <span class="comment"># 导入pandas库</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pd.__version__) <span class="comment"># 打印pandas版本信息</span></span><br></pre></td></tr></table></figure><p>读取csv文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file1 = pd.read_csv(<span class="string">&#x27;/home/maocy/jupyter/datasets/data_process/Organisation.csv&#x27;</span>)</span><br><span class="line">df = pd.DataFrame(file1)</span><br><span class="line"><span class="built_in">print</span>(df.info())</span><br></pre></td></tr></table></figure><p>获取所有列名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取列名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(file1))</span><br><span class="line"><span class="comment"># 将列名保存到txt文件中</span></span><br><span class="line">columns_name = <span class="built_in">list</span>(file1)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./columns_name.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">str1 = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">f.write(str1.join(columns_name))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>取出部分列的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data1 = &#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>], <span class="string">&#x27;B&#x27;</span>:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;C&#x27;</span>:[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>], <span class="string">&#x27;D&#x27;</span>:[<span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;</span><br><span class="line">df =pd.DataFrame(data1)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   A  B   C  D</span></span><br><span class="line"><span class="string">0  M  1  10  8</span></span><br><span class="line"><span class="string">1  C  2   9  8</span></span><br><span class="line"><span class="string">2  Y  3   8  9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">df1 = df.loc[ :, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>] ]</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   A  B</span></span><br><span class="line"><span class="string">0  M  1</span></span><br><span class="line"><span class="string">1  C  2</span></span><br><span class="line"><span class="string">2  Y  3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>数据进行合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data2 = &#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>], <span class="string">&#x27;B&#x27;</span>:[<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;C&#x27;</span>:[<span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>], <span class="string">&#x27;D&#x27;</span>:[<span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;</span><br><span class="line">df2 = pd.DataFrame(data2)</span><br><span class="line"></span><br><span class="line">df_1_2 = df1.append(df2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">0M1NaNNaN</span></span><br><span class="line"><span class="string">1C2NaNNaN</span></span><br><span class="line"><span class="string">2Y3NaNNaN</span></span><br><span class="line"><span class="string">0M29.08.0</span></span><br><span class="line"><span class="string">1C29.08.0</span></span><br><span class="line"><span class="string">2Y38.09.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>删除表中任何列中含有NaN的行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df_1_2.dropna(axis=<span class="number">0</span>, how=<span class="string">&#x27;any&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">0M29.08.0</span></span><br><span class="line"><span class="string">1C29.08.0</span></span><br><span class="line"><span class="string">2Y38.09.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>删除dfxxx的前三行数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfxxx.drop(dfxxx.head(<span class="number">3</span>).index, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>去除重复数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">df_2 = df.append(df2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">0M1108</span></span><br><span class="line"><span class="string">1C298</span></span><br><span class="line"><span class="string">2Y389</span></span><br><span class="line"><span class="string">0M298</span></span><br><span class="line"><span class="string">1C298</span></span><br><span class="line"><span class="string">2Y389</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">df_2.drop_duplicates()  <span class="comment">#不去重复项</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">0M1108</span></span><br><span class="line"><span class="string">1C298</span></span><br><span class="line"><span class="string">2Y389</span></span><br><span class="line"><span class="string">0M298</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">df_2.drop_duplicates(keep=<span class="literal">False</span>) <span class="comment"># 去重复项</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">0M1108</span></span><br><span class="line"><span class="string">0M298</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">df_2.drop_duplicates(subset=<span class="string">&#x27;A&#x27;</span>) <span class="comment"># 以 A 列作为参考</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">0M1108</span></span><br><span class="line"><span class="string">1C298</span></span><br><span class="line"><span class="string">2Y389</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>获取一模一样重复值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([df_2.drop_duplicates(), df_2.drop_duplicates(keep=<span class="literal">False</span>)]).drop_duplicates(keep=<span class="literal">False</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">1C298</span></span><br><span class="line"><span class="string">2Y389</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>获取A列一样，其他列不一样的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([df_2, df_2.drop_duplicates(subset=<span class="string">&#x27;A&#x27;</span>, keep=<span class="literal">False</span>)]).drop_duplicates(keep=<span class="literal">False</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ABCD</span></span><br><span class="line"><span class="string">0M1108</span></span><br><span class="line"><span class="string">0M298</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>对列换名操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df1.rename(columns=&#123;<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;B&#x27;</span>:<span class="string">&#x27;2&#x27;</span>&#125;, inplace = <span class="literal">True</span>)</span><br><span class="line">df1</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">12</span></span><br><span class="line"><span class="string">0M1</span></span><br><span class="line"><span class="string">1C2</span></span><br><span class="line"><span class="string">2Y3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>按label1列进行合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_department_merge =df_department.merge(df_label,on=[<span class="string">&#x27;label1&#x27;</span>])</span><br><span class="line">df_department_merge</span><br></pre></td></tr></table></figure><p>向指定位置添加列，及赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">col_name1=df_department_merge1.columns.tolist()</span><br><span class="line"><span class="built_in">print</span>(col_name1)</span><br><span class="line">col_name1.insert(<span class="number">1</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">df_department_merge1=df_department_merge1.reindex(columns=col_name1)</span><br><span class="line">df_department_merge1[<span class="string">&#x27;r&#x27;</span>]=<span class="string">&#x27;department&#x27;</span></span><br><span class="line">df_department_merge1</span><br></pre></td></tr></table></figure><p>导出csv文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_2.to_csv(<span class="string">&quot;point.csv&quot;</span>)</span><br><span class="line"><span class="comment"># header=None, index=False 数据集格式！</span></span><br><span class="line">data_train.to_csv(<span class="string">&quot;train.csv&quot;</span>, header=<span class="literal">None</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>生出数据集的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    此脚本将数据集分为训练集和测试集和验证集 8:1:1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = pd.read_csv(<span class="string">&quot;/home/maocy/jupyter/2022/DBpedia_geo/ALL.csv&quot;</span>, header=<span class="literal">None</span>)  <span class="comment">#加载数据</span></span><br><span class="line">    data:pd.DataFrame = data.sample(frac=<span class="number">1.0</span>)                     <span class="comment">#将数据打乱</span></span><br><span class="line">    rows, cols = data.shape</span><br><span class="line">    split_index_1 = <span class="built_in">int</span>(rows * <span class="number">0.1</span>)</span><br><span class="line">    split_index_2 = <span class="built_in">int</span>(rows * <span class="number">0.2</span>)</span><br><span class="line">    <span class="comment">#数据分割</span></span><br><span class="line">    data_test:pd.DataFrame = data.iloc[<span class="number">0</span>: split_index_1, :]</span><br><span class="line">    data_validate:pd.DataFrame = data.iloc[split_index_1:split_index_2, :]</span><br><span class="line">    data_train:pd.DataFrame = data.iloc[split_index_2: rows, :]</span><br><span class="line">    <span class="comment">#数据保存</span></span><br><span class="line">    data_test.to_csv(<span class="string">&quot;test.csv&quot;</span>, header=<span class="literal">None</span>, index=<span class="literal">False</span>)</span><br><span class="line">    data_validate.to_csv(<span class="string">&quot;validate.csv&quot;</span>, header=<span class="literal">None</span>, index=<span class="literal">False</span>)</span><br><span class="line">    data_train.to_csv(<span class="string">&quot;train.csv&quot;</span>, header=<span class="literal">None</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;划分完毕&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据处理 </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的基本操作</title>
      <link href="/2022/02/14/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/hexo/"/>
      <url>/2022/02/14/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo的一些基本操作。</p><span id="more"></span><h1 id="1-Init-初始化"><a href="#1-Init-初始化" class="headerlink" title="1. Init 初始化"></a>1. Init 初始化</h1><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure><h1 id="2-New-新建"><a href="#2-New-新建" class="headerlink" title="2. New 新建"></a>2. New 新建</h1><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 _config.yml 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：</span></span><br><span class="line">hexo n 666   #产生666.md文章</span><br><span class="line">hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure><h1 id="3-新建标签"><a href="#3-新建标签" class="headerlink" title="3. 新建标签"></a>3. 新建标签</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n page tags  # 产生 tags 标签</span><br></pre></td></tr></table></figure><h1 id="4-Generate-生成"><a href="#4-Generate-生成" class="headerlink" title="4. Generate 生成"></a>4. Generate 生成</h1><p>生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-d</td><td align="center">文件生成后立即部署网站</td></tr></tbody></table><p>该命令也可以简写为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h1 id="5-Publish-发布"><a href="#5-Publish-发布" class="headerlink" title="5. Publish 发布"></a>5. Publish 发布</h1><p>发布草稿</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h1 id="6-Server-运行"><a href="#6-Server-运行" class="headerlink" title="6. Server 运行"></a>6. Server 运行</h1><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>该命令也可以简写为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th>描述</th></tr></thead><tbody><tr><td align="center">-p</td><td>重设端口</td></tr><tr><td align="center">-s</td><td>只使用静态文件</td></tr><tr><td align="center">-l</td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h1 id="7-Deploy-部署"><a href="#7-Deploy-部署" class="headerlink" title="7. Deploy 部署"></a>7. Deploy 部署</h1><p>部署网站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="8-Clean-清除缓存"><a href="#8-Clean-清除缓存" class="headerlink" title="8. Clean 清除缓存"></a>8. Clean 清除缓存</h1><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>其他详细的内容，可参考<a href="https://hexo.io/zh-cn/docs/commands.html">官方文档</a>！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 五分钟教程</title>
      <link href="/2022/02/14/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/git/"/>
      <url>/2022/02/14/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/git/</url>
      
        <content type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><span id="more"></span><p>使用Git前，需要先建立一个仓库(repository)。您可以使用一个已经存在的目录作为Git仓库或创建一个空目录。使用您当前目录作为Git仓库，我们只需使它初始化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>使用我们指定目录作为Git仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure><p>从现在开始，我们将假设您在Git仓库根目录下，除非另有说明。</p><h1 id="1-添加新文件"><a href="#1-添加新文件" class="headerlink" title="1. 添加新文件"></a>1. 添加新文件</h1><p>我们有一个仓库，但什么也没有，可以使用add命令添加文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br></pre></td></tr></table></figure><p>可以使用add… 继续添加任务文件。</p><h1 id="2-提交版本"><a href="#2-提交版本" class="headerlink" title="2. 提交版本"></a>2. 提交版本</h1><p>现在我们已经添加了这些文件，我们希望它们能够真正被保存在Git仓库。为此，我们将它们提交到仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Adding files&quot;</span><br></pre></td></tr></table></figure><p>如果您不使用-m，会出现编辑器来让你写自己的注释信息。</p><p>当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;Changed some files&quot;</span><br></pre></td></tr></table></figure><p>git commit 命令的-a选项可将所有<strong>被修改或者已删除的且已经被git管理的文档</strong>提交到仓库中。</p><p><font color=red >千万注意，-a不会造成新文件被提交，只能修改。</font></p><h1 id="3-发布版本"><a href="#3-发布版本" class="headerlink" title="3. 发布版本"></a>3. 发布版本</h1><p>我们先从服务器克隆一个库并上传。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://example.com/~/www/project.git</span><br></pre></td></tr></table></figure><p>现在我们修改之后可以进行推送到服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push ssh://example.com/~/www/project.git</span><br></pre></td></tr></table></figure><h1 id="4-取回更新"><a href="#4-取回更新" class="headerlink" title="4. 取回更新"></a>4. 取回更新</h1><p>如果您已经按上面的进行push，下面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>从非默认位置更新到指定的url。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull http://git.example.com/project.git</span><br></pre></td></tr></table></figure><h1 id="5-删除"><a href="#5-删除" class="headerlink" title="5.删除"></a>5.删除</h1><p>如何你想从资源库中删除文件，我们使用rm。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm file</span><br></pre></td></tr></table></figure><h1 id="6-分支与合并"><a href="#6-分支与合并" class="headerlink" title="6.分支与合并"></a>6.分支与合并</h1><p>分支在本地完成，速度快。要创建一个新的分支，我们使用branch命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></figure><p>branch命令不会将我们带入分支，只是创建一个新分支。所以我们使用checkout命令来更改分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p>第一个分支，或主分支，被称为”master”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>对其他分支的更改不会反映在主分支上。如果想将更改提交到主分支，则需切换回master分支，然后使用合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>如果您想删除分支，我们使用-d标识。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>来源：<a href="https://www.runoob.com/w3cnote/git-five-minutes-tutorial.html">Git 五分钟教程（菜鸟教程）</a></p><hr><p>完整版git教程！</p><h1 id="1-Git-创建仓库"><a href="#1-Git-创建仓库" class="headerlink" title="1. Git 创建仓库"></a>1. Git 创建仓库</h1><h2 id="1-1-git-init"><a href="#1-1-git-init" class="headerlink" title="1.1. git init"></a>1.1. git init</h2><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。</p><p>在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用当前目录作为 Git 仓库，我们只需使它初始化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为Git仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure><p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *.c</span><br><span class="line">git add README</span><br><span class="line">git commit -m &#x27;初始化项目版本&#x27;</span><br></pre></td></tr></table></figure><p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><blockquote><p><strong>注：</strong> 在 Linux 系统中，commit 信息使用单引号，Windows 系统，commit 信息使用双引号。</p></blockquote><h2 id="1-2-git-clone"><a href="#1-2-git-clone" class="headerlink" title="1.2. git clone"></a>1.2. git clone</h2><p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似 <strong>svn checkout</strong>）。</p><p>克隆仓库的命令格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>repo:</strong> Git 仓库。</li><li><strong>directory:</strong> 本地目录。</li></ul><p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h1><p>git 的设置使用 <strong>git config</strong> 命令。</p><p>显示当前的 git 配置信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>编辑 git 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -e    # 针对当前仓库 </span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -e --global   # 针对系统上所有仓库</span><br></pre></td></tr></table></figure><p>设置提交代码时的用户信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;chao&quot;</span><br><span class="line">git config --global user.email chao@10086.com</span><br></pre></td></tr></table></figure><p>如果去掉 <strong>–global</strong> 参数只对当前仓库有效。</p><hr><h1 id="3-Git-基本操作"><a href="#3-Git-基本操作" class="headerlink" title="3. Git 基本操作"></a>3. Git 基本操作</h1><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。</p><p>本章将对有关创建与提交你的项目快照的命令作介绍。</p><p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong>，后面我们会详细介绍。</p><p>一个简单的操作步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化仓库</span></span><br><span class="line">git init    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加文件到暂存区</span></span><br><span class="line">git add .   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将暂存区内容添加到仓库中</span></span><br><span class="line">git commit  </span><br></pre></td></tr></table></figure><h2 id="3-1-创建仓库命令"><a href="#3-1-创建仓库命令" class="headerlink" title="3.1. 创建仓库命令"></a>3.1. 创建仓库命令</h2><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><h2 id="3-2-提交与修改"><a href="#3-2-提交与修改" class="headerlink" title="3.2.  提交与修改"></a>3.2.  提交与修改</h2><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到暂存区</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><h2 id="3-3-提交日志"><a href="#3-3-提交日志" class="headerlink" title="3.3. 提交日志"></a>3.3. 提交日志</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h2 id="3-4-远程操作"><a href="#3-4-远程操作" class="headerlink" title="3.4. 远程操作"></a>3.4. 远程操作</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><hr><h1 id="4-Git-分支管理"><a href="#4-Git-分支管理" class="headerlink" title="4. Git 分支管理"></a>4. Git 分支管理</h1><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><p>有人把 Git 的分支模型称为<strong>必杀技特性</strong>，而正是因为它，将 <strong>Git</strong> 从版本控制系统家族里区分出来。</p><p>创建分支命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (branchname)</span><br></pre></td></tr></table></figure><p>切换分支命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>合并分支命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge </span><br></pre></td></tr></table></figure><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><p>开始前我们先创建一个测试目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> gitdemo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> gitdemo/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;第一次版本提交&#x27;</span></span></span><br><span class="line">[master (root-commit) 3b58100] 第一次版本提交</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><h2 id="4-1-列出分支"><a href="#4-1-列出分支" class="headerlink" title="4.1. 列出分支"></a>4.1. 列出分支</h2><p>列出分支基本命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p><p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p><p>如果我们要手动创建一个分支。执行 <strong>git branch (branchname)</strong> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch testing</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>现在我们可以看到，有了一个新分支 <strong>testing</strong>。</p><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 <strong>testing</strong> 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p><p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;runoob.com&#x27;</span> &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;add test.txt&#x27;</span></span></span><br><span class="line">[master 3e92c19] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout testing</span></span><br><span class="line">Switched to branch &#x27;testing&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README</span><br></pre></td></tr></table></figure><p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们有重新出现了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure><p>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b newtest</span></span><br><span class="line">Switched to a new branch &#x27;newtest&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> test.txt</span> </span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> runoob.php</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;removed test.txt、add runoob.php&#x27;</span></span></span><br><span class="line">[newtest c1501a2] removed test.txt、add runoob.php</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        runoob.php</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure><p>如你所见，我们创建了一个分支，在该分支上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p><p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p><h2 id="4-2-删除分支"><a href="#4-2-删除分支" class="headerlink" title="4.2. 删除分支"></a>4.2. 删除分支</h2><p>删除分支命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure><p>例如我们要删除 testing 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d testing</span></span><br><span class="line">Deleted branch testing (was 85fc7e7).</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h2 id="4-3-分支合并"><a href="#4-3-分支合并" class="headerlink" title="4.3. 分支合并"></a>4.3. 分支合并</h2><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br><span class="line">  newtest</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge newtest</span></span><br><span class="line">Updating 3e92c19..c1501a2</span><br><span class="line">Fast-forward</span><br><span class="line"> runoob.php | 0</span><br><span class="line"> test.txt   | 1 -</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        runoob.php</span><br></pre></td></tr></table></figure><p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p><p>合并完后就可以删除分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d newtest</span></span><br><span class="line">Deleted branch newtest (was c1501a2).</span><br></pre></td></tr></table></figure><p>删除后， 就只剩下 master 分支了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h2 id="4-4-合并冲突"><a href="#4-4-合并冲突" class="headerlink" title="4.4. 合并冲突"></a>4.4. 合并冲突</h2><p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php</span></span><br></pre></td></tr></table></figure><p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;runoob&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>创建 change_site 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b change_site</span></span><br><span class="line">Switched to a new branch &#x27;change_site&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim runoob.php</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -3 runoob.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;changed the runoob.php&#x27;</span></span></span><br><span class="line">[change_site 7774248] changed the runoob.php</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim runoob.php    <span class="comment"># 修改内容如下</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">echo 1;</span><br><span class="line">?&gt;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --git a/runoob.php b/runoob.php</span><br><span class="line">index e69de29..ac60739 100644</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+&lt;?php</span><br><span class="line">+echo 1;</span><br><span class="line">+?&gt;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;修改代码&#x27;</span></span></span><br><span class="line">[master c68142b] 修改代码</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><p>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge change_site</span></span><br><span class="line">Auto-merging runoob.php</span><br><span class="line">CONFLICT (content): Merge conflict in runoob.php</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php     <span class="comment"># 打开文件，看到冲突内容</span></span></span><br><span class="line">&lt;?php</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">echo 1;</span><br><span class="line">=======</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt; change_site</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim runoob.php</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">echo 1;</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --cc runoob.php</span><br><span class="line">index ac60739,b63d7d7..0000000</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@@ -1,3 -1,3 +1,4 @@@</span><br><span class="line">  &lt;?php</span><br><span class="line"> +echo 1;</span><br><span class="line">+ echo &#x27;runoob&#x27;;</span><br><span class="line">  ?&gt;</span><br></pre></td></tr></table></figure><p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line">UU runoob.php</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add runoob.php</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line">M  runoob.php</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line">[master 88afe0e] Merge branch &#x27;change_site&#x27;</span><br></pre></td></tr></table></figure><p>现在我们成功解决了合并中的冲突，并提交了结果。</p><hr><h1 id="5-Git-查看提交历史"><a href="#5-Git-查看提交历史" class="headerlink" title="5. Git 查看提交历史"></a>5. Git 查看提交历史</h1><p>Git 提交历史一般常用两个命令：</p><ul><li>git log - 查看历史提交记录。</li><li>git blame <file> - 以列表形式查看指定文件的历史修改记录。</li></ul><h2 id="5-1-git-log"><a href="#5-1-git-log" class="headerlink" title="5.1. git log"></a>5.1. git log</h2><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 <strong>git log</strong> 命令查看。</p><p>针对我们前一章节的操作，使用 <strong>git log</strong> 命令列出历史提交记录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)</span><br><span class="line">Merge: c68142b 7774248</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:55:58 2019 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;change_site&#x27;</span><br><span class="line"></span><br><span class="line">commit c68142b562c260c3071754623b08e2657b4c6d5b</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:52:12 2019 +0800</span><br><span class="line"></span><br><span class="line">    修改代码</span><br><span class="line"></span><br><span class="line">commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:49:26 2019 +0800</span><br><span class="line"></span><br><span class="line">    changed the runoob.php</span><br><span class="line"></span><br><span class="line">commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:35:32 2019 +0800</span><br></pre></td></tr></table></figure><p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline</span></span><br><span class="line">d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">c68142b 修改代码</span><br><span class="line">7774248 (change_site) changed the runoob.php</span><br><span class="line">c1501a2 removed test.txt、add runoob.php</span><br><span class="line">3e92c19 add test.txt</span><br><span class="line">3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*   d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p><p>你也可以用 –reverse 参数来逆向显示所有日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --reverse --oneline</span></span><br><span class="line">3b58100 第一次版本提交</span><br><span class="line">3e92c19 add test.txt</span><br><span class="line">c1501a2 removed test.txt、add runoob.php</span><br><span class="line">7774248 (change_site) changed the runoob.php</span><br><span class="line">c68142b 修改代码</span><br><span class="line">d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br></pre></td></tr></table></figure><p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --author=Linus --oneline -5</span></span><br><span class="line">81b50f3 Move &#x27;builtin-*&#x27; into a &#x27;builtin/&#x27; subdirectory</span><br><span class="line">3bb7256 make &quot;index-pack&quot; a built-in</span><br><span class="line">377d027 make &quot;git pack-redundant&quot; a built-in</span><br><span class="line">b532581 make &quot;git unpack-file&quot; a built-in</span><br><span class="line">112dd51 make &quot;mktag&quot; a built-in</span><br></pre></td></tr></table></figure><p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span></span><br><span class="line">5469e2d Git 1.7.1-rc2</span><br><span class="line">d43427d Documentation/remote-helpers: Fix typos and improve language</span><br><span class="line">272a36b Fixup: Second argument may be any arbitrary string</span><br><span class="line">b6c8d2d Documentation/remote-helpers: Add invocation section</span><br><span class="line">5ce4f4e Documentation/urls: Rewrite to accomodate transport::address</span><br><span class="line">00b84e9 Documentation/remote-helpers: Rewrite description</span><br><span class="line">03aa87e Documentation: Describe other situations where -z affects git diff</span><br><span class="line">77bc694 rebase-interactive: silence warning when no commits rewritten</span><br><span class="line">636db2c t3301: add tests to use --format=&quot;%N&quot;</span><br></pre></td></tr></table></figure><p>更多 git log 命令可查看：<a href="http://git-scm.com/docs/git-log">http://git-scm.com/docs/git-log</a></p><h2 id="5-2-git-blame"><a href="#5-2-git-blame" class="headerlink" title="5.2. git blame"></a>5.2. git blame</h2><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file&gt;</span><br></pre></td></tr></table></figure><p>git blame 命令是以列表形式显示修改记录，如下实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git blame README</span> </span><br><span class="line">^d2097aa (tianqixin 2020-08-25 14:59:25 +0800 1) # Runoob Git 测试</span><br><span class="line">db9315b0 (runoob    2020-08-25 16:00:23 +0800 2) # 菜鸟教程 </span><br></pre></td></tr></table></figure><hr><h1 id="6-Git-标签"><a href="#6-Git-标签" class="headerlink" title="6. Git 标签"></a>6. Git 标签</h1><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><p>比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p><p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 </span><br></pre></td></tr></table></figure><p>当你执行 <code>git tag -a</code> 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 <code>git log --decorate</code> 时，我们可以看到我们的标签了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*   eb90e77 (HEAD -&gt; master, tag: v1.0) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\</span><br><span class="line">| * 38d67fa (change_site) changed the runoob.php</span><br><span class="line">* | 1cfd03c 修改代码</span><br><span class="line">|/</span><br><span class="line">* f90cc49 removed test.txt, add runoob.php</span><br><span class="line">* 925f816 add test.txt</span><br><span class="line">* 0e57a65 &#x27;第2次版本提交&#x27;</span><br><span class="line">* ab55fdc &#x27;第一次版本提交&#x27;</span><br></pre></td></tr></table></figure><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p><p>例如，假设我们发布了提交 925f816，但是那时候忘了给它打标签。 我们现在也可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v0.9 925f816</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate --graph</span></span><br><span class="line">*   eb90e77 (HEAD -&gt; master, tag: v1.0) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\</span><br><span class="line">| * 38d67fa (change_site) changed the runoob.php</span><br><span class="line">* | 1cfd03c 修改代码</span><br><span class="line">|/</span><br><span class="line">* f90cc49 removed test.txt, add runoob.php</span><br><span class="line">* 925f816 (tag: v0.9) add test.txt</span><br><span class="line">* 0e57a65 &#x27;第2次版本提交&#x27;</span><br><span class="line">* ab55fdc &#x27;第一次版本提交&#x27;</span><br></pre></td></tr></table></figure><p>如果我们要查看所有标签可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>指定标签信息命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;</span><br></pre></td></tr></table></figure><p>PGP签名标签命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;</span><br></pre></td></tr></table></figure><hr><h1 id="7-Git-远程仓库-Github"><a href="#7-Git-远程仓库-Github" class="headerlink" title="7. Git 远程仓库(Github)"></a>7. Git 远程仓库(Github)</h1><p>Git 并不像 SVN 那样有个中心服务器。</p><p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p><p><a href="https://www.runoob.com/git/git-remote-repo.html">https://www.runoob.com/git/git-remote-repo.html</a></p><hr><h1 id="8-Git-Gitee"><a href="#8-Git-Gitee" class="headerlink" title="8. Git Gitee"></a>8. Git Gitee</h1><p>大家都知道国内访问 Github 速度比较慢，很影响我们的使用。</p><p>如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——<a href="https://gitee.com/?utm_source=remote_blog_cnjc">Gitee（gitee.com）</a>。</p><p>Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。</p><p>接下来我们学习一下如何使用 Gitee。</p><p>由于我们的本地 Git 仓库和 Gitee 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息。</p><p><strong>1、我们先在 <a href="https://gitee.com/?utm_source=remote_blog_cnjc">Gitee</a> 上注册账号并登录后，然后上传自己的 SSH 公钥。</strong></p><p>我们在 Git Github 章节已经生成了自己的 SSH 公钥，所以我们只需要将用户主目录下的 ~/.ssh/id_rsa.pub 文件的内容粘贴 Gitee 上。</p><p>选择右上角用户头像 -&gt; 设置，然后选择 “SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的 .ssh/id_rsa.pub 文件的内容粘贴进去：</p><h2 id="8-1-添加远程库"><a href="#8-1-添加远程库" class="headerlink" title="8.1. 添加远程库"></a>8.1. 添加远程库</h2><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如  提交到 Github</span></span><br><span class="line">git remote add origin git@github.com:tianqixin/runoob-git-test.git</span><br></pre></td></tr></table></figure><h3 id="8-1-1-git-pull-命令"><a href="#8-1-1-git-pull-命令" class="headerlink" title="8.1.1. git pull 命令"></a>8.1.1. git pull 命令</h3><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。 命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>更新操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git pull origin</span><br></pre></td></tr></table></figure><p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master:brantest</span><br></pre></td></tr></table></figure><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>上面命令表示，取回 origin/master 分支，再与本地的 brantest 分支合并。</p><p>以我的 <a href="https://github.com/tianqixin/runoob-git-test">https://github.com/tianqixin/runoob-git-test</a> 为例，远程载入合并本地分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v  <span class="comment"># 查看信息</span></span></span><br><span class="line">origin    https://github.com/tianqixin/runoob-git-test (fetch)</span><br><span class="line">origin    https://github.com/tianqixin/runoob-git-test (push)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull origin master</span></span><br><span class="line">From https://github.com/tianqixin/runoob-git-test</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Already up to date.</span><br></pre></td></tr></table></figure><p>上面命令表示，取回 origin/master 分支，再与本地的 master 分支合并。</p><hr><h3 id="8-1-2-git-push-命令"><a href="#8-1-2-git-push-命令" class="headerlink" title="8.1.2. git push 命令"></a>8.1.2. git push 命令</h3><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p><p>命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>以下命令将本地的 master 分支推送到 origin 主机的 master 分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>相等于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure><p>删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure><p>以我的 <a href="https://github.com/tianqixin/runoob-git-test">https://github.com/tianqixin/runoob-git-test</a> 为例，本地添加文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> runoob-test.txt      <span class="comment"># 添加文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add runoob-test.txt</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;添加到远程&quot;</span></span></span><br><span class="line">master 69e702d] 添加到远程</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 runoob-test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master    <span class="comment"># 推送到 Github</span></span></span><br></pre></td></tr></table></figure><p>将本地的 master 分支推送到 origin 主机的 master 分支。</p><p>重新回到我们的 Github 仓库，可以看到文件已经提交上来了。</p><h2 id="8-2-查看当前的远程库"><a href="#8-2-查看当前的远程库" class="headerlink" title="8.2. 查看当前的远程库"></a>8.2. 查看当前的远程库</h2><p>要查看当前配置有哪些远程仓库，可以用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如  执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br></pre></td></tr></table></figure><h2 id="8-3-提取远程仓库"><a href="#8-3-提取远程仓库" class="headerlink" title="8.3. 提取远程仓库"></a>8.3. 提取远程仓库</h2><p>Git 有两个命令用来提取远程仓库的更新。</p><p>1、从远程仓库下载新分支与数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p><p>2、从远端仓库提取数据并尝试合并到当前分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><p>该命令就是在执行 <strong>git fetch</strong> 之后紧接着执行 <strong>git merge</strong> 远程分支到你所在的任意分支。</p><p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 <strong>git fetch [alias]</strong> 告诉 Git 去获取它有你没有的数据，然后你可以执行 <strong>git merge [alias]/[branch]</strong> 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:tianqixin/runoob-git-test</span><br><span class="line">   0205aab..febd8ed  master     -&gt; origin/master</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge origin/master</span></span><br><span class="line">Updating 0205aab..febd8ed</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><hr><h2 id="8-4-推送到远程仓库"><a href="#8-4-推送到远程仓库" class="headerlink" title="8.4. 推送到远程仓库"></a>8.4. 推送到远程仓库</h2><p>推送你的新分支与数据到某个远端仓库命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [alias] [branch]</span><br></pre></td></tr></table></figure><p>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> runoob-test.txt      <span class="comment"># 添加文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add runoob-test.txt</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;添加到远程&quot;</span></span></span><br><span class="line">master 69e702d] 添加到远程</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 runoob-test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master    <span class="comment"># 推送到 Github</span></span></span><br></pre></td></tr></table></figure><p>重新回到我们的 Github 仓库，可以看到文件已经提交上来了：</p><h2 id="8-5-删除远程仓库"><a href="#8-5-删除远程仓库" class="headerlink" title="8.5. 删除远程仓库"></a>8.5. 删除远程仓库</h2><p>删除远程仓库你可以使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm [别名]</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加仓库 origin2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin2 git@github.com:tianqixin/runoob-git-test.git</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line">origin2    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin2    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除仓库 origin2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote <span class="built_in">rm</span> origin2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch学习笔记</title>
      <link href="/2022/01/22/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/22/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>开始使用Pytorch炼丹之旅了！！！</p><span id="more"></span><h2 id="1-模型固定"><a href="#1-模型固定" class="headerlink" title="1.模型固定"></a>1.模型固定</h2><h3 id="为什么使用相同的网络结构，跑出来的效果完全不同，用的学习率，迭代次数，batch-size-都是一样？"><a href="#为什么使用相同的网络结构，跑出来的效果完全不同，用的学习率，迭代次数，batch-size-都是一样？" class="headerlink" title="为什么使用相同的网络结构，跑出来的效果完全不同，用的学习率，迭代次数，batch size 都是一样？"></a>为什么使用相同的网络结构，跑出来的效果完全不同，用的学习率，迭代次数，batch size 都是一样？</h3><p><strong>固定随机数种子</strong>是非常重要的。但是如果你使用的是PyTorch等框架，还要看一下<strong>框架的种子是否固定了</strong>。还有，如果你用了cuda，别忘了cuda的随机数种子。这里还需要用到<code>torch.backends.cudnn.deterministic</code>.</p><p><code>torch.backends.cudnn.deterministic</code>是啥？顾名思义，将这个 flag 置为True的话，每次返回的卷积算法将是<strong>确定</strong>的，即默认算法。如果配合上设置 Torch 的随机种子为固定值的话，应该可以保证每次运行网络的时候相同输入的输出是固定的，代码大致这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_seeds</span>(<span class="params">seed=<span class="number">0</span></span>):</span><br><span class="line">    torch.manual_seed(seed) <span class="comment"># sets the seed for generating random numbers.</span></span><br><span class="line">    torch.cuda.manual_seed(seed) <span class="comment"># Sets the seed for generating random numbers for the current GPU. It’s safe to call this function if CUDA is not available; in that case, it is silently ignored.</span></span><br><span class="line">    torch.cuda.manual_seed_all(seed) <span class="comment"># Sets the seed for generating random numbers on all GPUs. It’s safe to call this function if CUDA is not available; in that case, it is silently ignored.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> seed == <span class="number">0</span>:</span><br><span class="line">        torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">        torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：</p><ol><li><p><a href="https://blog.csdn.net/weixin_41990278/article/details/106268969">【pytorch】torch.backends.cudnn.deterministic</a>（√）</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/73711222">torch.backends.cudnn.benchmark ?!</a>（更详细）</p></li></ol><hr><h2 id="2-PyTorch是如何求梯度的？"><a href="#2-PyTorch是如何求梯度的？" class="headerlink" title="2.PyTorch是如何求梯度的？"></a>2.PyTorch是如何求梯度的？</h2><p>参考：</p><ol><li><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/chapter02_prerequisite/2.3_autograd">动手学深度学习 2.3 自动求梯度</a></li><li><a href="https://zhuanlan.zhihu.com/p/29923090">PyTorch 的 backward 为什么有一个 grad_variables 参数？</a></li></ol><hr><h2 id="3-什么是线性回归？"><a href="#3-什么是线性回归？" class="headerlink" title="3.什么是线性回归？"></a>3.什么是线性回归？</h2><p><strong>线性回归</strong>输出是一个<strong>连续值</strong>，因此适用于回归问题。回归问题在实际中很常见，如预测房屋价格、气温、销售额等连续值的问题。</p><p>与回归问题不同，分类问题中模型的最终输出是一个<strong>离散值</strong>。我们所说的图像分类、垃圾邮件识别、疾病检测等输出为离散值的问题都属于分类问题的范畴。<strong>softmax回归</strong>则适用于分类问题。</p><p>由于线性回归和softmax回归都是<strong>单层神经网络</strong>，它们涉及的概念和技术同样适用于大多数的深度学习模型。</p><p>线性回归的基本要素：</p><ul><li><p>模型定义</p><p> 设房屋的面积为$x_{1}$，房龄为$x_{2}$，售出价格为$ y $，建立基于输入$x_{1}$和$x_{2}$来计算输出y的表达式，也就是模型（model）。<br> $$<br> \hat{y}=x_{1} w_{1}+x_{2} w_{2}+b<br> $$<br> 其中，$w_{1}$和$w_{2}$是<strong>权重</strong>（weight），$b$是<strong>偏差</strong>（bias），且均为标量。他们是线性回归模型的参数（parameter）。模型输出$\hat y$是线性回归对真实价格$y$的预测或估计。</p></li><li><p>模型训练</p><p> 通过数据来寻找特定的模型参数值，使模型在数据上的误差尽可能小。这个过程叫作<strong>模型训练</strong>（model training）。下面我们介绍模型训练所涉及的3个要素。</p><ul><li><p>训练数据</p><p>通常收集一系列的真实数据，例如多栋房屋的真实售出价格和它们对应的面积和房龄。我们希望在这个数据上面寻找模型参数来使模型的预测价格与真实价格的误差最小。</p><p>在机器学习术语里，该数据集被称为<strong>训练数据集</strong>（training data set）或<strong>训练集</strong>（training set），一栋房屋被称为一个<strong>样本</strong>（sample），其真实售出价格叫作<strong>标签</strong>（label），用来预测标签的两个因素叫作<strong>特征</strong>（feature）。特征用来表征样本的特点。</p><p>假设我们采集的样本数为$n$，索引为i的样本的特征为$x_{1}^{(i)}$和$x_{2}^{(i)}$，标签为$y^{(i)}$。对于索引为$i$的房屋，线性回归模型的房屋价格预测表达式为<br>$$<br>\hat{y}^{(i)}=x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b<br>$$</p></li><li><p>损失函数</p><p>在模型训练中，我们需要衡量价格预测值与真实值之间的<strong>误差</strong>。通常我们会选取一个<strong>非负数</strong>作为误差，且数值越小表示误差越小。一个常用的选择是平方函数。它在评估索引为$ i $的样本误差的表达式为<br>$$<br>\ell^{(i)}\left(w_{1}, w_{2}, b\right)=\frac{1}{2}\left(\hat{y}^{(i)}-y^{(i)}\right)^{2}<br>$$<br>其中常数$\frac{1}{2}$使对平方项求导后的常数系数为1，这样在形式上稍微简单一些。显然，误差越小表示预测价格与真实价格越相近，且当二者相等时误差为0。</p><p>给定训练数据集，这个误差只与模型参数相关，因此我们将它记为以模型参数为参数的函数。在机器学习里，将衡量误差的函数称为<strong>损失函数</strong>（loss function）。这里使用的平方误差函数也称为<strong>平方损失</strong>（square loss）。</p><p>通常，我们用训练数据集中所有样本误差的平均来衡量模型预测的质量，即<br>$$<br>\ell\left(w_{1}, w_{2}, b\right)=\frac{1}{n} \sum_{i=1}^{n} \ell^{(i)}\left(w_{1}, w_{2}, b\right)=\frac{1}{n} \sum_{i=1}^{n} \frac{1}{2}\left(x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}\right)^{2}<br>$$<br>在模型训练中，我们希望找出一组模型参数，记为$w_{1}^{*},w_{2}^{*}, b^{*}$，来使训练样本平均损失最小：<br>$$<br>w_{1}^{<em>}, w_{2}^{</em>}, b^{*}=\underset{w1,w2, b}{\arg \min } \ell\left({w}<em>{1},w</em>{2}, b\right)<br>$$</p></li><li><p>优化算法</p><p>当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫作<strong>解析解</strong>（analytical solution）。本节使用的线性回归和平方误差刚好属于这个范畴。然而，大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫作<strong>数值解</strong>（numerical solution）。</p><p>在求数值解的优化算法中，<strong>小批量随机梯度下降</strong>（mini-batch stochastic gradient descent）在深度学习中被广泛使用。它的算法很简单：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch）$\mathcal{B}$，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。</p><p>在训练本节讨论的线性回归模型的过程中，模型的每个参数将作如下迭代：<br>$$<br>\begin{aligned}<br>w_{1} &amp; \leftarrow w_{1}-\frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \frac{\partial \ell^{(i)}\left(w_{1}, w_{2}, b\right)}{\partial w_{1}}=w_{1}-\frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} x_{1}^{(i)}\left(x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}\right), \<br>w_{2} &amp; \leftarrow w_{2}-\frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \frac{\partial \ell^{(i)}\left(w_{1}, w_{2}, b\right)}{\partial w_{2}}=w_{2}-\frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} x_{2}^{(i)}\left(x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}\right), \<br>b &amp; \leftarrow b-\frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \frac{\partial \ell^{(i)}\left(w_{1}, w_{2}, b\right)}{\partial b}=b-\frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}\left(x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}\right) .<br>\end{aligned}<br>$$<br>在上式中，$|\mathcal{B}|$代表每个<strong>小批量中的样本个数</strong>（批量大小，batch size），$\eta$称作<strong>学习率</strong>（learning rate）并取正数。需要强调的是，这里的<strong>批量大小</strong>和<strong>学习率</strong>的值是人为设定的，并不是通过模型训练学出的，因此叫作<strong>超参数</strong>（hyperparameter）。我们通常所说的“调参”指的正是调节超参数，例如通过反复试错来找到超参数合适的值。在少数情况下，超参数也可以通过模型训练学出。</p></li></ul></li><li><p>模型预测</p><p>模型训练完成后，我们将模型参数$w_{1},w_{2},b$在优化算法停止时的值分别记作$\hat{w}_{1}, \hat{w}_{2}, \hat{b}$。注意，这里我们得到的并不一定是最小化损失函数的最优解$w_{1}^{*},w_{2}^{*}, b^{*}$,而是对最优解的一个近似。然后，我们就可以使用学出的线性回归模型$x_{1} \hat{w}_{1}+x_{2} \hat{w}_{2}+\hat{b}$来估算训练数据集以外任意一栋面积（平方米）为$x_{1}$、房龄（年）为$x_{2}$的房屋的价格了。这里的估算也叫作<strong>模型预测</strong>、<strong>模型推断</strong>或<strong>模型测试</strong>。</p></li></ul><p>线性回归的表示方法</p><ul><li><p>神经网络图</p><p>下图使用神经网络图表示刚刚介绍的线性回归模型。神经网络图隐去了模型参数权重和偏差。</p><img src="https://pic.imgdb.cn/item/6214ed972ab3f51d91a6f6a7.jpg" /><p>其中，输入层的输入个数为2，分别是$x_{1},x_{2}$。输入个数也叫特征数或特征向量维度。输出层的输出个数为1，对应于$o$。需要注意的是，我们直接将图3.1中神经网络的输出$o$作为线性回归的输出，即$\hat{y}=o$。由于输入层并不涉及计算，按照惯例，图3.1所示的神经网络的层数为1。所以，线性回归是一个单层神经网络。输出层中负责计算$o$的单元又叫神经元。在线性回归中，$o$的计算依赖于$x_{1},x_{2}$。也就是说，输出层中的神经元和输入层中各个输入完全连接。因此，这里的输出层又叫<strong>全连接层</strong>（fully-connected layer）或<strong>稠密层</strong>（dense layer）。</p></li><li><p>矢量计算表达式</p><p>在模型训练或预测时，常常会同时处理多个数据样本并用到矢量计算。</p><img src="https://pic.imgdb.cn/item/6214edcc2ab3f51d91a79053.jpg" /><p>结果很明显，后者比前者更省时。因此，我们应该尽可能采用<strong>矢量计算</strong>，以提升计算效率。</p></li></ul><p>再回到房价预测问题。如果对训练数据集里的3个房屋样本（索引分别为1、2和3）逐一预测价格，将得到<br>$$<br>\begin{array}{l}<br>\hat{y}^{(1)}=x_{1}^{(1)} w_{1}+x_{2}^{(1)} w_{2}+b \<br>\hat{y}^{(2)}=x_{1}^{(2)} w_{1}+x_{2}^{(2)} w_{2}+b \<br>\hat{y}^{(3)}=x_{1}^{(3)} w_{1}+x_{2}^{(3)} w_{2}+b<br>\end{array}<br>$$<br>现在，我们将上面3个等式转化成矢量计算。设<br>$$<br>\hat{\boldsymbol{y}}=\left[\begin{array}{c}<br>\hat{y}^{(1)} \<br>\hat{y}^{(2)} \<br>\hat{y}^{(3)}<br>\end{array}\right], \quad \boldsymbol{X}=\left[\begin{array}{cc}<br>x_{1}^{(1)} &amp; x_{2}^{(1)} \<br>x_{1}^{(2)} &amp; x_{2}^{(2)} \<br>x_{1}^{(3)} &amp; x_{2}^{(3)}<br>\end{array}\right], \quad \boldsymbol{w}=\left[\begin{array}{c}<br>w_{1} \<br>w_{2}<br>\end{array}\right]<br>$$<br>对3个房屋样本预测价格的矢量计算表达式为<br>$$<br>\hat{\boldsymbol{y}}=\boldsymbol{X} \boldsymbol{w} + b<br>$$<br>其中的加法运算使用了广播机制。<br>$$<br>\ell(\boldsymbol{\theta})=\frac{1}{2 n}(\hat{\boldsymbol{y}}-\boldsymbol{y})^{\top}(\hat{\boldsymbol{y}}-\boldsymbol{y})<br>$$</p><p>$$<br>\nabla_{\boldsymbol{\theta}} \ell^{(i)}(\boldsymbol{\theta})=\left[\begin{array}{c}<br>\frac{\partial \ell^{(i)}\left(w_{1}, w_{2}, b\right)}{\partial \ell^{(i)}\left(w_{1}, w_{2}, b\right)} \<br>\frac{\partial_{1}, w_{2}}{\partial \ell^{(i)}\left(w_{1}, w 2, b\right)}<br>\end{array}\right]=\left[\begin{array}{c}<br>x_{1}^{(i)}\left(x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}\right) \<br>x_{2}^{(i)}\left(x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}\right) \<br>x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}<br>\end{array}\right]=\left[\begin{array}{c}<br>x_{1}^{(i)} \<br>x_{2}^{(i)} \<br>1<br>\end{array}\right]\left(\hat{y}^{(i)}-y^{(i)}\right)<br>$$</p><hr><h2 id="4-softmax回归"><a href="#4-softmax回归" class="headerlink" title="4.softmax回归"></a>4.softmax回归</h2><p>前面介绍的线性回归模型适用于输出为连续值的情景。在另一类情景中，模型输出可以是一个像图像类别这样的<strong>离散值</strong>。对于这样的离散值预测问题，我们可以使用诸如<strong>softmax回归</strong>在内的分类模型。和线性回归不同，softmax回归的输出单元从一个变成了多个，且引入了softmax运算使输出更适合离散值的预测和训练。</p><p>分类问题</p><p>让我们考虑一个简单的图像分类问题，其输入图像的高和宽均为2像素，且色彩为灰度。这样每个像素值都可以用一个标量表示。我们将图像中的4像素分别记为$x_{1},x_{2},x_{3},x_{4}$。假设训练数据集中图像的真实标签为狗、猫或鸡（假设可以用4像素表示出这3种动物），这些标签分别对应离散值$y_{1},y_{2},y_{3}$。</p><p>softmax回归模型</p><p>softmax回归跟线性回归一样将输入特征与权重做线性叠加。与线性回归的一个主要不同在于，softmax回归的输出值个数等于标签里的类别数。因为一共有4种特征和3种输出动物类别，所以权重包含12个标量（带下标的$w$）、偏差包含3个标量（带下标的b），且对每个输入计算$o_{1},o_{2},o_{3}$这三个输出：<br>$$<br>\begin{array}{}<br>o_{1}=x_{1} w_{11}+x_{2} w_{21}+x_{3} w_{31}+x_{4} w_{41}+b_{1} \<br>o_{2}=x_{1} w_{12}+x_{2} w_{22}+x_{3} w_{32}+x_{4} w_{42}+b_{2} \<br>o_{3}=x_{1} w_{13}+x_{2} w_{23}+x_{3} w_{33}+x_{4} w_{43}+b_{3}<br>\end{array}<br>$$<br>下图用神经网络图描绘了上面的计算。softmax回归同线性回归一样，也是一个单层神经网络。由于每个输出$o_{1},o_{2},o_{3}$的计算都要依赖于所有的输入$x_{1},x_{2},x_{3},x_{4}$，softmax回归的输出层也是一个全连接层。</p><img src="https://pic.imgdb.cn/item/6214eded2ab3f51d91a7f028.jpg" /><p>既然分类问题需要得到离散的预测输出，一个简单的办法是将输出值$o_{i}$当作预测类别是$i$的置信度，并将值最大的输出所对应的类作为预测输出，即输出$\arg \max _{i} o_{i}$。例如，如果$o_{1},o_{2},o_{3}$分别为0.1,10,0.1，由于$o_{2}$最大，那么预测类别为2，其代表猫。</p><hr><h2 id="5-多层感知机"><a href="#5-多层感知机" class="headerlink" title="5.多层感知机"></a>5.多层感知机</h2><p>多层感知机（multilayer perceptron，MLP）为例，介绍多层神经网络的概念。</p><p>隐藏层</p><p>多层感知机在单层神经网络的基础上引入了一到多个隐藏层（hidden layer）。隐藏层位于输入层和输出层之间。下图展示了一个多层感知机的神经网络图，它含有一个隐藏层，该层中有5个隐藏单元。</p><img src="https://pic.imgdb.cn/item/6214ee3a2ab3f51d91a8c607.jpg" /><p>在上图的多层感知机中，输入和输出个数分别为4和3，中间的隐藏层中包含了5个隐藏单元（hidden unit）。由于输入层不涉及计算，多层感知机的层数为2。隐藏层中的神经元和输入层中各个输入完全连接，输出层中的神经元和隐藏层中的各个神经元也完全连接。因此，多层感知机中的隐藏层和输出层都是全连接层。<br>$$<br>\begin{aligned}<br>\boldsymbol{H} &amp;=\boldsymbol{X} \boldsymbol{W}<em>{h}+\boldsymbol{b}</em>{h} \<br>\boldsymbol{O} &amp;=\boldsymbol{H} \boldsymbol{W}<em>{o}+\boldsymbol{b}</em>{o}<br>\end{aligned}<br>$$</p><p>$$<br>\boldsymbol{O}=\left(\boldsymbol{X} \boldsymbol{W}<em>{h}+\boldsymbol{b}</em>{h}\right) \boldsymbol{W}<em>{o}+\boldsymbol{b}</em>{o}=\boldsymbol{X} \boldsymbol{W}<em>{h} \boldsymbol{W}</em>{o}+\boldsymbol{b}<em>{h} \boldsymbol{W}</em>{o}+\boldsymbol{b}_{o}<br>$$</p><p>$$<br>\operatorname{ReLU}(x)=\max (x, 0)<br>$$</p><p>$$<br>\operatorname{sigmoid}(x)=\frac{1}{1+\exp (-x)}<br>$$</p><p>$$<br>\operatorname{sigmoid}^{\prime}(x)=\operatorname{sigmoid}(x)(1-\operatorname{sigmoid}(x)) \text {. }<br>$$</p><p>$$<br>\tanh (x)=\frac{1-\exp (-2 x)}{1+\exp (-2 x)}<br>$$</p><p>$$<br>\tanh ^{\prime}(x)=1-\tanh ^{2}(x)<br>$$</p><p>$$<br>\begin{aligned}<br>\boldsymbol{H} &amp;=\phi\left(\boldsymbol{X} \boldsymbol{W}<em>{h}+\boldsymbol{b}</em>{h}\right), \<br>\boldsymbol{O} &amp;=\boldsymbol{H} \boldsymbol{W}<em>{o}+\boldsymbol{b}</em>{o},<br>\end{aligned}<br>$$</p><hr><h2 id="6-模型选择、欠拟合和过拟合"><a href="#6-模型选择、欠拟合和过拟合" class="headerlink" title="6.模型选择、欠拟合和过拟合"></a>6.模型选择、欠拟合和过拟合</h2><p>在实验中，我们评价了机器学习模型在训练数据集和测试数据集上的表现。如果改变过实验中的模型结构或者超参数，也许发现了：当模型在训练数据集上更准确时，它在测试数据集上却不一定更准确。这是为什么呢？</p><p>训练误差和泛化误差</p><p><strong>训练误差</strong>（training error）指模型在训练数据集上表现出的误差，<strong>泛化误差</strong>（generalization error）指模型在任意一个测试数据样本上表现出的误差的期望，并常常通过测试数据集上的误差来近似。计算训练误差和泛化误差可以使用之前介绍过的损失函数，例如线性回归用到的平方损失函数和softmax回归用到的交叉熵损失函数。</p><p>在机器学习里，我们通常假设训练数据集（训练题）和测试数据集（测试题）里的每一个样本都是从同一个概率分布中相互独立地生成的。基于该独立同分布假设，给定任意一个机器学习模型（含参数），它的训练误差的期望和泛化误差都是一样的。例如，如果我们将模型参数设成随机值，那么训练误差和泛化误差会非常相近。训练后，训练误差的期望小于或等于泛化误差。也就是说，一般情况下，由训练数据集学到的模型参数会使模型在训练数据集上的表现优于或等于在测试数据集上的表现。由于无法从训练误差估计泛化误差，一味地降低训练误差并不意味着泛化误差一定会降低。</p><p>机器学习模型应关注<strong>降低泛化误差</strong>。</p><p>模型选择</p><p>在机器学习中，通常需要评估若干候选模型的表现并从中选择模型。这一过程称为<strong>模型选择</strong>（model selection）。可供选择的候选模型可以是有着不同超参数的同类模型。以多层感知机为例，我们可以选择隐藏层的个数，以及每个隐藏层中隐藏单元个数和激活函数。为了得到有效的模型，我们通常要在模型选择上下一番功夫。下面，我们来描述模型选择中经常使用的<strong>验证数据集</strong>（validation data set）。</p><p>验证数据集</p><p>从严格意义上讲，测试集只能在所有超参数和模型参数选定后使用一次。不可以使用测试数据选择模型，如调参。由于无法从训练误差估计泛化误差，因此也不应只依赖训练数据选择模型。鉴于此，我们可以预留一部分在训练数据集和测试数据集以外的数据来进行模型选择。这部分数据被称为<strong>验证数据集</strong>，简称<strong>验证集</strong>（validation set）。例如，我们可以从给定的训练集中随机选取一小部分作为验证集，而将剩余部分作为真正的训练集。</p><p>然而在实际应用中，由于数据不容易获取，测试数据极少只使用一次就丢弃。因此，实践中验证数据集和测试数据集的界限可能比较模糊。从严格意义上讲，除非明确说明，否则本书中实验所使用的测试集应为验证集，实验报告的测试结果（如测试准确率）应为验证结果（如验证准确率）。</p><p>$K$折交叉验证</p><p>由于验证数据集不参与模型训练，当训练数据不够用时，预留大量的验证数据显得太奢侈。一种改善的方法是$K$折交叉验证（$K$-fold cross-validation）。在$K$折交叉验证中，我们把原始训练数据集分割成$K$个不重合的子数据集，然后我们做$K$次模型训练和验证。每一次，我们使用一个子数据集验证模型，并使用其他$K−1$个子数据集来训练模型。在这$K$次训练和验证中，每次用来验证模型的子数据集都不同。最后，我们对这$K$次训练误差和验证误差分别求平均。</p><p>欠拟合和过拟合</p><p>接下来，将探究模型训练中经常出现的两类典型问题：一类是模型无法得到较低的训练误差，我们将这一现象称作<strong>欠拟合</strong>（underfitting）；另一类是模型的训练误差远小于它在测试数据集上的误差，我们称该现象为<strong>过拟合</strong>（overfitting）。在实践中，我们要尽可能同时应对欠拟合和过拟合。虽然有很多因素可能导致这两种拟合问题，在这里我们重点讨论两个因素：模型复杂度和训练数据集大小。</p><blockquote><p>关于模型复杂度和训练集大小对学习的影响的详细理论分析可参见 <a href="https://tangshusen.me/2018/12/09/vc-dimension/">博客</a></p></blockquote><p>模型复杂度</p><p>为了解释模型复杂度，我们以多项式函数拟合为例。给定一个由标量数据特征$x$和对应的标量标签$y$组成的训练数据集，多项式函数拟合的目标是找一个$K$阶多项式函数<br>$$<br>\hat{y}=b+\sum_{k=1}^{K} x^{k} w_{k}<br>$$<br>来近似 $y$。在上式中，$w_{k}$是模型的权重参数，$b$是偏差参数。与线性回归相同，多项式函数拟合也使用平方损失函数。特别地，一阶多项式函数拟合又叫线性函数拟合。</p><p>因为高阶多项式函数模型参数更多，模型函数的选择空间更大，所以高阶多项式函数比低阶多项式函数的复杂度更高。因此，高阶多项式函数比低阶多项式函数更容易在相同的训练数据集上得到更低的训练误差。给定训练数据集，模型复杂度和误差之间的关系通常下图所示。给定训练数据集，如果模型的复杂度过低，很容易出现欠拟合；如果模型复杂度过高，很容易出现过拟合。应对欠拟合和过拟合的一个办法是针对数据集选择合适复杂度的模型。</p><p><img src="https://pic.imgdb.cn/item/6214ee522ab3f51d91a909bf.jpg" alt="image-20220127101745940"></p><p>训练数据集大小</p><p>影响欠拟合和过拟合的另一个重要因素是训练数据集的大小。一般来说，如果训练数据集中样本数过少，特别是比模型参数数量（按元素计）更少时，过拟合更容易发生。此外，泛化误差不会随训练数据集里样本数量增加而增大。因此，在计算资源允许的范围之内，我们通常希望训练数据集大一些，特别是在模型复杂度较高时，例如层数较多的深度学习模型。</p><p>总结</p><ul><li>由于无法从训练误差估计泛化误差，一味地降低训练误差并不意味着泛化误差一定会降低。机器学习模型应关注降低泛化误差。</li><li>可以使用验证数据集来进行模型选择。</li><li>欠拟合指模型无法得到较低的训练误差，过拟合指模型的训练误差远小于它在测试数据集上的误差。</li><li>应选择复杂度合适的模型并避免使用过少的训练样本。</li></ul><hr><h2 id="7-权重衰减"><a href="#7-权重衰减" class="headerlink" title="7.权重衰减"></a>7.权重衰减</h2><p>过拟合现象，即模型的训练误差远小于它在测试集上的误差。虽然增大训练数据集可能会减轻过拟合，但是获取额外的训练数据往往代价高昂。应对过拟合问题的常用方法：<strong>权重衰减</strong>（weight decay）。</p><p>方法</p><p>权重衰减等价于$L2$范数正则化（regularization）。正则化通过为模型损失函数添加<strong>惩罚项</strong>使学出的模型参数值较小，是应对过拟合的常用手段。我们先描述$L2$范数正则化，再解释它为何又称权重衰减。$L2$范数正则化在模型原损失函数基础上添加$L2$ 范数惩罚项，从而得到训练所需要最小化的函数。$L2$范数惩罚项指的是模型权重参数每个元素的平方和与一个正的常数的乘积。以3.1节（线性回归）中的线性回归损失函数<br>$$<br>\ell\left(w_{1}, w_{2}, b\right)=\frac{1}{n} \sum_{i=1}^{n} \frac{1}{2}\left(x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}\right)^{2}<br>$$<br>为例，其中$w_{1},w_{2}$是权重参数，$b$是偏差参数，样本$i$的输入为$x_{1}^{(i)},x_{2}^{(i)}$，标签为$y^{(i)}$，样本数为$n$。将权重参数用向量$\boldsymbol{w}=\left[w_{1}, w_{2}\right]$表示，带有$L2$范数惩罚项的新损失函数为<br>$$<br>\ell\left(w_{1}, w_{2}, b\right)+\frac{\lambda}{2 n}|\boldsymbol{w}|^{2}<br>$$<br>其中超参数$\lambda &gt;0$。当权重参数均为0时，惩罚项最小。当$\lambda $较大时，惩罚项在损失函数中的比重较大，这通常会使学到的权重参数的元素较接近0。当$\lambda $设为0时，惩罚项完全不起作用。上式中$L2$范数平方$ |\boldsymbol{w}|^{2}$ 展开后得到$w_{1}^2+w_{2}^2$ 。有了$L2$ 范数惩罚项后，在小批量随机梯度下降中，我们将线性回归一节中权重$w_{1}$和$w_{2}$的迭代方式更改为<br>$$<br>\begin{array}{l}<br>w_{1} \leftarrow\left(1-\frac{\eta \lambda}{|\mathcal{B}|}\right) w_{1}-\frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} x_{1}^{(i)}\left(x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}\right) \<br>w_{2} \leftarrow\left(1-\frac{\eta \lambda}{|\mathcal{B}|}\right) w_{2}-\frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} x_{2}^{(i)}\left(x_{1}^{(i)} w_{1}+x_{2}^{(i)} w_{2}+b-y^{(i)}\right) .<br>\end{array}<br>$$<br>可见，$L2$范数正则化令权重$w_{1}$和$w_{2}$先自乘小于1的数，再减去不含惩罚项的梯度。因此，$L2$范数正则化又叫权重衰减。权重衰减通过惩罚绝对值较大的模型参数为需要学习的模型增加了限制，这可能对过拟合有效。实际场景中，我们有时也在惩罚项中添加偏差元素的平方和。</p><p>总结</p><ul><li>正则化通过为模型损失函数添加惩罚项使学出的模型参数值较小，是应对过拟合的常用手段。</li><li>权重衰减等价于$L2$范数正则化，通常会使学到的权重参数的元素较接近0。</li><li>权重衰减可以通过优化器中的weight_decay超参数来指定。</li><li>可以定义多个优化器实例对不同的模型参数使用不同的迭代方法。</li></ul><hr><h2 id="8-丢弃法"><a href="#8-丢弃法" class="headerlink" title="8.丢弃法"></a>8.丢弃法</h2><p>除了权重衰减以外，深度学习模型常常使用<strong>丢弃法</strong>（dropout）来应对过拟合问题。丢弃法有一些不同的变体。下面提到的丢弃法特指倒置丢弃法（inverted dropout）。</p><p>方法</p><p>多层感知机部分描述了一个单隐藏层的多层感知机。其中输入个数为4，隐藏单元个数为5，且隐藏单元$h_{i}(i=1,…,5)$的计算表达式为<br>$$<br>h_{i}=\phi\left(x_{1} w_{1 i}+x_{2} w_{2 i}+x_{3} w_{3 i}+x_{4} w_{4 i}+b_{i}\right)<br>$$<br>这里$\phi$是激活函数，$x_{1},…,x_{4}$是输入，隐藏单元$i$的权重参数为$w_{1i},…,w_{4i}$ ，偏差参数为$b_{i}$。当对该隐藏层使用丢弃法时，该层的隐藏单元将有一定概率被丢弃掉。设丢弃概率为$p$，那么有$p$的概率$h_{i}$会被清零，有$1−p$的概率$h_{i}$会除以$1−p$做拉伸。<strong>丢弃概率</strong>是丢弃法的超参数。具体来说，设随机变量$\xi_{i}$为0和1的概率分别为$p$和$1−p$。使用丢弃法时我们计算新的隐藏单元$h_{i}’$<br>$$<br>h_{i}^{\prime}=\frac{\xi_{i}}{1-p} h_{i}<br>$$<br>由于$E(\xi_{i})=1-p$，因此<br>$$<br>E\left(h_{i}^{\prime}\right)=\frac{E\left(\xi_{i}\right)}{1-p} h_{i}=h_{i}<br>$$<br>即<strong>丢弃法不改变其输入的期望值</strong>。让我们对图3.3中的隐藏层使用丢弃法，一种可能的结果下图所示，其中$h_{2}$和$h_{5}$被清零。这时输出值的计算不再依赖$h_{2}$和$h_{5}$ ，在反向传播时，与这两个隐藏单元相关的权重的梯度均为0。由于在训练中隐藏层神经元的丢弃是随机的，即$h_{1},…,h_{5}$都有可能被清零，输出层的计算无法过度依赖$h_{1},…,h_{5}$中的任一个，从而在训练模型时起到正则化的作用，并可以用来应对过拟合。在测试模型时，我们为了拿到更加确定性的结果，一般不使用丢弃法。</p><p><img src="https://pic.imgdb.cn/item/6214ee7b2ab3f51d91a97976.jpg" alt="image-20220127151421778"></p><p>总结</p><ul><li>可以通过使用丢弃法应对过拟合。</li><li>丢弃法只在训练模型时使用。</li></ul><hr><h2 id="9-正向传播、反向传播和计算图"><a href="#9-正向传播、反向传播和计算图" class="headerlink" title="9.正向传播、反向传播和计算图"></a>9.正向传播、反向传播和计算图</h2><p>在小批量随机梯度下降的优化算法来训练模型的实现中，我们只提供了模型的<strong>正向传播</strong>（forward propagation）的计算，即对输入计算模型输出，然后通过autograd模块来调用系统自动生成的backward函数计算梯度。基于<strong>反向传播</strong>（back-propagation）算法的自动求梯度极大简化了深度学习模型训练算法的实现。本节我们将使用数学和计算图（computational graph）两个方式来描述正向传播和反向传播。具体来说，我们将以带$L2$范数正则化的含单隐藏层的多层感知机为样例模型解释正向传播和反向传播。</p><p>正向传播</p><p>正向传播是指对神经网络沿着从输入层到输出层的顺序，依次计算并存储模型的中间变量（包括输出）。为简单起见，假设输入是一个特征为$x\in \Bbb R ^d $的样本，且不考虑偏差项，那么中间变量<br>$$<br>\boldsymbol{z}=\boldsymbol{W}^{(1)} \boldsymbol{x}<br>$$<br>其中$\boldsymbol{W}^{(1)} \in \Bbb R^{h\times d}$是隐藏层的权重参数。把中间变量$\boldsymbol{z} \in \Bbb R^{h}$输入按元素运算的激活函数$\phi$后，将得到向量长度为$h$的隐藏层变量<br>$$<br>\boldsymbol{h} = \phi(\boldsymbol{z})<br>$$<br>隐藏层变量$h$也是一个中间变量。假设输出层参数只有权重$\boldsymbol{W}^{(2)} \in \Bbb R^{q\times h}$，可以得到向量长度为$q$的输出层变量<br>$$<br>\boldsymbol{o}=\boldsymbol{W}^{(2)} \boldsymbol{h}<br>$$<br>假设损失函数为$\ell$，且样本标签为$y$，可以计算出单个数据样本的损失项<br>$$<br>L=\ell(\boldsymbol o, y)<br>$$<br>根据$L2$范数正则化的定义，给定超参数$\lambda $，正则化项即<br>$$<br>\boldsymbol{s}=\frac{\lambda}{2}\left(\left|\boldsymbol{W}^{(1)}\right|<em>{F}^{2}+\left|\boldsymbol{W}^{(2)}\right|</em>{F}^{2}\right)<br>$$<br>其中矩阵的Frobenius范数等价于将矩阵变平为向量后计算$L2$范数。最终，模型在给定的数据样本上带正则化的损失为<br>$$<br>J=L+ s<br>$$<br>正向传播的计算图</p><p>通常绘制计算图来可视化运算符和变量在计算中的依赖关系。下图绘制了样例模型正向传播的计算图，其中左下角是输入，右上角是输出。可以看到，图中箭头方向大多是向右和向上，其中方框代表变量，圆圈代表运算符，箭头表示从输入到输出之间的依赖关系。</p><p><img src="https://pic.imgdb.cn/item/6214ee942ab3f51d91a9c366.jpg" alt="image-20220129111529450"></p><p>反向传播</p><p>反向传播指的是<strong>计算神经网络参数梯度</strong>的方法。总的来说，反向传播依据微积分中的<strong>链式法则</strong>，沿着从<strong>输出层到输入层</strong>的顺序，依次计算并存储目标函数有关神经网络各层的中间变量以及参数的梯度。对输入或输出$X,Y,Z$为任意形状张量的函数$Y=f(X)$和$Z=g(Y)$，通过链式法则，我们有<br>$$<br>\frac{\partial Z}{\partial X}=\operatorname{prod}\left(\frac{\partial Z}{\partial Y}, \frac{\partial Y}{\partial X}\right)<br>$$<br>其中$prod$运算符将根据两个输入的形状，在必要的操作（如转置和互换输入位置）后对两个输入做乘法。</p><p>回顾一下样例模型，它的参数是$\boldsymbol{W}^{(1)}$和$\boldsymbol{W}^{(2)}$，因此反向传播的目标是计算$\frac{\partial J}{\partial \boldsymbol{W}^{(1)}} $和$\frac{\partial J}{\partial \boldsymbol{W}^{(2)}} $ 。我们将应用链式法则依次计算各中间变量和参数的梯度，其计算次序与前向传播中相应中间变量的计算次序恰恰相反。首先，分别计算目标函数$J=L+s$有关损失项$L$和正则项$s$的梯度<br>$$<br>\frac{\partial J}{\partial L}=1, \quad \frac{\partial J}{\partial s}=1<br>$$<br>其次，依据链式法则计算目标函数有关输出层变量的梯度$\frac{\partial J}{\partial o}\in \Bbb R^{q}$:<br>$$<br>\frac{\partial J}{\partial o}=\operatorname{prod}\left(\frac{\partial J}{\partial L}, \frac{\partial L}{\partial o}\right)=\frac{\partial L}{\partial o}<br>$$<br>接下来，计算正则项有关两个参数的梯度：<br>$$<br>\frac{\partial s}{\partial \boldsymbol{W}^{(1)}}=\lambda \boldsymbol{W}^{(1)}, \quad \frac{\partial s}{\partial \boldsymbol{W}^{(2)}}=\lambda \boldsymbol{W}^{(2)}<br>$$<br>现在，我们可以计算最靠近输出层的模型参数的梯度$\frac{\partial J}{\partial \boldsymbol{W}^{(2)}} \in \Bbb R^{q \times h}$<br>$$<br>\frac{\partial J}{\partial W^{(2)}}=\operatorname{prod}\left(\frac{\partial J}{\partial o}, \frac{\partial o}{\partial W^{(2)}}\right)+\operatorname{prod}\left(\frac{\partial J}{\partial s}, \frac{\partial s}{\partial W^{(2)}}\right)=\frac{\partial J}{\partial o} \boldsymbol{h}^{\top}+\lambda \boldsymbol{W}^{(2)}<br>$$<br>沿着输出层向隐藏层继续反向传播，隐藏层变量的梯度$\frac{\partial J}{\partial \boldsymbol{h}} \in \Bbb R^{h}$:<br>$$<br>\frac{\partial J}{\partial \boldsymbol{h}}=\operatorname{prod}\left(\frac{\partial J}{\partial \boldsymbol{o}}, \frac{\partial \boldsymbol{o}}{\partial \boldsymbol{h}}\right)=\boldsymbol{W}^{(2)^\top} \frac{\partial J}{\partial \boldsymbol{o}}<br>$$<br>由于激活函数$\phi$是按元素运算的，中间变量$z$的梯度$\frac{\partial J}{\partial \boldsymbol{z}} \in \Bbb R^{h}$计算需要使用按元素乘法符$\odot$：<br>$$<br>\frac{\partial J}{\partial z}=\operatorname{prod}\left(\frac{\partial J}{\partial h}, \frac{\partial h}{\partial z}\right)=\frac{\partial J}{\partial h} \odot \phi^{\prime}(z)<br>$$<br>最终，我们可以得到最靠近输入层的模型参数的梯度$\frac{\partial J}{\partial \boldsymbol{W}^{(1)}} \in \Bbb R^{h\times d}$。依据链式法则，得到<br>$$<br>\frac{\partial J}{\partial W^{(1)}}=\operatorname{prod}\left(\frac{\partial J}{\partial z}, \frac{\partial z}{\partial W^{(1)}}\right)+\operatorname{prod}\left(\frac{\partial J}{\partial s}, \frac{\partial s}{\partial W^{(1)}}\right)=\frac{\partial J}{\partial z} \boldsymbol{x}^{\top}+\lambda \boldsymbol{W}^{(1)}<br>$$<br>训练深度学习模型</p><p>在训练深度学习模型时，正向传播和反向传播之间相互依赖。下面以样例模型分别阐述它们之间的依赖关系。</p><p>一方面，正向传播的计算可能依赖于模型参数的当前值，而这些模型参数是在反向传播的梯度计算后通过优化算法迭代的。例如，计算正则化项$\boldsymbol{s}=\frac{\lambda}{2}\left(\left|\boldsymbol{W}^{(1)}\right|_{F}^{2}+\left|\boldsymbol{W}^{(2)}\right|_{F}^{2}\right)$依赖模型参数$\boldsymbol{W}^{(1)}$和$\boldsymbol{W}^{(2)}$的当前值，而这些当前值是优化算法最近一次根据反向传播算出梯度后迭代得到的。</p><p>另一方面，反向传播的梯度计算可能依赖于各变量的当前值，而这些变量的当前值是通过正向传播计算得到的。举例来说，参数梯度$\frac{\partial J}{\partial \boldsymbol{W}^{(2)}}=\frac{\partial J}{\partial o} \boldsymbol{h}^{\top}+\lambda \boldsymbol{W}^{(2)}$的计算需要依赖隐藏层变量的当前值$h$。这个当前值是通过从输入层到输出层的正向传播计算并存储得到的。</p><p>因此，在模型参数初始化完成后，我们交替地进行正向传播和反向传播，并根据反向传播计算的梯度迭代模型参数。既然我们在反向传播中使用了正向传播中计算得到的中间变量来避免重复计算，那么这个复用也导致正向传播结束后不能立即释放中间变量内存。这也是训练要比预测占用更多内存的一个重要原因。另外需要指出的是，这些中间变量的个数大体上与网络层数线性相关，每个变量的大小跟批量大小和输入个数也是线性相关的，它们是导致较深的神经网络使用较大批量训练时更容易超内存的主要原因。</p><p>总结：</p><ul><li>正向传播沿着从输入层到输出层的顺序，依次计算并存储神经网络的中间变量。</li><li>反向传播沿着从输出层到输入层的顺序，依次计算并存储神经网络中间变量和参数的梯度。</li><li>在训练深度学习模型时，正向传播和反向传播相互依赖。</li></ul><hr><h2 id="10-数值稳定性和模型初始化"><a href="#10-数值稳定性和模型初始化" class="headerlink" title="10.数值稳定性和模型初始化"></a>10.数值稳定性和模型初始化</h2><p>理解了正向传播与反向传播以后，来讨论一下深度学习模型的数值稳定性问题以及模型参数的初始化方法。深度模型有关数值稳定性的典型问题是<strong>衰减</strong>（vanishing）和<strong>爆炸</strong>（explosion）。</p><p>衰减和爆炸</p><p>当神经网络的层数较多时，模型的数值稳定性容易变差。假设一个层数为$L$的多层感知机的第$l$层$H^{(l)}$的权重参数为$W^{l}$，输出层$H^{(L)}$的权重参数为$W^{(L)}$。为了便于讨论，不考虑偏差参数，且设所有隐藏层的激活函数为恒等映射（identity mapping）$\phi (x)=x$。给定输入$X$，多层感知机的第l层的输出$H^{(l)}=XW^{(1)}W^{(2)}…W^{(l)}$。此时，如果过层数$l$ 较大，$H^{(l)}$的计算可能会出现衰减或爆炸。举个例子，假设输入和所有层的权重参数都是标量，如权重参数为$0.2$和$5$，多层感知机的第30层输出为输入$X$分别与$0.2^{30}\approx 1\times10^{-21}$（衰减）和$5^{30} \approx 9\times10^{20}$（爆炸）的乘积。类似地，当层数较多时，梯度的计算也更容易出现衰减或爆炸。</p><p>随着内容的不断深入，我们会在后续进一步介绍深度学习的数值稳定性问题以及解决方法。</p><p>随机初始化模型参数</p><p>在神经网络中，通常需要随机初始化模型参数。下面我们来解释这样做的原因。</p><p>回顾多层感知机中描述的多层感知机。为了方便解释，假设输出层只保留一个输出单元$o_{1}$（删去$o_{2}$和$o_{3}$以及指向它们的箭头），且隐藏层使用相同的激活函数。如果将每个隐藏单元的参数都初始化为相等的值，那么在正向传播时每个隐藏单元将根据相同的输入计算出相同的值，并传递至输出层。在反向传播中，每个隐藏单元的参数梯度值相等。因此，这些参数在使用基于梯度的优化算法迭代后值依然相等。之后的迭代也是如此。在这种情况下，无论隐藏单元有多少，隐藏层本质上只有1个隐藏单元在发挥作用。因此，正如在前面的实验中所做的那样，我们通常将神经网络的模型参数，特别是权重参数，进行随机初始化。</p><p>PyTorch的默认随机初始化</p><p>随机初始化模型参数的方法有很多。在线性回归的简洁实现中，我们使用<code>torch.nn.init.normal_()</code>使模型<code>net</code>的权重参数采用正态分布的随机初始化方式。不过，PyTorch中<code>nn.Module</code>的模块参数都采取了较为合理的初始化策略（不同类型的layer具体采样的哪一种初始化方法的可参考源代码），因此一般不用我们考虑。</p><p>Xavier随机初始化</p><p>还有一种比较常用的随机初始化方法叫作Xavier随机初始化。 假设某全连接层的输入个数为$a$，输出个数为$b$，Xavier随机初始化将使该层中权重参数的每个元素都随机采样于均匀分布<br>$$<br>U\left(-\sqrt{\frac{6}{a+b}}, \sqrt{\frac{6}{a+b}}\right)<br>$$<br>它的设计主要考虑到，模型参数初始化后，每层输出的方差不该受该层输入个数影响，且每层梯度的方差也不该受该层输出个数影响。</p><p>总结</p><ul><li>深度模型有关数值稳定性的典型问题是衰减和爆炸。当神经网络的层数较多时，模型的数值稳定性容易变差。</li><li>我们通常需要随机初始化神经网络的模型参数，如权重参数。</li></ul><hr><h2 id="11-模型构造"><a href="#11-模型构造" class="headerlink" title="11.模型构造"></a>11.模型构造</h2><ul><li>可以通过继承<code>Module</code>类来构造模型。</li><li><code>Sequential</code>、<code>ModuleList</code>、<code>ModuleDict</code>类都继承自<code>Module</code>类。</li><li>与<code>Sequential</code>不同，<code>ModuleList</code>和<code>ModuleDict</code>并没有定义一个完整的网络，它们只是将不同的模块存放在一起，需要自己定义<code>forward</code>函数。</li><li>虽然<code>Sequential</code>等类可以使模型构造更加简单，但直接继承<code>Module</code>类可以极大地拓展模型构造的灵活性。</li></ul><hr><h2 id="12-模型参数的访问、初始化和共享"><a href="#12-模型参数的访问、初始化和共享" class="headerlink" title="12.模型参数的访问、初始化和共享"></a>12.模型参数的访问、初始化和共享</h2><hr><h2 id="13-批量归一化"><a href="#13-批量归一化" class="headerlink" title="13.批量归一化"></a>13.批量归一化</h2><p>对输入数据做了标准化处理：处理后的任意一个特征在数据集中所有样本上的均值为0、标准差为1。标准化处理输入数据使各个特征的分布相近：这往往更容易训练出有效的模型。</p><p>通常来说，数据标准化预处理对于浅层模型就足够有效了。随着模型训练的进行，当每层中参数更新时，靠近输出层的输出较难出现剧烈变化。但对深层神经网络来说，即使输入数据已做标准化，训练中模型参数的更新依然很容易造成靠近输出层输出的剧烈变化。这种计算数值的不稳定性通常令我们难以训练出有效的深度模型。</p><p>批量归一化的提出正是为了应对深度模型训练的挑战。在模型训练时，批量归一化利用小批量上的均值和标准差，不断调整神经网络中间输出，从而使整个神经网络在各层的中间输出的数值更稳定。<strong>批量归一化和下一节将要介绍的残差网络为训练和设计深度模型提供了两类重要思路</strong>。</p><h3 id="批量归一化层"><a href="#批量归一化层" class="headerlink" title="批量归一化层"></a>批量归一化层</h3><p>对全连接层和卷积层做批量归一化的方法稍有不同。下面将分别介绍这两种情况下的批量归一化。</p><h4 id="对全连接层做批量归一化"><a href="#对全连接层做批量归一化" class="headerlink" title="对全连接层做批量归一化"></a>对全连接层做批量归一化</h4><p>我们先考虑如何对全连接层做批量归一化。通常，我们将批量归一化层置于全连接层中的仿射变换和激活函数之间。设全连接层的输入为$u$，权重参数和偏差参数分别为$W$和$b$，激活函数为$\phi$。设批量归一化的运算符为$BN$。那么，使用批量归一化的全连接层的输出为<br>$$<br>\phi(BN(\boldsymbol{x}))<br>$$<br>其中批量归一化输入$\boldsymbol{x}$由仿射变换<br>$$<br>\boldsymbol{x=Wu+b}<br>$$<br>得到。考虑一个由$m$个样本组成的小批量，仿射变换的输出为一个新的小批量$\mathcal{B} = {\boldsymbol{x}^{(1)}, \ldots, \boldsymbol{x}^{(m)} }$。它们正是批量归一化层的输入。对于小批量$\mathcal{B}$中任意样本$\boldsymbol{x}^{(i)} \in \mathbb{R}^d, 1 \leq i \leq m$，批量归一化层的输出同样是$d$维向量<br>$$<br>\boldsymbol{y}^{(i)} = BN(\boldsymbol{x}^{(i)})<br>$$<br>并由以下几步求得。首先，对小批量$\mathcal{B}$求均值和方差：<br>$$<br>\begin{array}{c}<br>\boldsymbol{\mu}<em>{\mathcal{B}} \leftarrow \frac{1}{m} \sum</em>{i=1}^{m} \boldsymbol{x}^{(i)} \<br>\boldsymbol{\sigma}<em>{\mathcal{B}}^{2} \leftarrow \frac{1}{m} \sum</em>{i=1}^{m}\left(\boldsymbol{x}^{(i)}-\boldsymbol{\mu}<em>{\mathcal{B}}\right)^{2}<br>\end{array}<br>$$<br>其中的平方计算是按元素求平方。接下来，使用按元素开方和按元素除法对$\boldsymbol{x}^{(i)}$标准化：<br>$$<br>\hat{\boldsymbol{x}}^{(i)} \leftarrow \frac{\boldsymbol{x}^{(i)}-\boldsymbol{\mu}</em>{\mathcal{B}}}{\sqrt{\sigma_{\mathcal{B}}^{2}+\epsilon}}<br>$$<br>这里$\epsilon &gt; 0$是一个很小的常数，保证分母大于0。在上面标准化的基础上，批量归一化层引入了两个可以学习的模型参数，拉伸（scale）参数 $\boldsymbol{\gamma}$和偏移（shift）参数 $\boldsymbol{\beta}$。这两个参数和$\boldsymbol{x}^{(i)}$形状相同，皆为$d$维向量。它们与$\boldsymbol{x}^{(i)}$分别做按元素乘法（符号$\odot$）和加法计算：<br>$$<br>\boldsymbol{y}^{(i)} \leftarrow \boldsymbol{\gamma} \odot \hat{\boldsymbol{x}}^{(i)}+\boldsymbol{\beta}<br>$$<br>至此，我们得到了$\boldsymbol{x}^{(i)}$的批量归一化的输出$\boldsymbol{y}^{(i)}$。 值得注意的是，可学习的拉伸和偏移参数保留了不对$\hat{\boldsymbol{x}}^{(i)}做$批量归一化的可能：此时只需学出$\boldsymbol{\gamma} = \sqrt{\boldsymbol{\sigma}_\mathcal{B}^2 + \epsilon}$和$\boldsymbol{\beta} = \boldsymbol{\mu}_\mathcal{B}$。我们可以对此这样理解：如果批量归一化无益，理论上，学出的模型可以不使用批量归一化。</p><h4 id="对卷积层做批量归一化"><a href="#对卷积层做批量归一化" class="headerlink" title="对卷积层做批量归一化"></a>对卷积层做批量归一化</h4><p>对卷积层来说，批量归一化发生在卷积计算之后、应用激活函数之前。如果卷积计算输出多个通道，我们需要对这些通道的输出分别做批量归一化，且<strong>每个通道都拥有独立的拉伸和偏移参数，并均为标量</strong>。设小批量中有$m$个样本。在单个通道上，假设卷积计算输出的高和宽分别为$p$和$q$。我们需要对该通道中$m×p×q$个元素同时做批量归一化。对这些元素做标准化计算时，我们使用相同的均值和方差，即该通道中$m×p×q$个元素的均值和方差。</p><h4 id="预测时的批量归一化"><a href="#预测时的批量归一化" class="headerlink" title="预测时的批量归一化"></a>预测时的批量归一化</h4><p>使用批量归一化训练时，我们可以将批量大小设得大一点，从而使批量内样本的均值和方差的计算都较为准确。将训练好的模型用于预测时，我们希望模型对于任意输入都有确定的输出。因此，单个样本的输出不应取决于批量归一化所需要的随机小批量中的均值和方差。一种常用的方法是通过移动平均估算整个训练数据集的样本均值和方差，并在预测时使用它们得到确定的输出。可见，和丢弃层一样，批量归一化层在训练模式和预测模式下的计算结果也是不一样的。</p><hr><h2 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><h3 id="不含隐藏状态的神经网络"><a href="#不含隐藏状态的神经网络" class="headerlink" title="不含隐藏状态的神经网络"></a>不含隐藏状态的神经网络</h3><p>让我们考虑一个含单隐藏层的多层感知机。给定样本数为$n$、输入个数（特征数或特征向量维度）为$d$的小批量数据样本$\boldsymbol{X} \in \mathbb{R}^{n \times d}$。设隐藏层的激活函数为$\phi$，那么隐藏层的输出$\boldsymbol{H} \in \mathbb{R}^{n \times h}$计算为<br>$$<br>\boldsymbol{H}=\phi\left(\boldsymbol{X} \boldsymbol{W}<em>{x h}+\boldsymbol{b}</em>{h}\right)<br>$$<br>其中隐藏层权重参数$\boldsymbol{W}<em>{xh} \in \mathbb{R}^{d \times h}$，隐藏层偏差参数 $\boldsymbol{b}<em>h \in \mathbb{R}^{1 \times h}$，$h$为隐藏单元个数。上式相加的两项形状不同，因此将按照广播机制相加。把隐藏变量$\boldsymbol{H}$作为输出层的输入，且设输出个数为$q$（如分类问题中的类别数），输出层的输出为<br>$$<br>\boldsymbol{O}=\phi\left(\boldsymbol{H} \boldsymbol{W}</em>{h q}+\boldsymbol{b}</em>{q}\right)<br>$$<br>其中输出变量$\boldsymbol{O} \in \mathbb{R}^{n \times q}$, 输出层权重参数$\boldsymbol{W}_{hq} \in \mathbb{R}^{h \times q}$, 输出层偏差参数$\boldsymbol{b}_q \in \mathbb{R}^{1 \times q}$。如果是分类问题，我们可以使用$\text{softmax}(\boldsymbol{O})$来计算输出类别的概率分布。</p><h3 id="含隐藏状态的循环神经网络"><a href="#含隐藏状态的循环神经网络" class="headerlink" title="含隐藏状态的循环神经网络"></a>含隐藏状态的循环神经网络</h3><p>现在我们考虑输入数据存在时间相关性的情况。假设$\boldsymbol{X}<em>t \in \mathbb{R}^{n \times d}$是序列中时间步$t$的小批量输入，$\boldsymbol{H}<em>t \in \mathbb{R}^{n \times h}$是该时间步的隐藏变量。与多层感知机不同的是，这里我们保存上一时间步的隐藏变量$\boldsymbol{H}</em>{t-1}$，并引入一个新的权重参数$\boldsymbol{W}</em>{hh} \in \mathbb{R}^{h \times h}$，该参数用来描述在当前时间步如何使用上一时间步的隐藏变量。具体来说，时间步tt<em>t</em>的隐藏变量的计算由当前时间步的输入和上一时间步的隐藏变量共同决定：<br>$$<br>\boldsymbol{H}<em>{t}=\phi\left(\boldsymbol{X}</em>{t} \boldsymbol{W}<em>{x h}+\boldsymbol{H}</em>{t-1} \boldsymbol{W}<em>{h h}+\boldsymbol{b}</em>{h}\right)<br>$$<br>与多层感知机相比，我们在这里添加了$\boldsymbol{H}<em>{t-1} \boldsymbol{W}</em>{hh}$一项。由上式中相邻时间步的隐藏变量$\boldsymbol{H}<em>t$和$\boldsymbol{H}</em>{t-1}$之间的关系可知，这里的隐藏变量能够捕捉截至当前时间步的序列的历史信息，就像是神经网络当前时间步的状态或记忆一样。因此，该隐藏变量也称为隐藏状态。由于隐藏状态在当前时间步的定义使用了上一时间步的隐藏状态，上式的计算是循环的。使用循环计算的网络即循环神经网络（recurrent neural network）。</p><p>循环神经网络有很多种不同的构造方法。含上式所定义的隐藏状态的循环神经网络是极为常见的一种。若无特别说明，本章中的循环神经网络均基于上式中隐藏状态的循环计算。在时间步$t$，输出层的输出和多层感知机中的计算类似：<br>$$<br>\boldsymbol{O}<em>{t}=\boldsymbol{H}</em>{t} \boldsymbol{W}<em>{h q}+\boldsymbol{b}</em>{q}<br>$$<br>循环神经网络的参数包括隐藏层的权重$\boldsymbol{W}<em>{xh} \in \mathbb{R}^{d \times h}$、$\boldsymbol{W}</em>{hh} \in \mathbb{R}^{h \times h}$和偏差 $\boldsymbol{b}<em>h \in \mathbb{R}^{1 \times h}$，以及输出层的权重$\boldsymbol{W}</em>{hq} \in \mathbb{R}^{h \times q}$和偏差$\boldsymbol{b}_q \in \mathbb{R}^{1 \times q}$。值得一提的是，即便在不同时间步，循环神经网络也始终使用这些模型参数。因此，循环神经网络模型参数的数量不随时间步的增加而增长。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Web</title>
      <link href="/2022/01/18/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/web/"/>
      <url>/2022/01/18/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/web/</url>
      
        <content type="html"><![CDATA[<p>常用Web汇总。</p><span id="more"></span><h2 id="待"><a href="#待" class="headerlink" title="待"></a>待</h2><p><a href="https://www.bilibili.com/">哔哩哔哩</a>、<a href="https://www.xljsci.com/index/index/list">小绿鲸</a>、<a href="https://scholar.google.com/">谷歌学术</a>、<a href="https://g.luciaz.me/">出去</a>、<a href="https://www.toolsdaquan.com/ipcheck/">IP可用性检测工具</a>、<a href="https://www.latexlive.com/home">公式编辑器</a></p><h2 id="学校"><a href="#学校" class="headerlink" title="学校"></a>学校</h2><p><a href="https://eone.neu.edu.cn/">一网通办</a>、</p><h2 id="在线PDF处理工具"><a href="#在线PDF处理工具" class="headerlink" title="在线PDF处理工具"></a>在线PDF处理工具</h2><p><a href="https://www.ilovepdf.com/zh-cn">iLovePDF</a></p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p><a href="https://www.deepl.com/translator">DeepL</a></p><h2 id="色彩工具"><a href="#色彩工具" class="headerlink" title="色彩工具"></a>色彩工具</h2><p><a href="https://mycolor.space/">ColorSpace</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Survey on Knowledge Graph Embeddings with Literals： Which model links better Literal-ly?</title>
      <link href="/2022/01/06/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/paper001/"/>
      <url>/2022/01/06/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/paper001/</url>
      
        <content type="html"><![CDATA[<p>KG应用程序的计算和存储成本很高。因此，体现了将高维KG映射到低维空间的表示的必要性，即嵌入空间，保留结构以及关系信息。本文对KG嵌入模型进行了研究，该模型不仅考虑了以KG实体和关系形式所包含的<strong>结构化</strong>信息，还考虑了文本、数值、图像等文字表示的<strong>非结构化</strong>信息等。除了对迄今为止提出的用文字生成KG嵌入的方法进行理论分析和比较外，还针对链接预测的一般任务，对相同设置下的不同方法进行了实证评估。</p><span id="more"></span><h1 id="4-带文字的知识图嵌入"><a href="#4-带文字的知识图嵌入" class="headerlink" title="4. 带文字的知识图嵌入"></a>4. 带文字的知识图嵌入</h1><p>本节研究KG嵌入模型，根据使用的文本类型将文本分为以下不同类别：（i）文本，（ii）数字，（iii）图像，以及（iv）多模态。KG嵌入模型利用至少两种提供补充信息的文字，被认为是多模态。在随后的章节中，将对前面描述的每个类别的模型进行描述，分析它们的相似性和差异，然后讨论潜在的缺点。</p><h2 id="4-1-具有文本属性的模型"><a href="#4-1-具有文本属性的模型" class="headerlink" title="4.1 具有文本属性的模型"></a>4.1 具有文本属性的模型</h2><p>在本节中，讨论了七种利用文本文字的KG嵌入模型，即Extended RESCAL[37]、 Jointly(desp)[21]、DKRL[13]、Jointly[22]、SSP[23]、KDCoE[24]和KGloVe with literals[36]。对这些模型的比较进行了详细描述，并总结了它们的缺点。此外，为了显示基于复杂性的模型之间的差异，每个模型的参数数量如表3所示。</p><p>CATT [97], textural association [98], open-world extension for KGC [99], EDGE [100], TransW [101].</p><h4 id="Extended-RESCAL"><a href="#Extended-RESCAL" class="headerlink" title="Extended RESCAL"></a>Extended RESCAL</h4><p>通过扩展其算法来更有效地处理文字值，并处理伴随张量的稀疏性的缺点，来改进原有的RESCAL方法。在原始的RESCAL方法中，关系数据被建模为大小为n×n×m的三维张量$X$，其中n是实体数，m是关系数。$X_{ijk} =1$ 表示的是第i个实体为主语，第k个关系作为谓词，第j个实体作为宾语的三元组的存在。</p><p>如果 $X_{ijk} =0$ ，则表示三元组不存在。提出了一种新的张量分解方法，该方法在$X$上执行。有关更多详细信息，请参阅[37]。如果属性三元组必须以这种方式建模，那么文本将被视为宾语实体，包含文字可能会导致运行时的增量，因为必须分解较大的张量。</p><p>与原算法相比，扩展的 RESCAL算法在一个单独的矩阵中处理属性三元组。这个矩阵分解是与三元组的张量因子分解共同完成的。只包含文本文本的属性三元组被编码在实体-属性矩阵$D$中，其中行是实体，列是 &lt; data type relation，value &gt; pairs。如果给定一个具有文本数据类型的三元组，比如 rdfs: label 或 yago: haspreferredmeaning，则通过对 object literal 中的文本进行<strong>标记和截断</strong>来创建一个或多个这样的对。</p><p>然后将矩阵$D$分解为$D \approx A V$，$A$ 和 $V$分别作为实体和属性的潜在组成部分表示。尽管这种方法在处理多值文本时有优势，但它<strong>不考虑</strong>文本值的序列。</p><p>属性允许我们包含简单的、自动聚合的特征，例如（实体、hasRelation、关系名称），这些特征在某些预测任务中很有用。 </p><p>在分解中包含属性的一种天真的方法是为属性添加一个额外的切片 m + 1，并对数据中的属性值应用某种形式的预处理。然后将这个预处理步骤的结果与其 相应的谓词作为新索引 n + 1, . . . , n + l 到 X 的实体模式。此外，对于实体 i 的每个属性值 o，那些条目 $X_{i,m+1,n+j}$将被设置为 1，其中 n+j 对应于 o。 </p><p>例如，假设文本数据通过标记化进行预处理，属性 (Albert_Einstein, foaf:name, ‘Albert Einstein’) 将设置这些条目$X_{ijk} =1$，其中 i ≡ Albert_Einstein, k ≡ m + 1 和 j ≡&lt;foaf:name, ‘Albert’&gt;或 j ≡ &lt;foaf:name, ‘Einstein’&gt;<br>$$<br>\min <em>{A, R, V} f</em>{l o s s}(A, R)+f_{r e g}(A, R)+f_{a t t r}(A, V)<br>$$<br>$$<br>f_{a t t r}(A, V)=|D-A V|<em>{F}^{2}+\lambda</em>{V}|V|_{F}^{2}<br>$$</p><p>其中，$f_{reg}$是正则化项，这是为了防止模型过度拟合。</p><h4 id="Jointly-desp"><a href="#Jointly-desp" class="headerlink" title="Jointly(desp)"></a>Jointly(desp)</h4><p>提出了一种新的将实体和词联合嵌入同一向量空间的方法。在我们的解决方案中，定义了知识和文本的相关概率模型，该模型由三部分组成：<strong>知识模型</strong>、<strong>文本模型</strong>和<strong>对齐模型</strong>。知识模型和文本模型都使用相同的核心方法假设进行事实建模：一个候选事实 (h, r, t) 是基于$\parallel h+r-t\parallel $</p><p>唯一的区别是，在知识模型中，关系r是<strong>显式监督</strong>的，目标是拟合事实三元组，而在文本模型中，我们假设在某些文本窗口中出现的任何一对单词h和t都具有一定的关系r，但r是一个<strong>隐藏变量</strong>，目标是拟合出现的单词对。</p><p>对齐模型保证了实体和词/短语在同一空间的嵌入，并促使两个模型相互增强。本文介绍了两种对齐机制：利用实体名称和利用维基百科锚点。这种联合嵌入知识和文本的方法可以认为是<strong>半监督</strong>的知识嵌入：知识图提供了对事实的明确监督，而文本语料库提供了更多的“关系-未标记”词对。</p><p>一种联合学习KGs嵌入和实体描述文本语料库的方法，即使用对齐模型确保实体、关系和单词在同一向量空间中表示。该方法由三部分组成，即知识模型、文本模型和对齐模型。知识模型用于从KG中获取结构化信息的语义。给定一个三元组&lt;h，r，t&gt;，该模型对三元组的合理性进行了细化，如[67]所示：</p><p>我们在知识图中定义事实（h，r，t）的以下条件概率：                      <strong>pTransE</strong></p><p>$$<br>\operatorname{Pr}(h \mid r, t)=\frac{\exp {z(\mathbf{h}, \mathbf{r}, \mathbf{t})}}{\sum_{\tilde{h} \in \mathcal{I}} \exp {z(\tilde{\mathbf{h}}, \mathbf{r}, \mathbf{t})}}<br>$$</p><p>$$<br>z(\mathbf{h}, \mathbf{r}, \mathbf{t})=b-\frac{1}{2}|\mathbf{h}+\mathbf{r}-\mathbf{t}|^{2}<br>$$</p><p>其中，b是指定用于调整刻度以获得更好数值稳定性的偏差常数，b=7是一个明智的选择。</p><p>然后，知识模型的损失函数定义如下：</p><p>知识模型的目标是<strong>最大化</strong>现有事实三元组的条件可能性<br>$$<br>\begin{array}{r}<br>L_{K}=\sum_{(h, r, t)}[\log \operatorname{Pr}(h \mid r, t)+\log \operatorname{Pr}(t \mid h, r)<br>+\log \operatorname{Pr}(r \mid h, t)]<br>\end{array}<br>$$</p><p>文本模型采用了[67]中的相同假设，即如果两个单词出现在同一<strong>上下文</strong>中，则它们之间存在关系。</p><p>文本窗口，则这两个单词之间存在rwv关系。也就是说，我们可以说（w，rwv，v）的三元组是一个事实。</p><p>基于此假设，文本模型定义了一对单词w和v在文本窗口中同时出现的概率，如下所示：<br>$$<br>\operatorname{Pr}(w \mid v)=\frac{\exp {z(w, v)}}{\sum_{\tilde{w} \in V} \exp {z(\tilde{w}, v)}}<br>$$</p><p>$$<br>z({w}, {v})=b-\frac{1}{2}|\mathbf{w}-\mathbf{v}|^{2}<br>$$</p><p>$$<br>L_{T}=\sum_{(w, v)} \log \operatorname{Pr}(w \mid v)<br>$$</p><p>如果我们只有知识模型和文本模型，那么实体嵌入和单词嵌入将在不同的空间中，它们之间的任何计算都是没有意义的。因此，我们需要将两个空间对齐到同一个空间的机制。本文提出了两种机制：利用维基百科锚和利用实体名称。</p><p>第三个组件对齐模型的作用是将实体、关系和单词的嵌入放在同一个向量空间中。该子模型通过使用实体描述来对齐这些嵌入。对于实体e描述中的每个单词w，给定e预测w的条件概率定义为：<br>$$<br>\operatorname{Pr}(w \mid e)=\frac{\exp {z(e, w)}}{\sum_{\tilde{w} \in V} \exp {z(e, \tilde{w})}},<br>$$</p><p>$$<br>z({e}, {w})=b-\frac{1}{2}|\mathbf{e}-\mathbf{w}|^{2}<br>$$</p><p>其中实体向量e与知识模型中出现的实体向量相同，即实体具有单个统一表示，该表示从结构化KG和实体描述中捕获语义。Pr（e | w）的定义类似。根据等式5中给出的定义，对齐模型的损失函数定义为：<br>$$<br>L_{A}=\sum_{e \in \mathcal{E}} \sum_{w \in D_{e}}[\log \operatorname{Pr}(w \mid e)+\log \operatorname{Pr}(e \mid w)]<br>$$</p><p>其中$\varepsilon$和$D_{e}$分别表示实体集合和实体e的描述。</p><p>通过采用[67]中的联合嵌入框架，联合的主要损失（desp）定义如下：<br>$$<br>L\left(\left{e_{i}\right},\left{r_{j}\right},\left{w_{l}\right}\right)=L_{K}+L_{T}+L_{A}<br>$$</p><h4 id="DKRL"><a href="#DKRL" class="headerlink" title="DKRL"></a>DKRL</h4><p>通过利用实体的描述扩展TransE[11]。对于每个实体e，学习两种向量表示，即基于结构的$e_{s}$和基于描述的$e_{d}$。这两种实体表示同时学习到相同的向量空间中，但<strong>不强制统一</strong>，从而可以表示仅具有描述的新实体。为了实现这一点，给定某个三重&lt;h，r，t&gt;，DKRL模型的能量函数定义为：</p><p>$$<br>\begin{aligned}<br>E &amp;=\left|h_{s}+r-t_{s}\right|+\left|h_{d}+r-t_{d}\right|<br>+\left|h_{s}+r-t_{d}\right|+\left|h_{d}+r-t_{s}\right|<br>\end{aligned}<br>$$<br>为了学习基于结构的表示，直接应用TransE方法，将三重关系视为从头实体到尾实体的转换。另一方面，连续字袋（CBOW）和深度卷积神经网络（CNN）模型被用来生成头部和尾部实体的基于描述的表示。以CBOW为例，基于关键词的描述生成短文本，并将其对应的词嵌入求和生成实体嵌入。在CNN模型中，在对描述进行预处理后，提供来自维基百科的预训练词向量作为输入。该模型有五层，在每个卷积层池化后，应用卷积层池化来减小卷积神经网络的参数空间和滤波噪声。最大池应用于第一个池，平均池应用于最后一个池。使用的激活函数是tanh或ReLU。CNN模型比CBOW工作得更好，因为它保留了单词的顺序。</p><p>为了训练DKRL，以下基于边距的分数函数被视为目标函数，并使用标准反向传播（使用随机梯度下降（SGD））最小化<br>$$<br>\begin{array}{r}<br>L=\sum_{(h, r, t) \in T} \sum_{\left(h^{\prime}, r^{\prime}, t^{\prime}\right) \in T^{\prime}} \max (\gamma+d(h+r, t)<br>\left.-d\left(h^{\prime}+r^{\prime}, t^{\prime}\right), 0\right)<br>\end{array}<br>$$<br>其中，$ \gamma $&gt;0是边界超参数，d是相异函数，$T’$是一组损坏的三元组。实体的表示可以是基于结构的，也可以是基于描述的。</p><h4 id="Jointly"><a href="#Jointly" class="headerlink" title="Jointly"></a>Jointly</h4><p>通过利用实体描述学习KG嵌入。具体来说，它通过将实体的基于结构和基于描述的表示与<strong>选通机制</strong>相结合来学习实体的联合嵌入。<strong>门</strong>用于在基于结构的表示和基于描述的表示之间找到平衡。</p><p>对于低频实体，描述将为嵌入提供补充信息，从而较好地解决了知识库中的稀疏性问题。对于某个实体，通过将描述转换为固定长度向量，可以从其描述中对表示进行编码。联合使用不同的文本编码器，如单词包、LSTM和注意力LSTM。给定一个实体，我们注意力LSTM编码器可以根据不同的关系从其文本描述中动态选择最相关的信息。</p><p>为了集成两种实体表示，我们使用选通机制来确定联合表示在多大程度上依赖于结构或文本</p><p>对于实体$e$，其联合表示$e$是其基于结构的表示 ($e_{s}$) 和基于描述的表示 ($e_{d}$) 之间的线性插值，其定义为：<br>$$<br>\mathbf{e}=g_{e} \odot \mathbf{e}<em>{\mathbf{s}}+\left(1-g</em>{e}\right) \odot \mathbf{e}<em>{\mathbf{d}}<br>$$<br>$\odot $是元素级乘法，$g</em>{e}$是平衡两个信息源（结构和文本）的门。</p><p>实体描述使用单词包、LSTM或注意LSTM（ALSTM）编码器进行编码，以便为相应实体生成基于文本的表示。另一方面，为了更好地建模基于结构的嵌入，可以使用任何现有的KG嵌入模型（如TransE）对实体和关系进行预训练。联合的评分功能受TransE的启发，定义如下：</p><p>$$<br>\begin{array}{c}<br>f\left(h, r, t ; d_{h}, d_{t}\right)=|\left(\mathbf{g}<em>{h} \odot \mathbf{h}</em>{s}+\left(1-\mathbf{g}<em>{h}\right)\right. \left.\odot \mathbf{h}</em>{d}\right)+r-\left(\mathbf{g}<em>{t} \odot \mathbf{h}</em>{t}+\left(1-\mathbf{g}<em>{t}\right) \odot \mathbf{t}</em>{d}\right) |<em>{2}^{2}<br>\end{array}<br>$$<br>其中，$h</em>{s}$、$h_{d}$和$g_{h}$分别是头部实体的基于结构的嵌入、基于描述的嵌入和gate，而$t_{s}$、$t_{d}$和$g_{t}$分别是尾部实体的基于结构的嵌入、基于描述的嵌入和gate。<br>$$<br>\begin{array}{c}<br>J(\Theta)=\sum_{(h, r, t) \in \mathcal{D}} \sum_{(\hat{h}, \hat{r}, \hat{t}) \in \hat{\mathcal{D}}} \max (0, \gamma- f(h, r, t)+f(\hat{h}, \hat{r}, \hat{t}))+\eta|\Theta|_{2}^{2}<br>\end{array}<br>$$</p><h4 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a>SSP</h4><p>SSP (语义空间投影)  [23] 是从结构化/符号三元组和文本描述中学习的联合嵌入模型。但仍有一个问题需要解决，即弱相关建模问题，现有模型很难表征文本和三元组之间的<strong>强相关性</strong>。</p><p>在DKRL中，对于三元组，尽可能将头部实体的嵌入向量转换为尾部实体的嵌入向量，然后将文本和实体的向量<strong>串联</strong>为最终的嵌入向量。而在“联合”模型中，作者试图生成相应实体和文本的连贯嵌入。DKRL和“联合”都应用了一阶约束，这些约束在捕获文本和三元组的相关性方面很弱。值得注意的是，三重嵌入始终是主要过程，文本描述必须与三重嵌入交互才能更好地嵌入。只有这样，<strong>语义效应</strong>才能产生更多的感觉。因此，我们通过将三重嵌入投射到语义子空间（如<strong>超平面</strong>）来关注更强的语义交互，如图2所示。在数学上，采用二次约束对强相关性进行建模，从而使嵌入拓扑具有足够的语义学特异性。</p><p>与DKRL和联合（Desp）不同，在DKRL和联合（Desp）中，一阶约束在捕获文本描述和符号三元组的相关性方面较弱，SSP遵循三元嵌入始终被视为主要过程的原则，文本描述必须与三元组相互作用学习更好的表示。</p><p>因此，采用二次约束将三重嵌入投影到超平面等语义子空间以允许强相关性。</p><p><img src="https://pic.imgdb.cn/item/6214efcd2ab3f51d91ad3dda.jpg" alt="image-20220108094305573"></p><p>SSP应用以下评分功能：<br>$$<br>f_{r}(h, t)=-\lambda\left|\mathbf{e}-\mathbf{s}^{T} \mathbf{e s}\right|<em>{2}^{2}+|\mathbf{e}|</em>{2}^{2}<br>$$</p><p>$$<br>\mathbf{e} \doteq \mathbf{h}+\mathbf{r}-\mathbf{t}<br>$$</p><p>由于语义向量的每个分量都指示主题的相关级别，因此我们建议语义组合应采用加法形式:<br>$$<br>\mathbf{s} \doteq \frac{\mathbf{s}<em>{\mathbf{h}}+\mathbf{s}</em>{\mathbf{t}}}{\left|\mathbf{s}<em>{\mathbf{h}}+\mathbf{s}</em>{\mathbf{t}}\right|}<br>$$</p><p>其中，标准化用于生成法向量。注意，λ是一个合适的超参数，h和t分别是基于头和尾实体的结构（符号三元组）嵌入，$s_{h}$和$s_{t}$分别是从头和尾实体的文本描述生成的语义向量。</p><p>通过文本语义，我们的模型可以<strong>增强辨别能力</strong>。具体地说，通过在相应语义超平面上的投影测量等长损失向量，从而对损失进行合理划分。例如，关于《约翰·鲍威尔》对哪部电影有贡献的问题，有两个候选实体，即真实答案“功夫熊猫”和否定答案“终结者拯救”。如果没有文本语义，就很难进行区分，因此，TransE计算的损失分别为8.1和8.0，这导致了一个艰难的决定。深入到结构语义中，我们发现，“约翰·鲍威尔”与“动画电影”的主题非常相关，后者与“功夫熊猫”的主题相匹配，而与另一个主题不相关。基于这一事实，查询和真实答案都存在于“动画电影”指导的超平面中，而查询和否定答案并不同时出现在相应的关联语义超平面中。因此，真实答案的预计损失可能远小于虚假答案。具体来说，我们模型中的损失分别为8.5和10.8，这足以进行区分。</p><p>因此，存在一个重要的限制，即三元组中的实体应嵌入由相关文本语义组成的语义空间中。这种限制被实现为二次形式，以描述文本和三元组之间的<strong>强相关性</strong>，换句话说，与两个信息源交互。</p><p>SSE采用非负矩阵分解（NMF）主题模型为实体（$s_{h}$和$s_{t}$）生成基于描述的语义向量，即将每个实体描述视为文档，并将文档的主题分布视为对应实体的表示。</p><p>SSP为培训提供两种不同的设置，称为Std和JOINT。在Std中，使用预先训练好的主题模型和NMF来获得基于描述的语义向量。这些基于描述的向量在训练期间是固定的，但其他参数是优化的。另一方面，在JOINT设置中，主题模型也与KG嵌入同时学习，而不是使用固定的预训练向量。</p><h4 id="KDCoE"><a href="#KDCoE" class="headerlink" title="KDCoE"></a>KDCoE</h4><p>通过基于利用实体描述的嵌入方法创建新的<strong>语言间链接</strong>（ILLs），重点关注<strong>多语言KG</strong>实体之间的一致性。该模型使用<strong>弱对齐</strong>多语言KG进行<strong>半监督跨语言</strong>学习。它迭代地执行多语言KG嵌入模型（KGEM）和多语言实体描述嵌入模型（DEM）的联合训练，以便每个模型交替提出新的IL。KGEM由两个部分组成，即知识模型和对齐模型，用于基于KGs（非定语三元组）的结构化信息学习嵌入。给定一组语言$\mathcal{L}$，对每种语言$L\in \mathcal{L}$使用单独的$k_{1}$维嵌入空间$\mathbb{R} ^{k_{1}}<em>{L} $来表示$R</em>{L}$和实体$E_{L}$的对应关系。为了学习$R_{L}$和$E_{L}$的嵌入，知识模型采用了TransE，从而以铰链损耗为目标函数。另一方面，对齐模型采用了一种基于线性变换的技术，该技术在跨语言推理的情况下性能最佳。该技术采用以下目标函数：<br>$$<br>S_{A}=\sum_{\left(e, e^{\prime}\right) \in I\left(L_{i}, L_{j}\right)}\left|M_{i j} \mathbf{e}-\mathbf{e}^{\prime}\right|<em>{2}<br>$$<br>其中$I\left(L</em>{i}, L_{j}\right)$是语言$L_{i}$和$L_{j}$之间的ILLs，$M_{ij}$是$k_{1}$×$k_{1}$矩阵，是从$L_{i}$到$L_{j}$的实体向量的线性变换。设$S_{K}$为知识模型使用的铰链损失函数，KGEM模型则最小化$S_{KG}=S_{K}+\alpha S_{A}$，其中α为正超参数。对于DEM模型，使用注意选通递归单元编码器（AGRU）对多语言实体描述进行编码。DEM采用多语词嵌入技术，从词级获取多语实体描述的语义信息。这两个模型，即KGEM和DEM，迭代地共同训练，以便每个模型交替地提出一个新的ILL。</p><h4 id="KGloVe-with-literals"><a href="#KGloVe-with-literals" class="headerlink" title="KGloVe with literals"></a>KGloVe with literals</h4><p>是在KG嵌入方法中结合实体描述的实验性尝试。该实验在DBpedia上进行，将实体的摘要和注释作为它们的描述。主要目标是从文本描述中提取命名实体，并针对文本中的每个实体，用实体本身替换表示实体的单词，然后将其相邻的单词和实体作为上下文。该方法的工作原理是独立创建两个共生矩阵，然后在最后合并它们，以便执行联合嵌入。第一个矩阵是使用与KGloVe[68]中相同的技术生成的，即在（加权）图上执行个性化PageRank（PPR），然后进行手套[69]方法中使用的相同优化。</p><p>手套遵循一种分布的语义观点，认为词语在上下文中的意义，这基本上依赖于“意义相似的词语出现在相似的上下文中”的假设–也就是说，意义可以从大量文本中单词的上下文（即周围的单词）中获得。</p><p>GloVe</p><p>最近的学习单词向量空间表示的方法已经成功地使用向量算法捕获细粒度语义和句法规则，但是这些规则的起源仍然是不透明的。我们分析并明确了这些规则在词向量中出现所需的模型属性。结果是一个新的全局对数双线性回归模型，它结合了文献中两个主要模型族的优点：全局矩阵分解和局部上下文窗口方法。我们的模型通过只对单词共现矩阵中的非零元素进行训练，而不是对整个稀疏矩阵或大型语料库中的单个上下文窗口进行训练，有效地利用了统计信息。该模型生成了一个具有有意义子结构的向量空间，在最近的一项单词类比任务中，该模型的性能达到了75%。它在相似性任务和命名实体识别方面也优于相关模型。</p><p>词向量学习的适当起点应该是共现概率的比率，而不是概率本身。</p><p>注意到Pik/Pjk的比率取决于三个词i、j和k，最一般的模型采用<br>$$<br>F\left(w_{i}, w_{j}, \tilde{w}<em>{k}\right)=\frac{P</em>{i k}}{P_{j k}}<br>$$<br>w字向量 w- 上下文词向量</p><p>KGloVe</p><p>向量空间嵌入在数据挖掘和机器学习任务中使用RDF数据时表现良好。现有的方法，如RDF2Vec，使用局部信息，即，它们依赖于为RDF图中的节点生成的局部序列。对于单词嵌入，已经提出了全局技术，如手套，作为替代方案。在本文中，我们展示了如何将全局嵌入的思想转化为RDF嵌入，并表明其结果与传统的局部技术（如RDF2Vec）具有竞争力。</p><p>是在KG嵌入方法中结合实体描述的实验性尝试。该实验在DBpedia上进行，将实体的摘要和注释作为它们的描述。主要目标是从文本描述中提取命名实体，并针对文本中的每个实体，用实体本身替换表示实体的单词，然后将其相邻的单词和实体作为上下文。该方法的工作原理是独立创建两个共生矩阵，然后在最后合并它们，以便执行联合嵌入。第一个矩阵是使用与KGloVe[68]中相同的技术生成的，即在（加权）图上执行个性化PageRank（PPR），然后进行手套[69]方法中使用的相同优化。为了创建第二个矩阵，使用KG的实体和谓词列表作为输入，对实体描述文本执行命名实体识别（NER）任务。NER步骤采用了一种简单的精确字符串匹配技术，这会导致许多缺点，例如由于具有相同语义的不同关键字而缺少实体。所有与任何实体标签不匹配的英语单词都将添加到实体谓词列表中。然后使用entitypredicate和单词列表作为输入，将文本的手套共现应用于修改后的文本（即DBpedia摘要和注释）。最后，将两个共现矩阵相加，以创建一个统一的矩阵。该方法已在分类和回归任务上进行了评估，结果表明，对于所使用的大多数分类器，除支持向量机外，该方法并没有给KGloVe带来显著的改进。然而，通过大量实验，可以通过参数调整来改进该方法。</p><p>总结</p><p>这些模型之间的基本区别在于利用文本文本文本中给出的信息并将其与基于结构的表示相结合的方法。与基于文本的嵌入模型相比，KDCoE的一个主要优点是它考虑了多语言KG中的描述。</p><p>此外，DKRL和KDCoE嵌入模型都被设计用于处理新实体，它们在KG中只有属性三元组。联合（Desp）将KG嵌入和单词嵌入在单词层面上对齐，这可能会导致在短语或句子层面上丢失一些语义信息。联合应用门控机制，允许自动在结构信息和文本信息之间找到平衡。它还使用LSTM编码器，该编码器使模型能够根据不同的关系从实体的文本描述中为实体选择最相关的信息。与DKRL和Joinly  (DESP) 不同，SSP通过将三重嵌入投影到语义子空间(例如超平面)上来描述实体描述和结构化三元组之间的更强相关性，如上文所述。</p><p>所提出的文本文本文本方法的另一个常见缺点是，它们主要关注描述，这是一个较长的自然语言文本，因此，其他类型的文本文本，例如名称、标签、标题等没有得到广泛考虑。此外，比较这些方法的另一种方法是查看它们的模型复杂性。表3显示了这些模型在参数数量方面的复杂性。</p><h4 id="CATT"><a href="#CATT" class="headerlink" title="CATT"></a>CATT</h4><p>通过知识图谱和实体描述之间的<strong>完全注意力</strong>来补全知识图谱</p><p>考虑到不同的实体在不同的三元组中具有不同的语义，提出了一种在完全注意（CATT）机制下，基于三元组学习知识图中实体描述信息的方法。这样，实体在不同的三元组中具有相应语义的不同表示。对于实体描述信息的编码，我们使用了三种深度学习方法，包括CNN、Bi LSTM和Transformer。实验结果表明，该方法在实体预测和关系预测两方面的性能都有显著提高。</p><p>在不同的三元组中，同一实体表达了不同的方面，关系的含义和属性，而仅通过KGs的结构信息无法区分差异。例如，三重 (Donald Trump，presidentOf，the United States) 中的实体 “唐纳德·特朗普” (Donald Trump，presidentOf，the United States) 强调实体的属性是 “的职业”。同时，在另一个三元组(Donald Trump，fatherOf，Ivanka Trump)  强调属性为 “的父母”。</p><p>贡献：</p><ol><li>为了学习文本语料库的表示，我们使用 CNN、Bi-LSTM 和 Transformer 三种深度学习方法对实体描述进行编码并分析结果。</li><li>我们提出了一个完整的注意力机制，强调同一实体在不同的三元组中具有不同方面的信息。由于引入了实体描述，它减少了噪音。</li><li>只有实体描述，链接预测已经达到了state-ofart的结果</li></ol><h5 id="KG表示"><a href="#KG表示" class="headerlink" title="KG表示"></a>KG表示</h5><p>$$<br>\boldsymbol{f}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t})=|\boldsymbol{h}+\boldsymbol{r}-\boldsymbol{t}|<em>{L</em>{1} / L_{2}}<br>$$</p><h5 id="实体描述"><a href="#实体描述" class="headerlink" title="实体描述"></a>实体描述</h5><p>编码得到的文本表示独立于KG的实体，限制了实体描述的表达能力。事实上，实体描述的感兴趣内容在不同的实体对中会有所不同。例如，“唐纳德特朗普”的描述与“总统”匹配时应强调与职业相关的描述性信息，而与“沃顿商学院”匹配时应强调与教育相关的描述性信息。</p><p>相同的实体具有在不同三元组中有不同的文本表示。<br>$$<br>\alpha_{i}=\operatorname{softmax}\left(h_{s} \cdot z_{i}\right)=\frac{\exp \left(h_{s} \cdot z_{i}\right)}{\sum_{j=1}^{n} \exp \left(h_{s} \cdot z_{j}\right)}\<br>\beta_{i}=\operatorname{softmax}\left(t_{s} \cdot z_{i}\right)=\frac{\exp \left(t_{s} \cdot z_{i}\right)}{\sum_{j=1}^{n} \exp \left(t_{s} \cdot z_{j}\right)}\<br>\gamma_{i}=\operatorname{softmax}\left(r \cdot z_{i}\right)=\frac{\exp \left(r \cdot z_{i}\right)}{\sum_{j=1}^{n} \exp \left(r \cdot z_{j}\right)}<br>$$<br>反映了头部实体、尾实体、关系在其描述中对每个文本表示的关注程度。<br>$$<br>a_{i}=\alpha_{i}+\beta_{i}+\gamma_{i}\<br>\widehat{\boldsymbol{a}<em>{\boldsymbol{\imath}}}=\frac{a</em>{\boldsymbol{i}}}{\sum_{\boldsymbol{j}=\mathbf{1}}^{\boldsymbol{i}} a_{\boldsymbol{j}}}\<br>\boldsymbol{d}=\sum_{j=1}^{m} \widehat{a_{j}} z_{j}<br>$$<br>那么$d$表示对应的的描述向量</p><h5 id="对齐模型"><a href="#对齐模型" class="headerlink" title="对齐模型"></a>对齐模型</h5><p>$$<br>\min <em>{\boldsymbol{\theta}} \sum</em>{(h, r, t) \in T} \sum_{\left(h^{\prime}, r^{\prime}, t^{\prime}\right) \in T^{\prime}} \max \left(\mathbf{0}, \boldsymbol{\delta}-\boldsymbol{f}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t})+\boldsymbol{f}\left(\boldsymbol{h}^{\prime}, \boldsymbol{r}^{\prime}, \boldsymbol{t}^{\prime}\right)\right)\<br>\boldsymbol{f}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t})=\boldsymbol{f}<em>{s s}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t})+\boldsymbol{f}</em>{s d}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t})+\boldsymbol{f}<em>{d s}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t})+\boldsymbol{f}</em>{d \boldsymbol{d}}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t})\<br>\boldsymbol{f}<em>{d s}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t})=-\left|\boldsymbol{h}</em>{d}+\boldsymbol{r}-\boldsymbol{t}<em>{s}\right|</em>{L_{1} / L_{2}} \<br>\boldsymbol{f}<em>{s d}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t})=-\left|\boldsymbol{h}</em>{s}+\boldsymbol{r}-\boldsymbol{t}<em>{d}\right|</em>{L_{1} / L_{2}}\<br>\boldsymbol{f}<em>{s s}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t}) =-\left|\boldsymbol{h}</em>{s}+\boldsymbol{r}-\boldsymbol{t}<em>{s}\right|</em>{L_{1} / L_{2}} \<br>\boldsymbol{f}<em>{d d}(\boldsymbol{h}, \boldsymbol{r}, \boldsymbol{t}) =-\left|\boldsymbol{h}</em>{\boldsymbol{d}}+\boldsymbol{r}-\boldsymbol{t}<em>{\boldsymbol{d}}\right|</em>{L_{1} / L_{2}}<br>$$</p><h4 id="textural-association"><a href="#textural-association" class="headerlink" title="textural association"></a>textural association</h4><p>要充分优化嵌入，还必须考虑更广泛可用的信息来源，例如文本。本文描述了一种<strong>无监督</strong>方法，通过使用关联词的嵌入来增强实体嵌入来合并文本信息。该方法不会修改知识图嵌入的优化目标，这允许它与现有的嵌入模型集成。考虑了两种不同形式的文本数据，针对每种情况提出了不同的嵌入增强。在第一种情况下，每个实体都有一个描述它的关联文本文档。在第二种情况下，文本文档不可用，而是实体作为非结构化文本片段语料库中的单词或短语出现。我们考虑一个非结构化语料库，它不直接链接到任何实体，但包含在任意位置的实体提及。</p><p>实验表明，当应用于许多不同的知识图嵌入模型时，这两种方法都可以改进链接预测任务。</p><p>在这项工作中，我们考虑了两种不同形式的文本数据，它们可能与知识图中的实体相关联，并提出了可以使用每种类型的数据增强现有知识图嵌入模型的方法。</p><p>我们首先考虑文本描述或文档与每个实体相关联的情况。例如，许多现实世界的实体和单词的描述可以很容易地从维基百科或字典中获得。我们为此场景提出了一个模型，该模型使用特定于关系的词向量加权平均值来表示特定实体。</p><h5 id="WWV"><a href="#WWV" class="headerlink" title="WWV"></a>WWV</h5><p>$$<br>\mathbf{e}<em>{i}=\frac{\mathbf{A}</em>{i} \mathbf{W}}{\left|\mathbf{A}<em>{i}\right|</em>{1}}\<br>\mathbf{e}<em>{i}^{\left(r</em>{j}\right)}=\frac{\left(\mathbf{A}<em>{i} \odot \mathbf{B}</em>{j}\right) \mathbf{W}}{\left|\mathbf{A}<em>{i} \odot \mathbf{B}</em>{j}\right|_{1}}<br>$$</p><p>例如transE<br>$$<br>f\left(e_{s}, r_{p}, e_{o}\right)=-\left|\mathbf{e}<em>{s}^{\left(r</em>{p}\right)}-\mathbf{r}<em>{p}+\mathbf{e}</em>{o}^{\left(r_{p}\right)}\right|_{1}<br>$$</p><h5 id="PE-WWV"><a href="#PE-WWV" class="headerlink" title="PE-WWV"></a>PE-WWV</h5><p>$$<br>B_{i j}=\frac{\exp \left(\mathbf{P}<em>{i} \mathbf{W}</em>{j}^{T}\right)}{\sum_{k=1}^{n_{w}} \exp \left(\mathbf{P}<em>{i} \mathbf{W}</em>{k}^{T}\right)}\<br>\mathbf{e}<em>{i}^{\left(r</em>{j}\right)}=\frac{\sum_{w_{k} \in \operatorname{text}\left(e_{i}\right)} A_{i j} \exp \left(\mathbf{P}<em>{j} \mathbf{W}</em>{k}^{T}\right) \mathbf{W}<em>{k}}{\sum</em>{w_{k} \in \operatorname{text}\left(e_{i}\right)} A_{i j} \exp \left(\mathbf{P}<em>{j} \mathbf{W}</em>{k}^{T}\right)}<br>$$</p><p>在第二种情况下，知识图中的实体没有关联的文档，而是在语料库中的各个点被提及。对于这种情况，我们提出了一个不同的模型，它首先通过在语料库上训练词嵌入 [Mikolov et al., 2013] 来获得实体的表示。生成的词向量基于实体名称与文本中其他词的共现提供实体的语义描述。然后将这些向量与实体嵌入相结合以增强表示。</p><h5 id="FeatureSum"><a href="#FeatureSum" class="headerlink" title="FeatureSum"></a>FeatureSum</h5><p>$$<br>\hat{\mathbf{e}}<em>{i}=\mathbf{e}</em>{i}+\mathbf{w}_{i} \mathbf{M}<br>$$</p><p>结论：</p><p>本文讨论了两种新方法，用于使用来自文本数据的信息来增强知识图中的实体嵌入。第一种方法将实体向量表示为与每个实体相关联的单词的直接函数，并且适用于以实体描述形式提供文本数据的任何时候。第二种方法在文本文档上训练 word2vec 算法，并将它为实体名称学习的特征添加到原始实体特征向量中。经验结果表明，如果文本数据具有足够高的质量，那么与没有文本的嵌入和合并文本的替代方法相比，这两种方法都可以提高许多不同嵌入模型的链接预测准确性。</p><h4 id="open-world-extension-for-KGC"><a href="#open-world-extension-for-KGC" class="headerlink" title="open-world extension for KGC"></a>open-world extension for KGC</h4><p>提出了对基于嵌入的知识图完成模型的新扩展，使它们能够执行<strong>开放世界链接预测</strong>，即根据文本描述预测训练中未见过的实体的事实。我们的模型结合了从知识图谱中学习的常规链接预测模型和从文本语料库中学习的词嵌入。在独立训练之后，我们学习了一种转换，将实体名称和描述的嵌入映射到基于图的嵌入空间。<br>在包括 FB20k、DBPedia50k 和我们的新数据集 FB15k-237-OWE 在内的多个数据集的实验中，我们展示了具有竞争力的结果。特别是，即使文本描述稀缺，我们的方法也能利用完整的知识图结构，不需要对图和文本进行联合训练，并且可以应用于任何基于嵌入的链接预测模型，例如 TransE、ComplEx 和 DistMult<br>$$<br>\operatorname{score}(h, r, t)=\phi\left(u_{h}, u_{r}, u_{t}\right)<br>$$</p><p>$$<br>v_{h}:=\Psi^{a g g}\left(v_{w_{1}}, v_{w_{2}}, \ldots, v_{w_{n}}\right)<br>$$</p><p>$$<br>\Psi^{\operatorname{map}}\left(v_{h}\right) \approx u_{h}<br>$$</p><p>$$<br>\operatorname{score}(h, r, t)=\phi\left(\Psi^{\operatorname{map}}\left(v_{h}\right), u_{r}, u_{t}\right)<br>$$</p><h4 id="EDGE"><a href="#EDGE" class="headerlink" title="EDGE"></a>EDGE</h4><p>在本文中，提出了实体描述引导嵌入（EDGE），这是一种利用实体描述的语义引导学习知识图表示的新方法。 EDGE 使嵌入模型能够同时学习 1) 在给定 KG 中直接观察到的知识三元组，以及 2) 具有关于这些实体的丰富语义信息的实体描述。在学习过程中，EDGE对实体描述的语义进行编码，以增强对知识图嵌入的学习，并结合学习到的KG嵌入，将其对应的词嵌入约束在实体描述中。<br>通过这个交互过程，实体描述的语义可以更好地转移到学习的 KG 嵌入中。我们评估 EDGE 在 Freebase 和 WordNet 上的链接预测和实体分类。实验结果表明：1）通过注入实体描述，EDGE 在最先进的基线上实现了显着且一致的改进； 2）与之前研究的那些一次性注入方案相比，交互式引导策略最大化了实体描述在 KG 嵌入中的效用，并且确实实现了更好的性能。</p><h5 id="基本嵌入模型"><a href="#基本嵌入模型" class="headerlink" title="基本嵌入模型"></a>基本嵌入模型</h5><p>transE<br>$$<br>E\left(e_{h}, r, e_{t}\right)=\left|\boldsymbol{e}<em>{\boldsymbol{h}}+\boldsymbol{r}-\boldsymbol{e}</em>{\boldsymbol{t}}\right|<br>$$</p><h5 id="分层-BiLSTM-最大池化编码器"><a href="#分层-BiLSTM-最大池化编码器" class="headerlink" title="分层 BiLSTM 最大池化编码器"></a>分层 BiLSTM 最大池化编码器</h5><p>先经过Word2vec预训练词向量处理，</p><p>句子中的词序列$\left(w_{1}, \ldots, w_{T}\right)$，对应的输出$\left(h_{1}, \ldots, h_{T}\right)$，其中$h_{t}$是两者之间的串联<br>$$<br>h_{t}=\left[\overrightarrow{h_{t}}, \overleftarrow{h_{t}}\right]\<br>\overrightarrow{h_{t}}=\overrightarrow{L S T M}<em>{t}\left(w</em>{1}, \ldots w_{T}\right)\<br>\overleftarrow{h_{t}}=\overleftarrow{L S T M_{t}}\left(w_{1}, \ldots w_{T}\right)<br>$$<br>最大池化层用于在隐藏单元$\left(h_{1}, \ldots, h_{T}\right)$上产生每个维度的最大值，同时它也具有与$h_{t}$相同的维度。将分层的BiLSTM 最大池作为我们的编码器，以提高神经网络对每个单词进行<strong>编码</strong>和<strong>记忆</strong>的能力。具体来说，我们假设每一层神经网络都可以重新读取输入描述。</p><p>我们将三层 BiLSTM 最大池化网络作为我们的层次结构。我们用上一层的最终隐藏和单元状态初始化第二和第三层 BiLSTM 层的初始隐藏状态和单元状态。此外，通过每个 BiLSTM 层之后的最大池化，我们在隐藏单元的每个维度上取最大值。最终的输出嵌入$e_{d}$是所有三个最大池化向量$u_{1},u_{2},u_{3}$的平均值。</p><h5 id="知识约束方法"><a href="#知识约束方法" class="headerlink" title="知识约束方法"></a>知识约束方法</h5><p>为了从实体描述中实现这种交互式引导，我们采用约束模型并使用欧几里得距离来定义一对向量之间的距离。</p><p>具体来说，我们希望描述中与实体相关的词嵌入$w_{i}$对学习的实体嵌入 $e_{i}$及其邻居$e_{j}$是封闭的。$\forall j$在给定的 KG 关系$(e_{i},e_{j})\in R$;以下优化问题变为<br>$$<br>\min \sum_{i=1}^{|V|}\left[\alpha_{i}\left|w_{i}-e_{i}\right|^{2}+\sum_{\left(e_{i}, e_{j}\right) \in R} \beta_{i j}\left|w_{i}-e_{j}\right|^{2}\right]<br>$$<br>其中 V 是单词的词汇量，α 和 β 是用于控制相对强度的可调整值。这个优化问题是凸的，它的解可以通过求解一个线性方程组来找到。为了改进词嵌入$w_{i}$，更新过程是<br>$$<br>\left(\alpha_{i}+\sum_{\left(e_{i}, e_{j}\right) \in R} \beta_{i j}\right) w_{i}-\alpha_{i} e_{i}-\sum_{\left(e_{i}, e_{j}\right) \in R} \beta_{i j} e_{j}=0<br>$$<br>那么更新后的词嵌入$w_{i}$是<br>$$<br>w_{i}=\frac{\sum_{\left(e_{i}, e_{j}\right) \in R} \beta_{i j} e_{j}+\alpha_{i} e_{i}}{\sum_{\left(e_{j}, e_{j}\right) \in R} \beta_{i j}+\alpha_{i}}<br>$$<br>上面描述的这种改造方法是模块化的，这意味着它可以应用于从任何模型获得的词嵌入。</p><h5 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h5><p>由于结构和实体描述都可以为 KG 嵌入学习提供有用且丰富的语义信息，因此我们将它们整合到一个联合表示中。对于实体 e，我们提出了两种嵌入来表示它，包括$e^{s}$，e 的结构嵌入$e^{d}$，来自实体描述的编码表示。为了结合这两种信息，我们在结合实体的结构表示和描述中的实体表示时应用了门控机制。通过$e^{s}$和$e^{d}$的组合得到最终的联合实体嵌入 e。<br>$$<br>e=g_{e} \odot \mathrm{e}^{s}+\left(1-g_{e}\right) \odot e^{d}<br>$$<br>考虑到每个维度包含的信息之间的差异，我们也将 ge 设置为向量。为了约束 ge 的每个元素的值在 [0, 1] 中，我们通过逻辑 sigmoid 函数计算门<br>$$<br>\mathrm{g}<em>{e}=\sigma\left(\tilde{\mathrm{g}</em>{e}}\right)<br>$$<br>其中$\tilde{\mathrm{g}<em>{e}} \in \mathbb{R}^{d}$是一个实值向量，一旦$\tilde{\mathrm{g}</em>{e}}$被学习，它就保持不变。我们用于训练的目标函数是最小化以下得分函数<br>$$<br>\begin{array}{}<br>L=\sum_{\left(e_{h}, r, e_{t}\right) \in O} \sum_{\left(e_{h}^{\prime}, r^{\prime}, e_{t}^{\prime}\right) \in O^{\prime}} \max \left(\gamma+d\left(\boldsymbol{e}<em>{\boldsymbol{h}}+\boldsymbol{r}, \boldsymbol{e}</em>{\boldsymbol{t}}\right)\right.\left.-d\left(\boldsymbol{e}<em>{\boldsymbol{h}}^{\prime}+\boldsymbol{r}^{\prime}, \boldsymbol{e}</em>{\boldsymbol{t}}^{\prime}\right), 0\right)\<br>\begin{aligned}<br>O^{\prime}=\left{\left(e_{h}^{\prime}, r, e_{t}\right) \mid e_{h}^{\prime} \in E\right} \cup &amp;\left{\left(e_{h}, r, e_{t}^{\prime}\right) \mid e_{t}^{\prime} \in E\right}\cup\left{\left(e_{h}, r^{\prime}, e_{t}\right) \mid r^{\prime} \in R\right}<br>\end{aligned}<br>\end{array}<br>$$</p><h4 id="TransW"><a href="#TransW" class="headerlink" title="TransW"></a>TransW</h4><p>本文提出了一种称为 TransW 的新方法，旨在通过使用<strong>词嵌入组合知识图嵌入</strong>来超越当前的工作。鉴于实体或关系包含一个或多个单词（经常）这一事实，学习从单词嵌入空间到知识嵌入空间的映射函数是明智的，它显示了如何使用人类单词构建实体。更重要的是，使用词嵌入组合知识嵌入使得处理新出现的新事实（新实体或关系）成为可能。使用三个公共数据集(WN11,FB13,FB15K)的实验结果显示了所提出的 TransW 的一致性和优异性能。</p><p>在 TransW 中，每个实体或关系都以词嵌入的线性组合形式表示。对于一个三元组$(h,r,t)$及其嵌入$(\boldsymbol{h},\boldsymbol{r},\boldsymbol{t})$，假设 h, r 和 t 中的词数分别为 n, p 和 m，则$(h,r,t)$可以是用他们的词嵌入表示：<br>$$<br>\begin{aligned}<br>\mathbf{h} &amp;=\sum_{i=0}^{\mathrm{n}} \mathbf{h}<em>{i} \otimes \mathbf{w}</em>{h i}+\mathbf{b}<em>{h} \<br>\mathbf{t} &amp;=\sum</em>{i=0}^{\mathrm{m}} \mathbf{t}<em>{i} \otimes \mathbf{w}</em>{t i}+\mathbf{b}<em>{t} \<br>\mathbf{r} &amp;=\sum</em>{i=0}^{\mathrm{p}} \mathbf{r}<em>{i} \otimes \mathbf{w}</em>{r i}+\mathbf{b}<em>{r}<br>\end{aligned}<br>$$<br>其中$h</em>{i},t_{i},r_{i} \in \Bbb W$分别是对应的h, r, t中第i个词的词嵌入，⊗表示哈达玛(Hadamard)积，$w_{hi},w_{ti},w_{ri}$,是h, r和t的第i个连接向量，$b_{h},b_{t},b_{r} \in \Bbb R^k$ 分别是实体 h 和 t 以及关系 r 的偏置参数。<br>$$<br>L=\sum_{\xi \in \Delta} \sum_{\xi^{\prime} \in \Delta^{\prime}}\left[\gamma+f_{r}\left(\xi^{\prime}\right)-f_{r}(\xi)\right]_{+}<br>$$</p><h2 id="4-2-具有数字文本的模型"><a href="#4-2-具有数字文本的模型" class="headerlink" title="4.2 具有数字文本的模型"></a>4.2 具有数字文本的模型</h2>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综述 </tag>
            
            <tag> KGE </tag>
            
            <tag> 无结构信息表示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 学习</title>
      <link href="/2022/01/04/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/First/"/>
      <url>/2022/01/04/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/First/</url>
      
        <content type="html"><![CDATA[<p>Markdown 的基本语法规则。</p><span id="more"></span><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul><li>列表1</li><li>列表2<br>  a 子列表哦<br>  b 字列表嗯？</li></ul><p><em>字体倾斜了吗？</em></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 使用心得 </tag>
            
            <tag> 博客 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/1970/01/01/hello-world/"/>
      <url>/1970/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 使用初体验</title>
      <link href="/1970/01/01/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/hello-world/"/>
      <url>/1970/01/01/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><p>111111</p><p>22222</p><h2 id="安装-nodejs-和-Git"><a href="#安装-nodejs-和-Git" class="headerlink" title="安装 nodejs 和 Git"></a>安装 nodejs 和 Git</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
