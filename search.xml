<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GDB</title>
      <link href="/2023/06/18/gdb/"/>
      <url>/2023/06/18/gdb/</url>
      
        <content type="html"><![CDATA[<h1 id="常用gdb调试命令汇总"><a href="#常用gdb调试命令汇总" class="headerlink" title="常用gdb调试命令汇总"></a>常用gdb调试命令汇总</h1><font color="#dd0000">浅红色文字：</font> <h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="将文件编译为debug版本"><a href="#将文件编译为debug版本" class="headerlink" title="将文件编译为debug版本"></a>将文件编译为debug版本</h3><p>在linux系统下，默认生成的可执行程序是release版，但是调试需要debug版本。需要在gcc或g++命令后加上限定符-g。这样生成的程序就是debug版本的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc/g++ -g test.c/test.cpp -o test</span><br></pre></td></tr></table></figure><h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><p>gdp会自动记录最近的命令，如果没有输入其他命令，可以按enter键继续执行最近命令。</p><h3 id="查看代码内容-l"><a href="#查看代码内容-l" class="headerlink" title="查看代码内容(l)"></a>查看代码内容(l)</h3><p><code>l</code> 命令是用来查看代码内容的。使用方式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l 行号   <span class="comment">//默认生成10行，当指定行号时，会生成以指定行号为中间的共10行代码</span></span><br></pre></td></tr></table></figure><h3 id="开始调试-r"><a href="#开始调试-r" class="headerlink" title="开始调试(r)"></a>开始调试(r)</h3><p><code>r</code>命令用来开始代码调试工作，使用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r     <span class="comment">//开始调试，直到程序结束或遇到断点暂停。在调试过程中，再次使用r命令会重新开始调试。</span></span><br></pre></td></tr></table></figure><h3 id="查看当前调试位置-where"><a href="#查看当前调试位置-where" class="headerlink" title="查看当前调试位置(where)"></a>查看当前调试位置(where)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where   <span class="comment">//查看此时执行位置</span></span><br></pre></td></tr></table></figure><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="打断点-b"><a href="#打断点-b" class="headerlink" title="打断点(b)"></a>打断点(b)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b 行号    <span class="comment">//在指定行打断点</span></span><br></pre></td></tr></table></figure><h3 id="显示断点-info-b"><a href="#显示断点-info-b" class="headerlink" title="显示断点(info b)"></a>显示断点(info b)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info b    <span class="comment">//显示全部断点信息，也可以在b后加编号显示指定断点</span></span><br></pre></td></tr></table></figure><h3 id="删除断点-d"><a href="#删除断点-d" class="headerlink" title="删除断点(d)"></a>删除断点(d)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d 断点编号 <span class="comment">//删除指定断点，不加编号则删除全部</span></span><br></pre></td></tr></table></figure><p>注意：断点编号不是行号，可以使用<code>info</code>来查看。 </p><h3 id="调试至下一个断点-c"><a href="#调试至下一个断点-c" class="headerlink" title="调试至下一个断点(c)"></a>调试至下一个断点(c)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c   <span class="comment">//从当前调试位置直接执行到下一个断点处</span></span><br></pre></td></tr></table></figure><h3 id="关闭断点-disable"><a href="#关闭断点-disable" class="headerlink" title="关闭断点(disable)"></a>关闭断点(disable)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable 断点编号  <span class="comment">// 关闭断点 </span></span><br></pre></td></tr></table></figure><p>注意：关闭断点并不是删除断点。只是在调试时不会在该处暂停，但是断点依旧存在。 使用<code>info b</code>即可看断点关闭与否。</p><h3 id="打开断点-enable"><a href="#打开断点-enable" class="headerlink" title="打开断点(enable)"></a>打开断点(enable)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable 断点编号  <span class="comment">//打开断点</span></span><br></pre></td></tr></table></figure><h2 id="打印变量和数组"><a href="#打印变量和数组" class="headerlink" title="打印变量和数组"></a>打印变量和数组</h2><h3 id="打印某变量值-p"><a href="#打印某变量值-p" class="headerlink" title="打印某变量值(p)"></a>打印某变量值(p)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p 变量    <span class="comment">//打印对应的变量值，打印地址直接加取地址符&amp;即可</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这种方法只能显示一次变量值，当继续调试时变量不再显示。如果我们需要打印数组的值，输入数组名即可。</p><h3 id="常显示某变量-display"><a href="#常显示某变量-display" class="headerlink" title="常显示某变量(display)"></a>常显示某变量(display)</h3><p>如果我们需要在调试中一直显示某个变量的值，那么就需要<code>display</code>命令了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display 变量   <span class="comment">//常显示指定变量值，使用方式与p一致 </span></span><br></pre></td></tr></table></figure><h3 id="删除常显示-undisplay"><a href="#删除常显示-undisplay" class="headerlink" title="删除常显示(undisplay)"></a>删除常显示(undisplay)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undisplay 常显示变量编号  <span class="comment">//删除指定常显示变量 </span></span><br></pre></td></tr></table></figure><p>需要注意的是，不能直接写变量名，变量编号使用 <code>info display</code>即可知道。</p><h2 id="逐语句、逐过程调试"><a href="#逐语句、逐过程调试" class="headerlink" title="逐语句、逐过程调试"></a>逐语句、逐过程调试</h2><h3 id="逐语句调试-step"><a href="#逐语句调试-step" class="headerlink" title="逐语句调试(step)"></a>逐语句调试(step)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s    <span class="comment">//逐语句调试。相当于vs中的F11</span></span><br></pre></td></tr></table></figure><h3 id="逐过程调试-next"><a href="#逐过程调试-next" class="headerlink" title="逐过程调试(next)"></a>逐过程调试(next)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n    <span class="comment">//逐过程调试。相当于vs中的F10 </span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="查看当前堆栈调用-bt"><a href="#查看当前堆栈调用-bt" class="headerlink" title="查看当前堆栈调用(bt)"></a>查看当前堆栈调用(bt)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bt   <span class="comment">//查看当前堆栈调用 </span></span><br></pre></td></tr></table></figure><h3 id="直接跑完当前函数-finish"><a href="#直接跑完当前函数-finish" class="headerlink" title="直接跑完当前函数(finish)"></a>直接跑完当前函数(finish)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finish  <span class="comment">//可以直接跑完当前函数，若函数只有一层则直接跑完函数。 </span></span><br></pre></td></tr></table></figure><p>如果是函数递归调用，当还没开始递归时，finish会执行完整个函数，自动走完全部递归过程（前提无断点）。</p><p>当已经递归调用后，在哪一层递归finish就会返回至它的前一层。 </p><h3 id="执行至指定行-until"><a href="#执行至指定行-until" class="headerlink" title="执行至指定行(until)"></a>执行至指定行(until)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">until 行号   <span class="comment">//执行至指定行</span></span><br></pre></td></tr></table></figure><p>until也可以在main函数中使用，但一般until用于小范围跳动。</p><h2 id="反汇编-disassemble"><a href="#反汇编-disassemble" class="headerlink" title="反汇编(disassemble)"></a>反汇编(disassemble)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble    <span class="comment">//查看指令附近区域的反汇编</span></span><br></pre></td></tr></table></figure><h2 id="在gdb界面执行linux指令-shell"><a href="#在gdb界面执行linux指令-shell" class="headerlink" title="在gdb界面执行linux指令(shell)"></a>在gdb界面执行linux指令(shell)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell 指令    <span class="comment">//在gdb界面中执行linux指令</span></span><br></pre></td></tr></table></figure><h2 id="退出gdb-quit"><a href="#退出gdb-quit" class="headerlink" title="退出gdb(quit)"></a>退出gdb(quit)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（gdb) quit</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/weixin_61857742/article/details/126067930">linux—常用gdb调试命令汇总</a></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode环境配置</title>
      <link href="/2023/06/13/VScode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/06/13/VScode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="VScode环境配置"><a href="#VScode环境配置" class="headerlink" title="VScode环境配置"></a>VScode环境配置</h1><h2 id="VScode连接远程服务器"><a href="#VScode连接远程服务器" class="headerlink" title="VScode连接远程服务器"></a>VScode连接远程服务器</h2><blockquote><p><a href="https://blog.csdn.net/zhaxun/article/details/120568402">vscode连接远程服务器（傻瓜式教学）</a></p><p><a href="https://www.jianshu.com/p/e8f377f498df?u_atoken=814c1441-f130-4152-8a33-ba4686e92491&amp;u_asession=01HhO8yePcyXAoTumjfJpJBNaY8hNlFq4Gfx9pM9yaQj3Vq1i-pPsBH-1AnOBUSrmlX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K80sDZY0Kx17FxwgeXSptQCyuYfe7vWV-zsHJifFo5DumBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=05w-6owfGv64hvnGs4SAf_pNF4Ba9OweWjx4qG9e9lVR36Dh8LtRohJtELtlwi0KQNDSrHmZJd4Tr6G8B2yrAgXVDnQAx2Sl9fn5BgHcmbLsatBgwYPcDqa4vt7uMVDav_VcQEtlzaiDGT4Ercwkpp8V7Ia7GL7OyoruxPhYQJP1D9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzXiOJ4OFQidhngz3iDrCq39TRA8oRwjzJwrS9Ypm1oV2fqft3yiexPr1Pj5ASov3mu3h9VXwMyh6PgyDIVSG1W89moljIgTqgExbzB45obxOrxm8QxhxX4dhzKpuzUjLm0hubwTFShruT4Sd3-f22eudOWMEwOEFp6vKm8jMpz0mmWspDxyAEEo4kbsryBKb9Q&amp;u_aref=fjJVa17a6u9XWSIOgJ1T%2BYePR8E%3D">VScode远程连接服务器写Jupyter Notebook或python script</a></p><p><a href="https://blog.csdn.net/weixin_50952710/article/details/128292821">VSCode远程连接免密登录</a></p><p><a href="https://blog.csdn.net/weixin_43799388/article/details/127022705">【开发工具】VScode连接远程服务器+设置免密登录</a></p></blockquote><p>安装 Remote-SSH 插件。</p><hr><h2 id="VScode-使用-jupyter"><a href="#VScode-使用-jupyter" class="headerlink" title="VScode 使用 jupyter"></a>VScode 使用 jupyter</h2><blockquote><p><a href="https://blog.csdn.net/buzhidao2333shuosha/article/details/120808445">Vscode使用Jupyter</a></p></blockquote><p>安装插件<br>Jupyter ：提供Jupyter基本支持<br>Jupyter Keymap : 提供Jupyter快捷键支持<br>Jupyter Notebook Renderer ：渲染和解析器，渲染例如gif、png、plotly等格式</p><p>注：只安装第一个即可，会一起捆绑安装。</p><hr><h2 id="Jupyter-Notebook服务器配置"><a href="#Jupyter-Notebook服务器配置" class="headerlink" title="Jupyter Notebook服务器配置"></a>Jupyter Notebook服务器配置</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/435223393">Jupyter Notebook服务器配置</a></p><p><a href="https://blog.csdn.net/qq_45056135/article/details/123960321">服务器配置Jupyter notebook/Jupyter notebook连接远程服务器</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装好jupyter</span></span><br><span class="line">pip install jupyter</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成配置文件</span></span><br><span class="line">jupyter notebook --generate-config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置Jupyter notebook密码</span></span><br><span class="line">jupyter notebook password</span><br></pre></td></tr></table></figure><p>/home/<code>username</code>/.jupyter/jupyter_notebook_config.py 加入如下配置信息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.allow_remote_access = <span class="literal">True</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">c.NotebookApp.allow_root = <span class="literal">True</span></span><br><span class="line">c.NotebookApp.port = <span class="number">8888</span> <span class="comment"># 端口可以更改</span></span><br></pre></td></tr></table></figure><p>后续即可访问！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VScode </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络相关</title>
      <link href="/2023/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络相关"><a href="#计算机网络相关" class="headerlink" title="计算机网络相关"></a>计算机网络相关</h1><blockquote><p><a href="https://mp.weixin.qq.com/s/0Cfrm2d11hQUt0dmBpO0lA">计算机网络知识点大全！（太详细了）</a></p><p><a href="https://mp.weixin.qq.com/s/LsprTTG_YIO1VeXwppzdxA">Wireshark 的抓包和分析，看这篇就够了！</a></p><p><a href="https://mp.weixin.qq.com/s/AtWpCLjXyguaDkCelZqCFQ">36张图，一次性补全网络基础知识</a></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NetWork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2023/03/10/%E5%88%B7%E9%A2%98_%E6%A0%91/"/>
      <url>/2023/03/10/%E5%88%B7%E9%A2%98_%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><p>二叉树有两种主要的形式：满二叉树和完全二叉树。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。如图所示：</p><p><img src="https://raw.githubusercontent.com/chaoyuan666/tuChuang/master/blog/image-20230618184003450.png" style="zoom:50%;" /></p><p>这棵二叉树为满二叉树，也可以说深度为 $k$，有 $2^k-1$ 个节点的二叉树。</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>什么是完全二叉树？</p><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</p><p><img src="https://raw.githubusercontent.com/chaoyuan666/tuChuang/master/blog/20230618184420.png" alt=""></p><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>下面这两棵树都是搜索树</p><p><img src="https://raw.githubusercontent.com/chaoyuan666/tuChuang/master/blog/20230618184632.png" alt=""></p><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。如图：</p><p><img src="https://raw.githubusercontent.com/chaoyuan666/tuChuang/master/blog/20230618184736.png" alt=""></p><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p><p>顺序存储其实就是用数组来存储二叉树，顺序存储的方式如图：</p><p><img src="https://raw.githubusercontent.com/chaoyuan666/tuChuang/master/blog/20230618185018.png" style="zoom:50%;" /></p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong></p><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>在深度优先遍历中：有三个顺序，前中后序遍历。</p><p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住前中后序指的就是中间节点的位置就可以了。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p><img src="https://raw.githubusercontent.com/chaoyuan666/tuChuang/master/blog/20230618185340.png" alt=""></p><p>二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p><p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><p><strong>这里其实我们又了解了栈与队列的一个应用场景了。</strong></p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p>递归算法的三个要素。<strong>每次写递归，都按照这三要素来写</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">orderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">traversal</span>(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* ret, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    ir(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    ret[(*returnSize)++]=root-&gt;val;</span><br><span class="line">    preOrder(root-&gt;left, ret, returnSize);</span><br><span class="line">    preOrder(root-&gt;right, ret, returnSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">preorderTraversal</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span>* ret = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    preOrder(root, ret, returnSize);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* node, <span class="type">int</span>* ret, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(node-&gt;left, ret, returnSize);</span><br><span class="line">    ret[(*returnSize)++] = node-&gt;val;</span><br><span class="line">    inOrder(node-&gt;right, ret, returnSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">inorderTraversal</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span>* ret = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    inOrder(root, ret, returnSize);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode* node, <span class="type">int</span>* ret, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postOrder(node-&gt;left, ret, returnSize);</span><br><span class="line">    postOrder(node-&gt;right, ret, returnSize);</span><br><span class="line">    ret[(*returnSize)++] = node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">postorderTraversal</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span>* ret= (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    postOrder(root, ret, returnSize);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><h3 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h3><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时会发现貌似使用迭代法写出前序遍历并不难，确实不难。</p><p><strong>此时是不是想改一点前序遍历代码顺序就把中序遍历搞出来了？</strong></p><p>其实还真不行！</p><p>但接下来，<strong>再用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。</strong></p><h3 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="中序遍历（迭代法）"></a>中序遍历（迭代法）</h3><p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="后序遍历（迭代法）"></a>后序遍历（迭代法）</h3><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。</p><p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p><p>上面这句话，可能一些同学不太理解，建议自己亲手用迭代法，先写出来前序，再试试能不能写出中序，就能理解了。</p><p><strong>那么问题又来了，难道 二叉树前后中序遍历的迭代法实现，就不能风格统一么（即前序遍历 改变代码顺序就可以实现中序 和 后序）？</strong></p><p>当然可以，这种写法，还不是很好理解，我们将在下一章里重点讲解，敬请期待！</p><h2 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h2><p>其实<strong>针对三种遍历方式，使用迭代法是可以写出统一风格的代码！</strong></p><p><strong>重头戏来了，接下来介绍一下统一写法。</strong></p><p>我们以中序遍历为例，<strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。</p><p><strong>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.push(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.push(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.top();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代法前序遍历"><a href="#迭代法前序遍历" class="headerlink" title="迭代法前序遍历"></a>迭代法前序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代法后序遍历"><a href="#迭代法后序遍历" class="headerlink" title="迭代法后序遍历"></a>迭代法后序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h2><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归法  ???</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录</title>
      <link href="/2022/07/20/%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/07/20/%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><p>搭建Github图床 </p><blockquote><p><a href="https://www.cnblogs.com/linshengqian/p/16612571.html">https://www.cnblogs.com/linshengqian/p/16612571.html</a></p></blockquote><p>【状态机】这3种优雅的嵌入式软件架构，你值得拥有！</p><blockquote><p><a href="https://mp.weixin.qq.com/s/Xpd4TgL2gx_iUuBWfPtWpg">https://mp.weixin.qq.com/s/Xpd4TgL2gx_iUuBWfPtWpg</a></p></blockquote><p>C 语言里面的 extern “C” ，并没有那么简单！</p><blockquote><p><a href="https://mp.weixin.qq.com/s/QA9Kn-ZwXQNv7YODWsuWQQ">https://mp.weixin.qq.com/s/QA9Kn-ZwXQNv7YODWsuWQQ</a></p></blockquote><p>分享 10 道有趣的嵌入式 C 语言面试题及答案</p><blockquote><p><a href="https://mp.weixin.qq.com/s/BfsdB_t0uN3gMpK9jJg6Yg">https://mp.weixin.qq.com/s/BfsdB_t0uN3gMpK9jJg6Yg</a></p></blockquote><p>当你想使用 RTOS 的时候，需要先注意些什么？</p><blockquote><p><a href="https://mp.weixin.qq.com/s/0xRyFNHGzhwDCazgnD-KKg">https://mp.weixin.qq.com/s/0xRyFNHGzhwDCazgnD-KKg</a></p></blockquote><p>20个嵌入式工程师常见面试题（内附答案）</p><blockquote><p><a href="https://mp.weixin.qq.com/s/NFa4RZo2NvEcvONBS7vWsw">https://mp.weixin.qq.com/s/NFa4RZo2NvEcvONBS7vWsw</a></p></blockquote><p>单片机到linux</p><blockquote><p><a href="https://mp.weixin.qq.com/s/PcMD7f8oRDBCn9zBfxUkEw">https://mp.weixin.qq.com/s/PcMD7f8oRDBCn9zBfxUkEw</a></p></blockquote><p>STM32 单片机到底是如何实现软硬件结合？</p><blockquote><p><a href="https://mp.weixin.qq.com/s/O3DJTMuNGReYCpAb2y2kcw">https://mp.weixin.qq.com/s/O3DJTMuNGReYCpAb2y2kcw</a></p></blockquote><p>STM32 嵌入式面试知识点</p><blockquote><p><a href="https://mp.weixin.qq.com/s/lTYl3n4Rv_b0LuAo5oTSpQ">https://mp.weixin.qq.com/s/lTYl3n4Rv_b0LuAo5oTSpQ</a></p></blockquote><p>在vscode上编写stm32程序</p><blockquote><p><a href="https://blog.csdn.net/weixin_48896613/article/details/125737673">https://blog.csdn.net/weixin_48896613/article/details/125737673</a></p></blockquote><p>一文剖析 Linux 内核的内存管理</p><blockquote><p><a href="https://mp.weixin.qq.com/s/9qgrQ5WkHNcPmLTY3pyrpg">https://mp.weixin.qq.com/s/9qgrQ5WkHNcPmLTY3pyrpg</a></p></blockquote><p>关于Linux内存管理的详细介绍，这篇万字长文值得你的收藏点赞！</p><blockquote><p><a href="https://mp.weixin.qq.com/s/2GgkksTIo-wilfAG-0q22Q">https://mp.weixin.qq.com/s/2GgkksTIo-wilfAG-0q22Q</a></p></blockquote><p>linux设备模型之kset/kobj/ktype分析</p><blockquote><p><a href="https://mp.weixin.qq.com/s/WET4m1Nd2vpvojKjgmRkbw">https://mp.weixin.qq.com/s/WET4m1Nd2vpvojKjgmRkbw</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 五分钟教程</title>
      <link href="/2022/02/14/Git%20%E4%BA%94%E5%88%86%E9%92%9F%E6%95%99%E7%A8%8B/"/>
      <url>/2022/02/14/Git%20%E4%BA%94%E5%88%86%E9%92%9F%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><span id="more"></span><p>使用Git前，需要先建立一个仓库(repository)。您可以使用一个已经存在的目录作为Git仓库或创建一个空目录。使用您当前目录作为Git仓库，我们只需使它初始化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>使用我们指定目录作为Git仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure><p>从现在开始，我们将假设您在Git仓库根目录下，除非另有说明。</p><h1 id="1-添加新文件"><a href="#1-添加新文件" class="headerlink" title="1. 添加新文件"></a>1. 添加新文件</h1><p>我们有一个仓库，但什么也没有，可以使用add命令添加文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br></pre></td></tr></table></figure><p>可以使用add… 继续添加任务文件。</p><h1 id="2-提交版本"><a href="#2-提交版本" class="headerlink" title="2. 提交版本"></a>2. 提交版本</h1><p>现在我们已经添加了这些文件，我们希望它们能够真正被保存在Git仓库。为此，我们将它们提交到仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Adding files&quot;</span><br></pre></td></tr></table></figure><p>如果您不使用-m，会出现编辑器来让你写自己的注释信息。</p><p>当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;Changed some files&quot;</span><br></pre></td></tr></table></figure><p>git commit 命令的-a选项可将所有<strong>被修改或者已删除的且已经被git管理的文档</strong>提交到仓库中。</p><font color=red >千万注意，-a不会造成新文件被提交，只能修改。</font><h1 id="3-发布版本"><a href="#3-发布版本" class="headerlink" title="3. 发布版本"></a>3. 发布版本</h1><p>我们先从服务器克隆一个库并上传。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://example.com/~/www/project.git</span><br></pre></td></tr></table></figure><p>现在我们修改之后可以进行推送到服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push ssh://example.com/~/www/project.git</span><br></pre></td></tr></table></figure><h1 id="4-取回更新"><a href="#4-取回更新" class="headerlink" title="4. 取回更新"></a>4. 取回更新</h1><p>如果您已经按上面的进行push，下面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>从非默认位置更新到指定的url。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull http://git.example.com/project.git</span><br></pre></td></tr></table></figure><h1 id="5-删除"><a href="#5-删除" class="headerlink" title="5.删除"></a>5.删除</h1><p>如何你想从资源库中删除文件，我们使用rm。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm file</span><br></pre></td></tr></table></figure><h1 id="6-分支与合并"><a href="#6-分支与合并" class="headerlink" title="6.分支与合并"></a>6.分支与合并</h1><p>分支在本地完成，速度快。要创建一个新的分支，我们使用branch命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></figure><p>branch命令不会将我们带入分支，只是创建一个新分支。所以我们使用checkout命令来更改分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p>第一个分支，或主分支，被称为”master”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>对其他分支的更改不会反映在主分支上。如果想将更改提交到主分支，则需切换回master分支，然后使用合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>如果您想删除分支，我们使用-d标识。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br></pre></td></tr></table></figure><p>来源：<a href="https://www.runoob.com/w3cnote/git-five-minutes-tutorial.html">Git 五分钟教程（菜鸟教程）</a></p><hr><p>完整版git教程！</p><h1 id="1-Git-创建仓库"><a href="#1-Git-创建仓库" class="headerlink" title="1. Git 创建仓库"></a>1. Git 创建仓库</h1><h2 id="1-1-git-init"><a href="#1-1-git-init" class="headerlink" title="1.1. git init"></a>1.1. git init</h2><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。</p><p>在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用当前目录作为 Git 仓库，我们只需使它初始化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为Git仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure><p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *.c</span><br><span class="line">git add README</span><br><span class="line">git commit -m &#x27;初始化项目版本&#x27;</span><br></pre></td></tr></table></figure><p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><blockquote><p><strong>注：</strong> 在 Linux 系统中，commit 信息使用单引号，Windows 系统，commit 信息使用双引号。</p></blockquote><h2 id="1-2-git-clone"><a href="#1-2-git-clone" class="headerlink" title="1.2. git clone"></a>1.2. git clone</h2><p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似 <strong>svn checkout</strong>）。</p><p>克隆仓库的命令格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>repo:</strong> Git 仓库。</li><li><strong>directory:</strong> 本地目录。</li></ul><p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h1><p>git 的设置使用 <strong>git config</strong> 命令。</p><p>显示当前的 git 配置信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>编辑 git 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -e    # 针对当前仓库 </span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -e --global   # 针对系统上所有仓库</span><br></pre></td></tr></table></figure><p>设置提交代码时的用户信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;chao&quot;</span><br><span class="line">git config --global user.email chao@10086.com</span><br></pre></td></tr></table></figure><p>如果去掉 <strong>—global</strong> 参数只对当前仓库有效。</p><hr><h1 id="3-Git-基本操作"><a href="#3-Git-基本操作" class="headerlink" title="3. Git 基本操作"></a>3. Git 基本操作</h1><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。</p><p>本章将对有关创建与提交你的项目快照的命令作介绍。</p><p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong>，后面我们会详细介绍。</p><p>一个简单的操作步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化仓库</span></span><br><span class="line">git init    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加文件到暂存区</span></span><br><span class="line">git add .   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将暂存区内容添加到仓库中</span></span><br><span class="line">git commit  </span><br></pre></td></tr></table></figure><h2 id="3-1-创建仓库命令"><a href="#3-1-创建仓库命令" class="headerlink" title="3.1. 创建仓库命令"></a>3.1. 创建仓库命令</h2><p>下表列出了 git 创建仓库的命令：</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git init</code></td><td style="text-align:left">初始化仓库</td></tr><tr><td style="text-align:left"><code>git clone</code></td><td style="text-align:left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table></div><h2 id="3-2-提交与修改"><a href="#3-2-提交与修改" class="headerlink" title="3.2.  提交与修改"></a>3.2.  提交与修改</h2><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git add</code></td><td style="text-align:left">添加文件到暂存区</td></tr><tr><td style="text-align:left"><code>git status</code></td><td style="text-align:left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td style="text-align:left"><code>git diff</code></td><td style="text-align:left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td style="text-align:left"><code>git commit</code></td><td style="text-align:left">提交暂存区到本地仓库。</td></tr><tr><td style="text-align:left"><code>git reset</code></td><td style="text-align:left">回退版本。</td></tr><tr><td style="text-align:left"><code>git rm</code></td><td style="text-align:left">删除工作区文件。</td></tr><tr><td style="text-align:left"><code>git mv</code></td><td style="text-align:left">移动或重命名工作区文件。</td></tr></tbody></table></div><h2 id="3-3-提交日志"><a href="#3-3-提交日志" class="headerlink" title="3.3. 提交日志"></a>3.3. 提交日志</h2><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git log</code></td><td style="text-align:left">查看历史提交记录</td></tr><tr><td style="text-align:left"><code>git blame &lt;file&gt;</code></td><td style="text-align:left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table></div><h2 id="3-4-远程操作"><a href="#3-4-远程操作" class="headerlink" title="3.4. 远程操作"></a>3.4. 远程操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git remote</code></td><td style="text-align:left">远程仓库操作</td></tr><tr><td style="text-align:left"><code>git fetch</code></td><td style="text-align:left">从远程获取代码库</td></tr><tr><td style="text-align:left"><code>git pull</code></td><td style="text-align:left">下载远程代码并合并</td></tr><tr><td style="text-align:left"><code>git push</code></td><td style="text-align:left">上传远程代码并合并</td></tr></tbody></table></div><hr><h1 id="4-Git-分支管理"><a href="#4-Git-分支管理" class="headerlink" title="4. Git 分支管理"></a>4. Git 分支管理</h1><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><p>有人把 Git 的分支模型称为<strong>必杀技特性</strong>，而正是因为它，将 <strong>Git</strong> 从版本控制系统家族里区分出来。</p><p>创建分支命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (branchname)</span><br></pre></td></tr></table></figure><p>切换分支命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>合并分支命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge </span><br></pre></td></tr></table></figure><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><p>开始前我们先创建一个测试目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> gitdemo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> gitdemo/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;第一次版本提交&#x27;</span></span></span><br><span class="line">[master (root-commit) 3b58100] 第一次版本提交</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><h2 id="4-1-列出分支"><a href="#4-1-列出分支" class="headerlink" title="4.1. 列出分支"></a>4.1. 列出分支</h2><p>列出分支基本命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p><p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p><p>如果我们要手动创建一个分支。执行 <strong>git branch (branchname)</strong> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch testing</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>现在我们可以看到，有了一个新分支 <strong>testing</strong>。</p><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 <strong>testing</strong> 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p><p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;runoob.com&#x27;</span> &gt; test.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;add test.txt&#x27;</span></span></span><br><span class="line">[master 3e92c19] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout testing</span></span><br><span class="line">Switched to branch &#x27;testing&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README</span><br></pre></td></tr></table></figure><p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们有重新出现了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure><p>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b newtest</span></span><br><span class="line">Switched to a new branch &#x27;newtest&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> test.txt</span> </span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> runoob.php</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;removed test.txt、add runoob.php&#x27;</span></span></span><br><span class="line">[newtest c1501a2] removed test.txt、add runoob.php</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        runoob.php</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure><p>如你所见，我们创建了一个分支，在该分支上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p><p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p><h2 id="4-2-删除分支"><a href="#4-2-删除分支" class="headerlink" title="4.2. 删除分支"></a>4.2. 删除分支</h2><p>删除分支命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure><p>例如我们要删除 testing 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d testing</span></span><br><span class="line">Deleted branch testing (was 85fc7e7).</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h2 id="4-3-分支合并"><a href="#4-3-分支合并" class="headerlink" title="4.3. 分支合并"></a>4.3. 分支合并</h2><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br><span class="line">  newtest</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge newtest</span></span><br><span class="line">Updating 3e92c19..c1501a2</span><br><span class="line">Fast-forward</span><br><span class="line"> runoob.php | 0</span><br><span class="line"> test.txt   | 1 -</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README        runoob.php</span><br></pre></td></tr></table></figure><p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p><p>合并完后就可以删除分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d newtest</span></span><br><span class="line">Deleted branch newtest (was c1501a2).</span><br></pre></td></tr></table></figure><p>删除后， 就只剩下 master 分支了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h2 id="4-4-合并冲突"><a href="#4-4-合并冲突" class="headerlink" title="4.4. 合并冲突"></a>4.4. 合并冲突</h2><p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* master</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php</span></span><br></pre></td></tr></table></figure><p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;runoob&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>创建 change_site 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b change_site</span></span><br><span class="line">Switched to a new branch &#x27;change_site&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim runoob.php</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -3 runoob.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;changed the runoob.php&#x27;</span></span></span><br><span class="line">[change_site 7774248] changed the runoob.php</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim runoob.php    <span class="comment"># 修改内容如下</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">echo 1;</span><br><span class="line">?&gt;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --git a/runoob.php b/runoob.php</span><br><span class="line">index e69de29..ac60739 100644</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+&lt;?php</span><br><span class="line">+echo 1;</span><br><span class="line">+?&gt;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;修改代码&#x27;</span></span></span><br><span class="line">[master c68142b] 修改代码</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><p>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge change_site</span></span><br><span class="line">Auto-merging runoob.php</span><br><span class="line">CONFLICT (content): Merge conflict in runoob.php</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php     <span class="comment"># 打开文件，看到冲突内容</span></span></span><br><span class="line">&lt;?php</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">echo 1;</span><br><span class="line">=======</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt; change_site</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim runoob.php</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> runoob.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">echo 1;</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --cc runoob.php</span><br><span class="line">index ac60739,b63d7d7..0000000</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@@ -1,3 -1,3 +1,4 @@@</span><br><span class="line">  &lt;?php</span><br><span class="line"> +echo 1;</span><br><span class="line">+ echo &#x27;runoob&#x27;;</span><br><span class="line">  ?&gt;</span><br></pre></td></tr></table></figure><p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line">UU runoob.php</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add runoob.php</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line">M  runoob.php</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line">[master 88afe0e] Merge branch &#x27;change_site&#x27;</span><br></pre></td></tr></table></figure><p>现在我们成功解决了合并中的冲突，并提交了结果。</p><hr><h1 id="5-Git-查看提交历史"><a href="#5-Git-查看提交历史" class="headerlink" title="5. Git 查看提交历史"></a>5. Git 查看提交历史</h1><p>Git 提交历史一般常用两个命令：</p><ul><li>git log - 查看历史提交记录。</li><li>git blame <file> - 以列表形式查看指定文件的历史修改记录。</li></ul><h2 id="5-1-git-log"><a href="#5-1-git-log" class="headerlink" title="5.1. git log"></a>5.1. git log</h2><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 <strong>git log</strong> 命令查看。</p><p>针对我们前一章节的操作，使用 <strong>git log</strong> 命令列出历史提交记录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)</span><br><span class="line">Merge: c68142b 7774248</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:55:58 2019 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;change_site&#x27;</span><br><span class="line"></span><br><span class="line">commit c68142b562c260c3071754623b08e2657b4c6d5b</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:52:12 2019 +0800</span><br><span class="line"></span><br><span class="line">    修改代码</span><br><span class="line"></span><br><span class="line">commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:49:26 2019 +0800</span><br><span class="line"></span><br><span class="line">    changed the runoob.php</span><br><span class="line"></span><br><span class="line">commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:35:32 2019 +0800</span><br></pre></td></tr></table></figure><p>我们可以用 —oneline 选项来查看历史记录的简洁的版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline</span></span><br><span class="line">d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">c68142b 修改代码</span><br><span class="line">7774248 (change_site) changed the runoob.php</span><br><span class="line">c1501a2 removed test.txt、add runoob.php</span><br><span class="line">3e92c19 add test.txt</span><br><span class="line">3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 —graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*   d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p><p>你也可以用 —reverse 参数来逆向显示所有日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --reverse --oneline</span></span><br><span class="line">3b58100 第一次版本提交</span><br><span class="line">3e92c19 add test.txt</span><br><span class="line">c1501a2 removed test.txt、add runoob.php</span><br><span class="line">7774248 (change_site) changed the runoob.php</span><br><span class="line">c68142b 修改代码</span><br><span class="line">d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br></pre></td></tr></table></figure><p>如果只想查找指定用户的提交日志可以使用命令：git log —author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --author=Linus --oneline -5</span></span><br><span class="line">81b50f3 Move &#x27;builtin-*&#x27; into a &#x27;builtin/&#x27; subdirectory</span><br><span class="line">3bb7256 make &quot;index-pack&quot; a built-in</span><br><span class="line">377d027 make &quot;git pack-redundant&quot; a built-in</span><br><span class="line">b532581 make &quot;git unpack-file&quot; a built-in</span><br><span class="line">112dd51 make &quot;mktag&quot; a built-in</span><br></pre></td></tr></table></figure><p>如果你要指定日期，可以执行几个选项：—since 和 —before，但是你也可以用 —until 和 —after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 —no-merges 选项以隐藏合并提交）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span></span><br><span class="line">5469e2d Git 1.7.1-rc2</span><br><span class="line">d43427d Documentation/remote-helpers: Fix typos and improve language</span><br><span class="line">272a36b Fixup: Second argument may be any arbitrary string</span><br><span class="line">b6c8d2d Documentation/remote-helpers: Add invocation section</span><br><span class="line">5ce4f4e Documentation/urls: Rewrite to accomodate transport::address</span><br><span class="line">00b84e9 Documentation/remote-helpers: Rewrite description</span><br><span class="line">03aa87e Documentation: Describe other situations where -z affects git diff</span><br><span class="line">77bc694 rebase-interactive: silence warning when no commits rewritten</span><br><span class="line">636db2c t3301: add tests to use --format=&quot;%N&quot;</span><br></pre></td></tr></table></figure><p>更多 git log 命令可查看：<a href="http://git-scm.com/docs/git-log">http://git-scm.com/docs/git-log</a></p><h2 id="5-2-git-blame"><a href="#5-2-git-blame" class="headerlink" title="5.2. git blame"></a>5.2. git blame</h2><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file&gt;</span><br></pre></td></tr></table></figure><p>git blame 命令是以列表形式显示修改记录，如下实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git blame README</span> </span><br><span class="line">^d2097aa (tianqixin 2020-08-25 14:59:25 +0800 1) # Runoob Git 测试</span><br><span class="line">db9315b0 (runoob    2020-08-25 16:00:23 +0800 2) # 菜鸟教程 </span><br></pre></td></tr></table></figure><hr><h1 id="6-Git-标签"><a href="#6-Git-标签" class="headerlink" title="6. Git 标签"></a>6. Git 标签</h1><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><p>比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p><p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 </span><br></pre></td></tr></table></figure><p>当你执行 <code>git tag -a</code> 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 <code>git log --decorate</code> 时，我们可以看到我们的标签了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*   eb90e77 (HEAD -&gt; master, tag: v1.0) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\</span><br><span class="line">| * 38d67fa (change_site) changed the runoob.php</span><br><span class="line">* | 1cfd03c 修改代码</span><br><span class="line">|/</span><br><span class="line">* f90cc49 removed test.txt, add runoob.php</span><br><span class="line">* 925f816 add test.txt</span><br><span class="line">* 0e57a65 &#x27;第2次版本提交&#x27;</span><br><span class="line">* ab55fdc &#x27;第一次版本提交&#x27;</span><br></pre></td></tr></table></figure><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p><p>例如，假设我们发布了提交 925f816，但是那时候忘了给它打标签。 我们现在也可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v0.9 925f816</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate --graph</span></span><br><span class="line">*   eb90e77 (HEAD -&gt; master, tag: v1.0) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\</span><br><span class="line">| * 38d67fa (change_site) changed the runoob.php</span><br><span class="line">* | 1cfd03c 修改代码</span><br><span class="line">|/</span><br><span class="line">* f90cc49 removed test.txt, add runoob.php</span><br><span class="line">* 925f816 (tag: v0.9) add test.txt</span><br><span class="line">* 0e57a65 &#x27;第2次版本提交&#x27;</span><br><span class="line">* ab55fdc &#x27;第一次版本提交&#x27;</span><br></pre></td></tr></table></figure><p>如果我们要查看所有标签可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>指定标签信息命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;</span><br></pre></td></tr></table></figure><p>PGP签名标签命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;</span><br></pre></td></tr></table></figure><hr><h1 id="7-Git-远程仓库-Github"><a href="#7-Git-远程仓库-Github" class="headerlink" title="7. Git 远程仓库(Github)"></a>7. Git 远程仓库(Github)</h1><p>Git 并不像 SVN 那样有个中心服务器。</p><p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p><p><a href="https://www.runoob.com/git/git-remote-repo.html">https://www.runoob.com/git/git-remote-repo.html</a></p><hr><h1 id="8-Git-Gitee"><a href="#8-Git-Gitee" class="headerlink" title="8. Git Gitee"></a>8. Git Gitee</h1><p>大家都知道国内访问 Github 速度比较慢，很影响我们的使用。</p><p>如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——<a href="https://gitee.com/?utm_source=remote_blog_cnjc">Gitee（gitee.com）</a>。</p><p>Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。</p><p>接下来我们学习一下如何使用 Gitee。</p><p>由于我们的本地 Git 仓库和 Gitee 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息。</p><p><strong>1、我们先在 <a href="https://gitee.com/?utm_source=remote_blog_cnjc">Gitee</a> 上注册账号并登录后，然后上传自己的 SSH 公钥。</strong></p><p>我们在 Git Github 章节已经生成了自己的 SSH 公钥，所以我们只需要将用户主目录下的 ~/.ssh/id_rsa.pub 文件的内容粘贴 Gitee 上。</p><p>选择右上角用户头像 -&gt; 设置，然后选择 “SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的 .ssh/id_rsa.pub 文件的内容粘贴进去：</p><h2 id="8-1-添加远程库"><a href="#8-1-添加远程库" class="headerlink" title="8.1. 添加远程库"></a>8.1. 添加远程库</h2><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如  提交到 Github</span></span><br><span class="line">git remote add origin git@github.com:tianqixin/runoob-git-test.git</span><br></pre></td></tr></table></figure><h3 id="8-1-1-git-pull-命令"><a href="#8-1-1-git-pull-命令" class="headerlink" title="8.1.1. git pull 命令"></a>8.1.1. git pull 命令</h3><p><strong>git pull</strong> 命令用于从远程获取代码并合并本地的版本。</p><p><strong>git pull</strong> 其实就是 <strong>git fetch</strong> 和 <strong>git merge FETCH_HEAD</strong> 的简写。 命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>更新操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git pull origin</span><br></pre></td></tr></table></figure><p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master:brantest</span><br></pre></td></tr></table></figure><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>上面命令表示，取回 origin/master 分支，再与本地的 brantest 分支合并。</p><p>以我的 <a href="https://github.com/tianqixin/runoob-git-test">https://github.com/tianqixin/runoob-git-test</a> 为例，远程载入合并本地分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v  <span class="comment"># 查看信息</span></span></span><br><span class="line">origin    https://github.com/tianqixin/runoob-git-test (fetch)</span><br><span class="line">origin    https://github.com/tianqixin/runoob-git-test (push)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull origin master</span></span><br><span class="line">From https://github.com/tianqixin/runoob-git-test</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Already up to date.</span><br></pre></td></tr></table></figure><p>上面命令表示，取回 origin/master 分支，再与本地的 master 分支合并。</p><hr><h3 id="8-1-2-git-push-命令"><a href="#8-1-2-git-push-命令" class="headerlink" title="8.1.2. git push 命令"></a>8.1.2. git push 命令</h3><p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p><p>命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>以下命令将本地的 master 分支推送到 origin 主机的 master 分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>相等于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 —force 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure><p>删除主机的分支可以使用 —delete 参数，以下命令表示删除 origin 主机的 master 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure><p>以我的 <a href="https://github.com/tianqixin/runoob-git-test">https://github.com/tianqixin/runoob-git-test</a> 为例，本地添加文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> runoob-test.txt      <span class="comment"># 添加文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add runoob-test.txt</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;添加到远程&quot;</span></span></span><br><span class="line">master 69e702d] 添加到远程</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 runoob-test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master    <span class="comment"># 推送到 Github</span></span></span><br></pre></td></tr></table></figure><p>将本地的 master 分支推送到 origin 主机的 master 分支。</p><p>重新回到我们的 Github 仓库，可以看到文件已经提交上来了。</p><h2 id="8-2-查看当前的远程库"><a href="#8-2-查看当前的远程库" class="headerlink" title="8.2. 查看当前的远程库"></a>8.2. 查看当前的远程库</h2><p>要查看当前配置有哪些远程仓库，可以用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如  执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br></pre></td></tr></table></figure><h2 id="8-3-提取远程仓库"><a href="#8-3-提取远程仓库" class="headerlink" title="8.3. 提取远程仓库"></a>8.3. 提取远程仓库</h2><p>Git 有两个命令用来提取远程仓库的更新。</p><p>1、从远程仓库下载新分支与数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p><p>2、从远端仓库提取数据并尝试合并到当前分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><p>该命令就是在执行 <strong>git fetch</strong> 之后紧接着执行 <strong>git merge</strong> 远程分支到你所在的任意分支。</p><p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 <strong>git fetch [alias]</strong> 告诉 Git 去获取它有你没有的数据，然后你可以执行 <strong>git merge [alias]/[branch]</strong> 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:tianqixin/runoob-git-test</span><br><span class="line">   0205aab..febd8ed  master     -&gt; origin/master</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge origin/master</span></span><br><span class="line">Updating 0205aab..febd8ed</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><hr><h2 id="8-4-推送到远程仓库"><a href="#8-4-推送到远程仓库" class="headerlink" title="8.4. 推送到远程仓库"></a>8.4. 推送到远程仓库</h2><p>推送你的新分支与数据到某个远端仓库命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [alias] [branch]</span><br></pre></td></tr></table></figure><p>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> runoob-test.txt      <span class="comment"># 添加文件</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add runoob-test.txt</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;添加到远程&quot;</span></span></span><br><span class="line">master 69e702d] 添加到远程</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 runoob-test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master    <span class="comment"># 推送到 Github</span></span></span><br></pre></td></tr></table></figure><p>重新回到我们的 Github 仓库，可以看到文件已经提交上来了：</p><h2 id="8-5-删除远程仓库"><a href="#8-5-删除远程仓库" class="headerlink" title="8.5. 删除远程仓库"></a>8.5. 删除远程仓库</h2><p>删除远程仓库你可以使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm [别名]</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加仓库 origin2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin2 git@github.com:tianqixin/runoob-git-test.git</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line">origin2    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin2    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除仓库 origin2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote <span class="built_in">rm</span> origin2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/10/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/10/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><p><img src="https://raw.githubusercontent.com/chaoyuan666/tuChuang/master/blog/4ea956ed6bbe434d826b2d5406b86909.png" alt=""></p><p><img src="https://raw.githubusercontent.com/chaoyuan666/tuChuang/master/blog/af26922d331d4e20a18842f5b0d4b8d0.png" alt=""></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。假设长度为n的数组arr，要按照从小到大排序。则冒泡排序的具体过程可以描述为：首先从数组的第一个元素开始到数组最后一个元素为止，对数组中相邻的两个元素进行比较，如果位于数组左端的元素大于数组右端的元素，则交换这两个元素在数组中的位置。这样操作后数组最右端的元素即为该数组中所有元素的最大值。接着对该数组除最右端的n-1个元素进行同样的操作，再接着对剩下的n-2个元素做同样的操作，直到整个数组有序排列。</p><p>冒泡排序算法的原理如下：</p><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="comment">// arr： 需要排序的数组； length： 数组长度 </span></span><br><span class="line"><span class="comment">//注： int cnt = sizeof(a) / sizeof(a[0]); //获取数组长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length -  i - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 $O(n^2)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。具体来说，假设长度为n的数组arr，要按照从小到大排序，那么先从n个数字中找到最小值min1，如果最小值min1的位置不在数组的最左端(也就是min1不等于arr[0])，则将最小值min1和arr[0]交换，接着在剩下的n-1个数字中找到最小值min2，如果最小值min2不等于arr[1]，则交换这两个数字，依次类推，直到数组arr有序排列。</p><p>算法的时间复杂度为$O(n^2)$。</p><p>选择排序算法的原理如下：</p><ol><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p></li><li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义方法：交换两个变量的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选择排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++) &#123;    <span class="comment">//  遍历未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;  <span class="comment">//  找到目前最小值</span></span><br><span class="line">                min = j;   <span class="comment">// 记录最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[min], &amp;arr[i]);    <span class="comment">//做交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*if (index != i)  // 不用自定义函数时可以用选择下面方式进行交换</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">temp = arr[i];</span></span><br><span class="line"><span class="comment">arr[i] = arr[index];</span></span><br><span class="line"><span class="comment">arr[index] = temp;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插入排序</p><p>希尔排序</p><p>归并排序</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序通常明显比其他 $O(nlog_n)$ 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，已达到整个序列有序。一趟快速排序的具体过程可描述为：从待排序列中任意选取一个记录(通常选取第一个记录)作为基准值，然后将记录中关键字比它小的记录都安置在它的位置之前，将记录中关键字比它大的记录都安置在它的位置之后。这样，以该基准值为分界线，将待排序列分成的两个子序列。它是处理大数据最快的排序算法之一了。该算法时间复杂度为 $O(nlogn)$。</p><p>快速排序算法的原理如下：</p><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i = start;</span><br><span class="line"><span class="type">int</span> j = end;</span><br><span class="line"><span class="type">int</span> baseval = arr[start]; <span class="comment">// 基准数</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= baseval) <span class="comment">//从右向左找比基准数小的数</span></span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; baseval) <span class="comment">// 从左向右找比基准数大的数</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">arr[j] = arr[i];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把基准数放到i的位置</span></span><br><span class="line">arr[i] = baseval;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line">QuickSort(arr, start, i - <span class="number">1</span>);</span><br><span class="line">QuickSort(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>堆排序</p><p>计数排序</p><p>桶排序</p><p>基数排序</p><blockquote><p><a href="https://blog.csdn.net/qq_51664685/article/details/124427443">常用十大排序算法</a></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书籍</title>
      <link href="/2021/09/24/%E4%B9%A6%E7%B1%8D/"/>
      <url>/2021/09/24/%E4%B9%A6%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li>MySQL必知必会（文字版）</li></ol><blockquote><p><a href="https://github.com/sewain5780/ShareBooks">https://github.com/sewain5780/ShareBooks</a></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用导航</title>
      <link href="/2021/08/10/%E5%B8%B8%E7%94%A8%E5%AF%BC%E8%88%AA/"/>
      <url>/2021/08/10/%E5%B8%B8%E7%94%A8%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><h2 id="热门导航"><a href="#热门导航" class="headerlink" title="热门导航"></a>热门导航</h2><p><a href="https://xydh.fun/">炫猿导航</a></p><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><p><a href="https://github.com/xinguoxia/KGE">KGE Papers</a></p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p><a href="https://www.runoob.com/">菜鸟教程</a></p><p><a href="https://www.cnblogs.com/">博客园</a></p><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p><a href="https://www.ilovepdf.com/zh-cn">iLovePDF</a></p><p><a href="https://www.superbed.cn/">聚合图床</a></p><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></p><p><a href="https://convertio.co/zh/png-ico/">图片格式转换</a></p><p><a href="https://colorhunt.co/">配色</a></p><p><a href="https://mycolor.space/">调色</a></p><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p><a href="https://translate.google.com/?hl=zh-CN">Google翻译</a></p><p><a href="https://www.deepl.com/translator">Deepl翻译</a></p><p><a href="https://www.grammarly.com/">Grammarly</a></p><p><a href="https://quillbot.com/">Quillbot</a></p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h2 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h2><p><a href="https://xn--6nq0hk9tdjr.com/">低价机场</a></p><p><a href="http://spatialhadoop.cs.umn.edu/">SpatialHadoop</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2021/07/20/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/07/20/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="dpkg用法"><a href="#dpkg用法" class="headerlink" title="dpkg用法"></a>dpkg用法</h2><p>dpkg 是Debian package的简写，为”Debian“ 操作系统 专门开发的套件管理系统，用于软件的安装，更新和移除。</p><p>所有源自”Debian”的Linux的发行版都使用 dpkg,   例如”Ubuntu”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装软件</span>   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dpkg -i &lt;.deb file name&gt;</span></span><br><span class="line">dpkg -i  ~/Download/mozybackup_i386.deb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找包的详细信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dpkg -s package</span></span><br><span class="line">dpkg -s mozybackup</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/kunkliu/article/details/122608422">https://blog.csdn.net/kunkliu/article/details/122608422</a></p></blockquote><h2 id="mount-用法"><a href="#mount-用法" class="headerlink" title="mount 用法"></a>mount 用法</h2><p>加载文件系统</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">语法：mount  [选项] [磁盘或分区的设备名] [载入点]</span><br><span class="line">该命令的各选项含义如下：</span><br><span class="line">-a  载入在/etc/fstab中描述的所有设备</span><br><span class="line">-n  载入信息不记录到日志文件/etc/mtab文件中</span><br><span class="line">-r  以只读的模式载入设备</span><br><span class="line">-t  指定载入文件系统的类型(fat32为vfat)</span><br><span class="line">-o  选项，常用的选项有 codepage, iocharset</span><br><span class="line">    (对于中文codepage=936,iocharset=gb2312)</span><br><span class="line">-w  以可读写模式载入设备</span><br><span class="line">-loop  挂载 ISO 文件时用 </span><br><span class="line">[载入点]  是一个目录，请建立一个空目录，mount 后该目录中的内容就是你载入的文件系统内容。</span><br></pre></td></tr></table></figure><p>指令实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载/dev/hda5到/mnt/wind目录下并且目录支持中文</span></span><br><span class="line">mount -t vfat /dev/hda5 /mnt/wind -o codepage=936,iocharset=gb2312</span><br><span class="line">mount -t nfs localhost:/opt/4412/rootfs  /mnt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自备（即将开放）</title>
      <link href="/2021/06/19/%E8%87%AA%E5%A4%87/"/>
      <url>/2021/06/19/%E8%87%AA%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7e00a2a8b861b1e4c1920706d22b9e442863227edce7626e9aa29f84e9cbd909">870dbc0705f077354042cef7483ce055f9309bae538238a44b5881fde9396409a957c0753e2092abb8ea8f9e8b231a00fb6b3825ecdfa812782784afd96a20c0c991e1fcfe2af2126a01b726215a50111cb55b2ae0a6df52de8b8b2af651e86d4392818db464d1e0da4c22782df73e6f5588cad0bb308b460b850b6ee415b1764595e7bc6bde38462e2695a9ad001bd702debafa94cdcfc4232855d7791788d319063e6361625badbf81b86a48f2cbc371de7dfd8f670eebd8e926e57ca28242080ae3844ba522e829ab63e3dbb08e1f109322881312cf3d3d352e53ab8bc467bb28db3ce63b25a3b925b927d29665822e40d1c09f7be5b1c04e4cbbf9095d781204bf0c46556c5469271d607573956be083a44225852c66712fc5a47a5ef4240e39baa73dbb601d2458035cfa596953ca5eaccf0327be599b82ebfdcc0cb2078b1c8563f830135da535cada8f5f3b6e65c0d7c989286cca48c42f3051daeb3d45d8c8c9d3881f1c637e45a550ffcba058d1ed03466e2299ed1d994c3e8fe8ace588f60745a42f21bd1e78ef8c75533700b2ef54bf9d2b3f0baea257a7702c634aa5b6d7b8b830745ab32b2172620a080ba3f316e3d9442ee3880ebdb21be236750e23b82d70d5a4916425805b94669066562b5036425bc419a302656d3e89e6f1aa4fb6c6234ad9a238ff991f2b1ff6b6405b7e1aaee03a73d575c688da080576c74b26a3d5724f7bffbfddb60e80553fd46c7d6a0c411099ecd6247701b0763794225ac5595b9efd0aafcb4c9cffde3e2215f904e121c07a90ce0a30570ef682b78fc8c8240a5f8884aeeb4ee1e4d654bff76eb316291010b58ed4a480f6150d2189eb180f73080235d5ad76f3a2a78b87f40e38f003214b556f37da22f7189279c2f40103ee1224cd46fc9382d6956e8a95ef978ad08e57c533bd10fdd8d9bf869b18ceb169d594b13d943fd9379e7edb4c39d87559b85d095b78677516f94ca26a556a4cab92261a3cc66f0b4b92f7b2e7475e7cd84cbac2c676f9c94395243c104aad9203a72b4ad585e650f845380bd01fb7246a895d180a7aaba71fab3f450d2ac8a3e81d5394b4626b73433e104454ea0dd62e67a18a4f55f681d4624480d570a7a13c85406c40ad753116afdcda273cace43bfcf91afbc5823a6a326a13eb8cafe45bcc5a22e959d6f43589cf0e83a475ab2472afed5e175bd45d4ea6a15cf971d2705d18739a4b91496b8bc2a6d3c9deb00cdbcec1bb10b655b0d550f4237327c5058d9cc5dfb49f45d1a7dd933b5808b26154fa98fe77ac189c20f6303aed5bb671e91e153f7bf9a1c8d32a72dd3870b51d8565edd9ea629629eb3bfa444d510cc42abd5f054a59a14be479fb043836f9bf682c867ded670c8855437ce06b7484dcd433b3fafedd9a08fcc08393cfae45786086a62a31f0948af429fd37dd08462ee8d380d9e4b1eb7989d97cc1a3ceee74b49f2d08971ea4f9238ad1a95cde34a0e51aec3b8b47a48476fc29007da2a6f78db91960d0d3146a035f584d6ef93146fd89c029f8bd91b5901af79058893bb1383f4c5fb2bd9b9cb98d046f51b67344e087c1af893845b14c2d3728724e110062c83b604581d96dac419e01de3d324bc17dacb9e45543fb8533c266eacfcaffcb633b3f7e0f027a510f341175d15ca4d1b454f6cb0679560836240709369ef6d67c5934c4e909556c43e045f04f98212c61b432d45aaee4dac35b7a40dd5fd2168f3fc11b4c88e600d5a36efb3763a6151bcf5aa78b24d1d55051b855854dd40d1b5ecd29d48ec7cf9f8db3a1941f0fb05e0ee5bb510af8741812860e734e51c4deff574be84fa92e35901a8720279ebc1fa8bc3211bf77ccf50b16a84d963607830de8680a7116437310735ec7bf9453b89bd0662f8c5330117dc7fef2dde9e2afc4011450154d50f3ee8cbc2db6d19a24d01c7cccf23ad525daebc54adf5f3bc42c176626e5705c8cad1b118dc93667fc2c099d190be3bd4a884ab0030b8ee7a02a1020e1c53a81bf1db4145b793703a862e6a33dec9c49e5f3f65551b23c315788ba94df6af551d2f45d9afa9631b1a44bb511a04ee24b177955c6dc6eb0196a4d3a7ff3abdef124b2d8129270d2b929ce5ca21bb77e6281def3a7c8220ab2fc67810b60f38db78b30e74cf656acb1344e786a340d43449e721fb6752e91024e1577dce210fcfc983bba12a7aa6576a43995ffd20aed4dfae0dba5f8d6e0fbdac26461cc88b33082da94e13e3aa341af770fcf47d235f311e8a74aaa1e33927e81b48775d32d335b11503e8f76c33e0f8ca188b4c8b95f844d13158765eff829ff11bcbd50c2176bac212802d07456ab46f2a6caffd9a70b6c1a2fcdc3723c9724c960e9b4eebf9da863c8b130c3f40eb2779c57f7253e1b0a69e9f1b18d2000937da79512453ca256604d8dde60c132b2a65baf0c6941f49afa042a7527ec0c3a2b08526f4fc00fdfc0a4a144da61f1e7b31082766d84ada601012a0464b7b7b795f1e82bcaf3932d74fbfb6b67c67964db185d088ad3af3137ed843cc80794dd080bc79d673192ee572583da424d07f15b1b4db0eb5451941bf63114662806f91b72ecfe1a78530bdbc32c6c08955b92cc0c645ff325466dc55d683df7bb187c3971c7156b7a45a386ebec3c844eadb73e0a1fd631d8ebf82140cfaf0e37dc293b80527de7469e0c3adc8fecc89ca449c877b378d18c3d7b8789ead73d3d3b132022ecb4dd31e2b4d2a8d4e2ff412f16b7c1bd23346144a7311f92f33d6f294ce906281f7e1cbf336ac5274cd0b36c7924ecf4ea61200eddc74ec01a24d877a22505bb7cc29acf1d8d3206b377f96e2f86a7951b3825582e0999c2258cf8e941b78a7486faffb1d4959ac5e3cd7cda8ffa593fc0db020e4902619b60192b1c36d06ce1c5bd0a27ba39f035b3fcd251738122466bfb7260a113a110b21bb070105caf7d833f864d1f30e3c98d103140018121989e41769d113a3752672dee4c2c0bdc9914726380ca5f9372f7f1eeeea206a86e8c974ad072d4f97d25f74e7cc8256da5df928e1d0eb8c05a76af5930ca08dffa49620c35d46812448c1696bc3fdffffce265f0c62b624c8faba723e2cb08952542915d0ff1a8c5ad6143de32007737751b157aa0f3663a5d1a2ae82fa6740e19d21ef44b8255c754ccf2c9e527238af4358bd96c41ebab53e8783612d3860f40c737b5bbc238dc5965874e9a622280bcc2a3e42a4eca554bb58a481d98c6e1078f9bef33cd5779c6c6762aefac6b1bd9f5c341a135c20c0285ceb169628965f44869f07982402a07cda28832d29aa2049015e084fd3d4293aee731ef2feb0d4c734f7a927917fe3dfa1a0bd3cfe09aa2170976f69292249ed4279cd5a0d29ec677d4977be84228befb33cdcb9693eab9c8f0493829c2a3114da303152f5f5f873569e2738d8b35f6a573cbafd66dfb0d837bace069569ef2242fbaa2dd42c4aa9052dec24e8333fb7470cf7a4e647479cdbc85d1fb033f7c7c8ed6cb21177f8515609b86005765c5b38d7fb1c8355adc3275614159c1b3f2644df07b1ad6f9c21f19e819629101ab5a6164af64b34b1c9d725d8fa1f5f10287b03112fe5bb4e504bc41a61d2d21e5e90c17cf62eeaeb78525139fbac8a4025ea916b631d53131eab2ae7c4ed7d07d50086562e59dd7b9e5a111a11216fec14b52d071a3b20d382b75abc9ade8fc19e800466c1fda25940641ba63e2df76b2f83626b4d7011363d8e5fc1d61f34c6f2b3b0afe7496b61e93270f7b314cd547174b76e6261188321e225fefef4021b8ca6502b7b954ffc360e41402bcfe18df3f4a606870952be03fbd221c7fa9db4b6d814dba61957061309bff94c1da94b049ae42042336a401017747082303c0d9e88ab829c2e3f5be780876b73e21b575c56106cb70464bc7b7d3fd72bb7df1d7f78275660add3accd7c76a0087b9f238823b1f09abf884e70689b437e9a62ac7818d99ce91cad9885fa98dbb3c7a6eeb591d617930c3851c3d65d513f63a68e77b7af871943256596ae608b48ec16ffd47699f711747d90483818bbea8598e337c64ce52dfbef94d73381ab61980e81cc3e7f3231991d462ea5081c30bab48c5a2e04bdad2eee3673b421a07ae5e339037cf5cb914fb178c443320330d3ac794df22507195fe97bd0adc9fa99552a6fb6f1f783176642e5a4a12085b0ad5935077a41a74b9c326040c10d1406272eededf5fd1234ad17fc2def668f2b7c2469dcb908f50dc896bad11fab852e77699e5f1115d97127bddb1f96c2cc39e505cacc8e124b0b61adc1accacc3425b989895e95df9cf8318a9bc54c9eeb885f1930c8ebb049c43b090d45b03d1df4688cd45378615eb4876a94394a9e47f1a2fc9ca9a00995064768059c936dea4c3a52f374f5b4b1daa407901a118fdff17af43058c5273fc3ecd8cc29d2a47ae5b30177778608dbcd058e7523dbae3d80b0b25f97e83ce88a564de23a5ee3f68ac123cc22e723f7567ffbbe01511e6f925e65ea1eb957b78cf6fe03a16ee0a128a43d8f5469d32139dbb35eeef3d71f54d8765a24b52d83720d5199c8517c8c5ae0648024d3c027c02826c2c4811ca4695542d03b75f1326e0b18eb650e1ac11d368175e3dfabf5f4ca0e861733e7a09c4198f58a2afcd26558f7f96f3a31b12d16742141490b387e263c4fa0a282bed9c66735c493f9a7131773eb278b15e984bf106937613ebb379cb5dd4a74f65c3720cbcfc1ba08db5f660f641cb9a4c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里需要密码才能访问。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见知识汇总（即将开放）</title>
      <link href="/2021/06/19/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/06/19/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="eea9a1d5f4256eeaf929cfcde38ff18c3adbe82479d8784c133c8548bf3e865e">870dbc0705f077354042cef7483ce0554c672a2c20aea55ccfbfd19f77eaa173c101c1651a9a1e9e1d35ef3868053d89aa6b0c97f846988d331871185e6b7905e0b637bcd1a7677e93a887d41389b4fd9706950446744a9a4b1dad2373412ff8901bd99f93c0c0b8450ba373bed36daa54af03b21bf22927252a63c271689ba0531e3649f2db083a35e8e711079e94e7ccea1a3c1ef82a22eb9b7af2648a589d39f729fcead1e50892379dcd6a38f1f2c74f22cfb08038781e4ebf7f8da0737061e5b2dcb226be3887c530467e4f1a0496e01c3aca4f30550d1408bb7013bfbc22157175d8f155e8f50a976c7ecb46ab7659af5bfc24ffec5f94a1fd8aea21963ca69ee18d74bee012377e72f4930f4f3ab2193caf77e4fc75a7bef50b86af02bf25329f9f15b1669570283fadc1661591354dc8c887e6f884ab907dd8bd0e59197f248a6e6f51b455ae3539a7a59b74b44c79876febe5153ce9f1f52bbf20ed5b156dea8ce4f517143376436ca6ec5643ef9de3a990d8838811aef7b7317cef7b000e1f2007f34f8996c1fa110902b37ac168092b27c99078a9f1a08caab8dcdedea31302bf4babc294bb598254675de00e8365fc654522a3802e1ac4c5c26253e72b2476ff791da1bbcb384d3f0bf10dabc264f9b613a50f46feeb3e8ea8b379c85199db59b434b2c89e4fd60e4ad492f2002bb369155ec107fb70b47c9e717ce7714818f7e525c3b1d4365576da757e17fc14de2e8cc5ae809f717603cade8cc33529e174b9b413833e17cbb18c2482b738b7aaf5fb417e5b9ee1bd5b819f6cc904dc8ee1fcc70ef94cde1ae7a7395ee05cefc35860004dc6e0abe28cc14a512f22028e03ddf2750c5eedfacf4ea3acfaf376e7594fbef0ac0af416754db4775bd5367b954cd2d055757cc201a2168c47ac6cedf83a4604a7183d3d0a6420ea9d01539a725289c2fa8f228f8e27c475045dbf7038a637403cb1319cffe6ef3c204354373a723b5b69e3f558e9b85f368e7d88d069cac5a3a5ffd5ad2ee913d327f4563158263eed0da1dcafaff089c058ab069cdd48f4b462793b9c58ad27ef9285e39e7ae36df6b7b997c0c319aa6d00da493339c4d6b45de0776acd1c634fa6b80e0828cdbbac7721e24e448a9eacdc4d3f06586eadb02e1f17902b0df42c9064f3089e77a5f2fe6e72d2a1f39b4f48f955526039be4934f148e8566a926e47049de51ad07c84c07baacf56baf2a9cd9d2717626676739eca8007fb5bac045d516d481cc1c78d6e4c70a0278d7b5359598f0dd6aa018e667990df758c5b7c258066eddb99e54d8d1504b359a35f755b81cf33cb662bc9948226dd47a32102248303093559d24353301dea695e5710f9e2b3615e70b6de190b3cfc291032cea6d9c945af4820d7658c4657e5b9b5fa0962d1f30303441b13ccc3dcae540ca6dce5c96bba96f184df63714f61783a996f3cc0a58670f0146cecc0352fc90d9af52c25789ec4729291a1df985bf9d1c3b5728a10482cce9620541fd24383ae8d3cbde861c72ec65115131d943a41912d672dfe97cb8c4f6485852c5978d131faec3855e24010734b8870487c75dedad7cdd6a3f0704002d2ab1597273d11e1da98dcfc024ac0e58c15438a0ace772ecd183b2ef59820b3cdd4cdadfdbbe7cf8dfc70fea1037e18e5737374c638471cc49f1346efe4ed102abda7d47f5655d3936608abf3ac380015e44f12f55e8f337dec1ddae3101e7163b7f41ee71696845ad7b7498d6f9ca184ac86be78b473e8a37f4e64461671fe94a5b7eb67093798a920367520bebd15908ce93b70c0f0a45aec27c43cf6a13105870ae13027bac7f5df7f52b281aecc761c0e313cd38ea37ee686b6d75e157b64a436305bba8033dffed42214e530edf234ab78efba5a9325e10690a4a690db59a3ea623dea221d1fc9b6c3178a6ad3c5c92d3875c1c3e4627c05203f0e683246ce997e68d3d261ce72ba7f370d03e9f842d7d3e2d7456f240a42cbf439cd3372e2830fad89ed181f0bb3da83db63743511686b67b4c4c2d4c28569eb7a2fb21c5cb4364a4c61b176a0a28175f6ef422f95a9dd43dc912aab438b2a3d170f94331012054bde4ba8fbc0bd9c8fdd1959a7a01b04b97a907062c43c016643bd8d0d6f4e592666ba91c017d5899979b20ac434848a2228bdd9c7a18e7aff7a44e3e01255d3e187476f105fc3654b954c16e41c4a1db6abd88a0bd9250ae963042843526214a90abc1c3a25a6fce823b0ffc5901995f6546ec2714c3a82c2da683f456063cbffd80fdad4de0bc5c3b97703b4cd4120622c569b2d0838f58f5ae9820d61317226d7990d930ac0abf7395f04595c1680e80f3fce3040af7bf83d152f1cfa515a2e2f9e1177a9c34fff649dbdeb4f1ec53bf3a0c8ec9529dcfcedfa9fcb57047a164383604eceb382b5d9c39dc8a24c45edf84905d0d8d26b4a44f18d4eb841008053086a4cbf626748e000431e08a21160ad1f5de5751d11a6f0803358530b598e3a56e93b02542b0a47e29410e2a29f675038b9ea72a076e9777954849c76f2659390817f711106892452c1654892eae933c069cfeaa5d04e7a0beac1c627a57cb5ec525de2c0dff8174e86b4ff7d6a4f48bca0dea0fdb7b031f477bfd3e864d341052cdceb317abf941af4a3ef8afc8e9f97724d4422f95aa41d1a479dce56d1413b92517711be57d8a983d4cb887e017d0be0c8fb101805759450ee6c812f67a9caea2de5d31477cbac25c48a16329cef940031ebf41b8100a4d761b7c24360ad9c3ef25486589e8f5150a43e71e227ff6ade8e5232cb1504ccc975189d8487efb05a34188b9897684fadc50cbe0ded1a91008ac194fd20d763265e2f6dbf99003caaff753cdfe5d4929c76528e746986c080778598096e3e2183b66fc908601ed548c1d5509ae6d660f5d959a3173fcf3e33726e2d564adcb4c5e9e48d36171c7c546249adfbfb01d219bd929c576d3e89c77f7a40964e3ecc77424882f076f3a7720692355d034e312f6272cfcd83be061a741173cc195091fafc4fe9eb2d57bd82953d30767e7d7522af4bb05c03bc58765d7b696389a4d73f1e456ffa23f3114df545e7320b52915749a4b4d50435e3e9ea99409cbbdb968d5bdfb90c4d7e82270a8d4eadb3ad46b67265cb8ff82c312e7cb7ed600830690cb845ddafc654805699863067cb0385619c3ecf969b72849e64fd1753aa6c3fee22eaa96b4b97af34440eed91a35fce0c17ed201070dc3694094ebb5fd5f310c26270b85c243fb739da458907e06d5229f68261da95bfe09f9069bfa74723d1be225d067ac77dafcfb9eee77bd70a6fa7b3aee1033413a45f8cadc97eda8ac823bd345f12ebee828ae7707e145296a80f97e2a97baf83d7f0cd562dca2ce2a06ed5503f3dfc930c5793589ebf7960fc530837b0e77112c3018c66ab5f4b1c372194517f40fe21dee6cc10ceb888c60756a5f1c925f83bc9bee133c5a46e15ba2efc661d2595d82a357eed2926eff6f8dcc0c48e50dca81b84da891e9c10435f5ed1ee96107f34046baa1f37df63af7e73cf7ae250c3462be2ff3ad7d4c7271c87e8943b4003e5bdb53720b4c5cd09feea79b9059bc83e7a0e2bb2d754f2d458ae7995a0a4ee36ccb55e255b87cf1d382cf24dd7788ec34ab942989175918e0ffe78365f90ea5ccfb8e153709d37087c2ae20320be5a14c26d21c4c2f8f62796dcd1dd2f88520b087cee96a82e59af22032de20a3303c3a7710edbaf4d3b37e1f2c1fa5eaa816d29b5a732ddf2187a1e42138870068cffbd240dc21c4597d5b069b717be7273298629aecd8c5803695e474289756e66fa123f5829650725b6a8956031937b07569ba2e6c0bc9428304811b18f8914ca6911654ade7da2a7459b720cde6588123ebab1d92f7ea602e1b2826db1696aaadbc8fec5f8ec21ff01f6412183dda4d75633f600da4207f6c7c2445c287b47ac923a4818b475498413e1afe509afc4c3b2146b95e799162f44111e91d7d01cb4d6055ef2954339d05e6703bbfd82e4ed4092b111efc56685d0892fe57f4c6147c0177cb1cd3989bafe88fd61db98a634e915cf5fc69fd8bb34d20caa6ac8ff44d615f91456ebecc076294c401bba313cfb857e2d007dd6b1b0ed7d1a2644a15b79aa0e027b16c4fb02cff5d86940509b4129cb81aa804cdc8d2cfa2a545c0bc35c415eb89d5d45f65815172e497f7203d0e9aba0ffbda46822d22753622a3724c1286f820db28efb37178b61ce8b01226b92d2dae06b9d8d6446cee059ea01cac85e3546b51191cf6c05c54370863e02352a1f11844171a2677ba47e9ec04fffc7d500b61578a10472f85cfe7156a8e663e256e1c9713a6417bfc7283989df6ff6878172b99e9f7b80584cb4ad25ad622c2b94962207571ad7ea31e06895b386afdee8563ccbaca9025ca977b49ab03bd4619a2e8cd82755f6e0ac0d5d313c63401e3dd67027555d53e57be0aeb69e4777f0c7859923976e05b3117d1e4d82849295fa655667deee9ebfef38d5f029fd858b0d74ac8d598ea2bda934588b99d32ee970ade3346863b01b5b2c44555d25dae9273988534c68bf39eb9c568837069aa347d361392b90df24356dff3143e03be8616332bf44bafecaba78f0ffe2a422a1b00e79ecc9f15538b8806a960bbb27189ad303aa1e7e8d2b871aabefa19e7532854d2055f8285700a08432cd9d0a3d225fc7e2b15738a2c5c701b422b636f189f3d37cc3ade1cab6e070a37bc2985459df779bab5182b5718157bc5175a5c1ec2712f96e98a4e1a01cbe235e3653b1aa9b70c35528138243fa1215cabcd14da664268ccb36bc1e2340aeaf7573bbc91785fdecb0fc76ec84a124a24457c5f8449f6fec3db40f9c4fe83fca5e9275614b53eeab4b9415b1c41cd468c49cb56fc8e95daf89cf0b69bddb28f9bbe90f598216ebbd02cc9a7f48862b21864ac001e4b67ddff2fc746060701f0a1ffa46141117a5d77b1d021b295dac9923219598c43af448862db685c68177c2edda361e368a1531bad40f2beca4cd3aaa1dae694703899cbdb229904c46e36bf7354b3993e27bb1ae7a283fd70f2bfccece0023261b26c68e2eccd0e8f31b886703947ea323015033c9ee7d5658427dec1738e44575b66e5407c6bec0850cdf85d70c7741d80adec001b74e3b1653f6bd7879cd106a202c7fd679d216299c68d7181102d1741ce4abd2afb0f87494d4e48797469cd51abda26ddf618781404e5da8584196e17cba5e7ae58b55d6d9e5a2cf96b0cca7c1ff329c07b7dd01d59f4ebd953c7a338d7661e462ab320d3c2c9aaa5f142d4978e7766fec1dc2cc7fac52b9230281a8e028b9ce6fad5655b02cf54d41bd89602bb7845e19faf2a5a38bf5f423e920f82feab058640ed2482e8e7bbeea08464799fda52f768242d25f5764d8b522106f6958ad2ce45fd7f3c389425412eb76d73ee39d8e024ede7f70f74d81916b7486b22a4e9a1836efa3e40959bbaf50f6b61ff84edf81454451caf2a7a0df5665fc2f16335423fe60e68e90878570812464533aae95fc6bcfb56477e99bea78cb51812b40f9bbfd1d93397f936b0283e5ceff83034140db07eb77afb0f2a847ba319ac7f0d65e116afa39e7bff0e592c92f79ee20ec386e1d04538b9166f58c7da85f9fc8b56bbfda1f4f682263ce57be80ee5c232a5f94866fc272f48c9cf64e16759734c0f5ef025ae875ca256aa22e6ec5e232ecd86c9497e94ae1857d1e93715d0f9b4979d705a039a3e5f33e72fdb4c9bc4f065bb19898f24063d5f25a084e9196e6ab806823333d6b461245fda4873950e37350be1f9f20d026357f40208ea406dea64b0c72e54b520820845f5452520bd928dfcead354061a5a612f74d428734f944d76077dde903b25581bd7b07baf7f1048a118117f3f5795359be63633e9a72ad97bc4ba59364f31d763843e747cdc9bbfc402b4373ee1fee308ee65d2d38a1d3ac9a45ad0ccf358460fd56d0eb7c06da383d0304304b71d8876983dfb0f8ebd82b99a253cd58cd3df78fe64d021782b98e50cc4887a7330fd840d851c8441f6036186350dc62486ecaa077163aed6f7357cc5f50c4b3cd9f257ec99d5bc266796e267a7db5100cf9de28d4e8287481adac47ee7bb3d0dbe41eef62e09cd6f33202cbe3e1ce3a1ba1d58953e761bb6f6084a91bf2338662cd7503484fbd0e7b6d1bfc07b3066f73d2f79e81d84b5a8c15540f0004ab5740f67b5f689b16d18d6b571fbd10aecebfe155841e8b181d0803c41772d419d3dbb2ed83dbefb06e902e8f69074ad78aa09746de160adabf8334f1c8a8243766815c1c62cf5eb749d267ea25ddacef7fc4ed194ee6763ab64f2fc7ce330fc9e1c7bb6b4762d0063e464b715d884973b93ed5a8d16c9c10f35033de56d9ad48cd6972a52fa78bad536d20ca7381bf1ae595004c7172dd2b9ed55ad209f524edea471825df3441543d8876bf94ee513d3c17533c1da220282152c656d8d99f1afe444c535d8989e3556dff39aee0821b431e5d4eded8c69c13d79991aedfe4ad3c46dd35758ac9c52c99e295c5e83230847b676be263e6e2219915392e2eb24951f5fed5ee5beb6124902e5860054a66481939cbb24871f5c51f052df33ac948e90e38a558e726048fbf197ce30c6c7e7b9dfb0e681b00da2eb75cfd341ed9204a29bc34ec30d2273c8780a2d63f945c8b0317ffa08305fb2c5ca11b33c5b29f08ea4dd6c068a49cfb1185a8ebd308894c40d806d0095aeb5831c8c15e85e2c8621c01d40875b24a1c4400267d9ce3b75e3ad766aa8e4436cfa3707f90faa5fed93e7907100baf7f629ef3b66741660ac4349d6123e464561a85e44bd4e2faa85ff321ae1ea9026903c0d3d4295350fdd535d50f3f55c0a3bf9e7225c4472fd83911361a9dce945710d5373d29af6655d3913ac3011538ee96f7c890184d2e96db7b7e11a8ef92abedae19f4b557c60a7f29d21b3efdcfcdde51e9267503073b972d11f77a096b8ae61e41462223625e67402354d16da46b1671ce57640efb732391d1e528006158401f7aeaa31c7ea3254086236b55019b8926bc5bbd766888a9a6565f6fed27412cc8be165bb871d0387e63b082f32c20d1340e829431ef794d716ba7ecb881e0305be95a7fab630f012ed3cccff75e9119fc04fb3a7d05d67ff147fd901efe0eb8b121103aa244ae6d0cc46809bc1f2f1bf7678b29263be7a16d8c397452bfca183760b5a1ae9406f88de1b6445138f3a66c232ddd3f5994c2d8453e87b775374dc53bd989515778a74afec139feda1a4c2c444b7005719316f7cbf62431d4e2467e2a9d487285c55b2c09e722370c5d0e6158e61322fa56b045e275648ec0192c13174aa6f90a1f9b6e190237da58d73242d0316c7db40d2e91347be212a8e0e34c1671c072a378d61a2d9749c804fff67a9583066917a1d32a4f49279c3345709257d1476efff4b5cef1fd02fc834e90ee6124fa0337509312f82e39c4e9f6f8b3880b3cc202f28983e205c14ecb415a3e2694f925eefec4dbb22d45cdc97e77b48724d485252aec4498a70034723cc623ac7a088876710d645954fa196d451b67fa39ab074bc226467226c96dfd1169827cdb3ccb5c454d396ae300eec151be10a1af75019639a8d65956e63141b7fb2df40ac80e3d3245b458c1fde23ad271e54261b16ebbb3288a55a75fff87a98b4c9f7a24e453012c021a63bfec6c2459047ebb1797bef57028cc0c2704f633c7637dafeb1040133605d2a7321821fc586b778a58f25b3d137508f26d1fe0bf4642f5a1813bda3b3e5f2eebe3b944d8f008a711227f9c13809dfef9444eefbecc36f55c1d538354c07937212fd50200a2264570e0f54140b70f0dc3161436874f3932be743ae29f6c40243826cae38b7dbb665206d33d0526629bb2176aa205d1ac76192189e5895b466b856bc61d6d533719dc35799e5422226ceceb25a2e73cf2c0eb833fbf57fac0e97507cbdf8be536de8cccbb148ec1374ebcc93b69380fb76cb034993302ffbb89d3708d2225a14e94cc8c08db7b631ceffbd1b7a72d8ef6a6822364c99ce989eef4e6ae5da6e6a03bce6247c585fa55271eab125e6e9e02626270057785128dec37c8c82e8a7ad99cb8ab759bef3d4bbec915e3c947efce1c86c80be99df3c97e7c0da1edf952aa67e85780e581fcce5392a69f66330f56384f4bcf00eaf80e50a7596612c7e99c0e3df3d9c82c30ac182142d286a77e7045e69de7c70d709b8ff9efe7fc50b5755e073b24bce7d6c9b1d63171d52052268d3d92cdb58b5732713b835b3e80ef33eadd8cbfba57faaecda82542aad62be08e634ccf4f0719b9cf96ccafc0198cd9a207a086a647e331878ef6198b3f1e69b5e85306340c8118266e635aeb50450d5ca63bc9866edc30c2d180ec4bb7644ab57bb5926592a3baf62e42b76034312b75103e8fa41f079578a9f7cc96dcf6495bfbf3db305ca9be52e1edabb6732ef53a87e0ccaa98ff7cc85f4b9866eb307c01d04f970447b83c280c94614083be2fb80159b639fd92a8082c3a4f220abe89232250ad76fe34fd0e849a84c3c1710a67d6c03067746a9c254c18d7f80ee46ba88c3332e6fd5f2a460d8ad8dd1e63a8c6e143d3c23699763b8aea7f6aad097bce77d2c80366aac71248e1d43403a6ea3ab067603eeb56f76465f0abd536023cfb7ba053411fbaf09706d6d8ab9f228b0a6e61e420febae47af4a94fe42ad12f8b7d5d34c7fdc18c64a667604358ce2258c8ee51afa235a5c5ab2143290bbf7651175602abaf5a1febbefa2bba16bf0719bc03ebe4b2282487b2347c1cffb51dbc91658e566557f193d99bdb637462c68276a165b4fe0e765b60a468e28dc54e2d9f9d8f86f43cd48a7225f0c72e6b2685e821583a7c7e2d08424c36b40fe0c0cf3935c2b38a705d1eb67618053abf6029e5e4b1ac9be4d31bfdb6592a94a0bac3cfebb6b8980fd868302aa783b44fadb4694f221baae5caf0dcc3628a926a97356cbbb5e490a375145d6ca8decbb2cd65d361385e4101302c857d41d620680b0e47c137ed5c1e08c5063f6e0aa39e269bfdfaedca39b9d5efd727f83d794888a37b54ecb7f96577e5dc2cfd12a182cfdbf1c59436680220bee9aa227179ed68241ee906031881ad0a7ca049f32d318b763f6aa6947eb329cdb1b7d6b7d31cdec86e79621639f89175111dc3fbbb12fb98a39573e2bb78ac04b18526502812cfc6148becbbc74c4edcd92dc7ce480dbbd9e17bff2a30d274d62a27778261570b2e80a2e0d15ec73a5673b91a79c71d9d6679dd5a4e63cc2b36da5deca774cfad2ba4d109c01245ccd5a04e0d1153e5529a5819b9179dcbc7c5566f9b394623befac046fc2531cc45919b8fe9577e34b8e010b5d60afc08a9dcb3359c430e1dd46097f61a9776f963e57cc03cfc85c2ceddf81ad7082629738ac2684c637a4c464f22529ab4164f826d8c5aa611de164af1d43228bca5c15962bfac29246497087c442034b4dbcf9f8d441ac01e6aacfddacdab776ffbb9fcd2724edff39199d1ee3bf3333ae99e648151ad40f066e5268afc3f6b8a637e50b45f1a84e303ff9db99ae8ce890c4f0ae19e869cabecaca30446557c3920e3be67ee7951f1d47f405b0dfe63237df4cf8dbe479955aeeaf150d7cddcd0a8b21c33e328504dcd8077570d19cd2892753ddf904996f4a2976f977e3872a9847154aed8591e0a33b42f40c31a2712c82231d9db1967a1d7e6d808ffc25560c69d24268da5a089b44b502cc498e7fbb06599fb826d70b2481efc7c2d5cca7c46caf6821b599647ec6c6dd1c76908cda7ac81df1b4a36f8277f1a0395958b42d007ac52344d0d5fef4bc779833c7ba28c97a1ca2872bf05ebe89010938432f4d87958cbbbd8a00b4e2f386eb4a3f5938b156ff291ce89ab3458b9603590a30e3e7be417edad3304b9def662eab81da4d5eed37f04d919f03dd5c176da043283e81fa6a5610b589e987abccd79b05203c1d2dcba88a18013328668f14b2c70d4f6140301f671b09028016193344f6430f8c365c613f5a48b348397a957f8a1675be3e88c726a64198865722d011003c3e7080b9f52819a9b5643068bb175ae18ebe9ebea8b3815cef7f12b3ccf078da8d7b228f608a4ede0851e352f02339632ea9e9d2f339750a18749aa9182d6e5dc2347732c0f98f62c4712d4a1af4b6bf35164ba8c6daf1a4b36591bbcd3f7375ec710ad568e687b2d53a51e6ea7fd85be5f48b313d46a6918785571eed481076c9ce3a119b522f2d64c11ea8c12cab1dd655a342b484c7862bc18418b787649ae854f909d064f188919b56d6499e69102d640eed78be48a6bfda820f6df7937b0b89524e1b93d3ae2bc3d514910d96dcf982dcce3b15da4979934315ea3f25850362fdb8b6fa783f4ba807a116b6a3c65da9f7004f264bd395bb374aca3582ddc30f172ca358ccef2727e5ff0f9c72261c232ba21516cb3d7a0e618c28ad6511ae63b468baba3a3080ad793d3fdf6d717348cbeadbe455e13b91bae5144f93b6d593533da9d845746e71afeb93919483c0a247d16d1ea694ed80c39b9d176840faffd378c1c410873cd0c7530fc76de4b57e85f2c50a4856bea896d157f750ec456e766c3330bb1089c28c1342dcad7e211eda10283dd164d136f9cf21350fd7ca4b198ff0e4cf268960f73a73f3a0ee2dc3128e702d6da507deac4ecb454aada38ace57a19c1e3f9831410af17fd3c691418300df2ddecde2d218774bc34762815d20ce563d69f55d5ad2767db510cd8f1a15088232efc6fe0a0f93e2cc6055b4985261742ee10df0e742bf48cf3f8c2473eb8242d6020664896301828f8b445ecdc5f7d6fcca8c969758ba103660e6667063f3f81b344662b90113f77496c81e8ae57abe6fc168ea6dd780e2b7093efb2b3c1c455bcf9d94f297ccf87b8a91883764347b727b87f3110d1b3c504fc6715c78c1d0e779e39443ed01917d90baafeea0d6e387fab54c576242e0a19e6c6e49243876a5ef1d85c5f16f88d2315acbb242a4df9d182b2bfa50ac40278fa05c88eaa971c9400201dcb154c70d71ac11770b536b04715c28aabeafcebf5a5f131efa067e5696ae9dd427e93512b8474fa3371ced73cddf11612895efdf45d5571355a9005c8192cadb66b2d6baf8f21349c98a6a3471d72110f6fb730a8e4a425ad3f7ea49bfa69d3b37d756eb1b38955ff155f0bac237da9b553f243cce676e67863ac6a8199632cf3227a3c903eda23d2cc0680185601b2ed0370b5696233f02895ef051469ce962d4899a30164a1ead2d40939f6e83bb2504d6604094ef22529e7b1bc3c3e401811eb957a7a44f18af560bcc43ad00df9033351a015e46ec2a4de527b351aff4f756adbe5682922bb6e87bf8e67364ac4701087d435e7a780d56682195c25cd67d3a8ac10234a6d63993eb4c54ba1004e33f36a5b9e1ce973c6cca844e2e2db900efeae6047c7a3708a3987db908ddbf89889a2ad0a83ef656ea5b5a3c016bc7faf28df5a900ce60f38131ef58e00db976c0750d7f491798e554fe95cb9b84b78652505b3cca4441a7a8049e4a96a581bda0c995e3ca133f6a472f6f7fa61cd141b395c5cf184333c892085b86b8c2dfa2edc3d42075d33e13a5a36cee2a67f4b65f4be9814931d8ccbdd34734bb10004b856b3485dc378987a1e52ea43f78197a852d28ded63b355c35aba094154b584dca1938cfc170257d17352bd83877ebd751acd2819aecd99f7a9a8aac2534b0c38f79275973af93ad2b8ab677a1023fd8abcfacd871c264adb696506b2b9ab76f30101c49fbcaa9e594be68c1193de8897453e07220dcb1e3d4ba5c47de64aeba7463781aa11183773fb1f0211a36307fca43628948933e39099ef23b4ed80ebd4216d4b6dd20c7be754b25ff6def00b69c9a6748df11832a496fdb79c5643faae28a8a58b6b17372391f892ae69152c3a2480bfb8f4fc6ac16eca33aee17e90e7c40db97cafb6748e5edd5bcf4dd2df71ea6366bc829ece34fb929474915e01c2e6bda8f5837548abc3e55f8649bf36b64ba1e2c64ddb3af82dd0f32a7accd6512f97975973153a4e3716fd35aaf73fce9aaed15220308fb9c7adba396fa88dc82e5c24358bac91eb60c80d3621c002d0ba2f65eb430aea51ce3a8b008db3f9c9ee4864aed531ba49c466dbc0f01aa7f60d4ab8cbce7eb4cd06047a29fe6ee712639568db2667197f97aeda6f4046e54993afdfea758d908441a0db500358697bd71a26594ec7a287303b6109029ff41801475af46cbee1d40eb838a6b3430a0da4cb046faf94b9619acaed052d3a32e8acb84c1b243f0598e941cf4a5ad2e8841901f5b9a34d263341ec9bcd921a66fe4ce4441bb2da7b42f5fa8ab0644407d2a60957d591facd6bf76bb63f866b647222e2af5fce79e7c2e43677fbaca0f378a1944ece19c612b7a18626d86fc74190ea08067bf3ab602f92853aeb3d0e7d44b2f43aa6c70bddc38750424b5c89d5eec8450aaca94ba87ab46e8a499cc1fdc01e15bd30d4143aa787e1c0d5d1c0de5f09dca53c37a6d89de06516463be43de222b82ec1e7c69a58c1fd80895b93cc41a7fe61a74ddfce56ca592772563e9d21acaac895074227e6dd9df17710140c040d8b2d766b14351684940985a658743c6204033aaad35472a2385df50a08ffdd922f7cfaad044ccd6f5b4c6f69b93d177507686673cabaedc2a4cab049c42fdf40c4b0201da48d35832f1e564b2e59f63bd68055a6fbc45568dc651322de8fa94d3d37032914d09a60daf1d4077e05a5d8bad35192f106bb6ccc1414f1a669d23bcce0b699a42474f622fcbe4abf73125141e5ea500318f0b6e7685cd132daaeface1cecf35b575231a17e29f3545fbe60d6c6a534a4ae4ceeae3991779b79ed4f6ae776186010c397cf1b1ba53b7e592491a602844554deadb61bb76b6741ff84dbeee0791518fba7061a006134aa5dd87ce36f3bf15667a3a83780f9eb17670e1ac43a66399dab662169175a551704278cf1f5186905bc24f6af99f1bfb00ea430242b49396f6c23cc32bc3494eda7aadd2f58a9de69062f6716a53947f20d677656cb42e48a646cd69ed0a2cdde18d90a193be754b41768535347dbc0b400426dd8ef86427f4f56cefde9e067e14334d99e8b1e66e07a90bed377304c86dd5c6f47f40186b5ba8b4356ab93261728a0e1b2900015f7c54f2c813590d6e7878f2c02411b37c9b770df46adb46f13b8bd06a177407e3da56b513bc4e69c62cadd2a467341d46dbea092f31c25281e764e7450b94aeaa7b4f418f8e65c421da7c7a90c4027c2d78cc04a9c93f3bc6dd5424215c915a20b8042ce8fe4652098e9ba11b0387c6bb463850bcfa685f2d08fda6d16e1ad7f75f5f2a18afbc9c35ce0e953d0de161b3b3244a1a2268321db9d3e264bf5bc93e34ce71484e4933d18905852096535ad79bd89ac01adffb8f6da72aeb29d56a7b0e93c25530fe32ed6dda8f1179cd583684a8ff3b7f15de659ef2c89e7c59a1d146f6da2971a64ed68a77c3eff01a3d5fae6cdf5ea4f8e29ccd5249f274b5bffc7c76937a623b40126d2d3bde164e72de96008526d1df33a9de6311bdda6a294b1a754907f974a94060d2a6f7f1eb8b17ba2a433e6d58285ccde8324d30d41f1d70b9473af303c86c5393b51b8087565c505904342f915f8db066d8929e03d9ac4593a51cd5b6991cab4d893da433878075b0d817b85af9f507adf643ad1f0f8564cd94e5a854fc3635f2656c2de5745fe384336022a4e8d4eb87b560361df6541048ba6d099a48499c0630f5c61a083505ae319bae428481720fd3efc876f16264ddf828534a03f2d5baadfb0b86de25ffb22b1c374855a4c09acd6d0964dcbdee661e5564061fcc5c57b1b74e4646ff0f1e42bde98c6e4b2a0d93537fa6ba2cc384948650a31d2ae334071a434ba3dce5edc6fc5e17738b8ea4c963664087b0b0eb1c6b073d1d7a092cc9c014ed24294a33a9e248f26c9d8e1fb9a34ee5079da4767ab69057ecc132684493c61b2edb3427c8ce0858677015eff9ed7a99271c085f4b01f8734f2c397b70b44bf5f79cfbf793b22d3921b3aeed4b00f7b2e1a7897f88cb73dbe69dff9aa42d377da5d271f76ad5dd2b56c06045301f5d654c3e6206cbe6dd1f7c8a3166d02de68707ead371ed5eb9e56fd5653c5a86ce9f45ad5d27324f3bd64f9d9c3a22575afe93bd018d8417533274f395af934195c51e5f0b5dd707363dfcf6c2341b0fb19265a81d75c92a3805c49263d4eae56b60ac5980b210baa4eede1b151dc49352157440b784532ff063d16580402229ddcf66740dd63ffff57643adcfc4a756588c2c2d86d0eff1afd7d02b4c3f90eb9d2c5f75f94e3cd4d339772277a2ecbb7cacba3424b66468c18b1a15841aceb7b2bf8dc982dfb194c191b6ca670461696d8089fd1143cee4737a2930148612849d1f84160e57fdffff45038d728065c48ab1bc5831a49b8393ab47db14f143fb4424fad7a5b491f5886e5d0aa851c8f91430c4bdfbfd4953d6aab29b11474d919d83d496a6da43b8695ad20903fd2f2d8b1e1ad379ae412840332ef07316b7713562b3e9bb9d08215ea96eaddb703105cd63da75a5ab3fbf797bbc656b4dd283779ea3e008143b349db9b2582cc7e4fd39e230c5c2845d006648c645be2f869c80b0c94fc67df4f5e621db585f0094140957c232edae40beb46d3cbe24ef7ecd9c37fa52e3c8e612ecfa427581ebb8c1b1876d39c9297fdc9b30369d494db45216e4d65cee61a351c5d6ac02a726119b39b1701457ac1266aa0e69f6eed907f2bf9c96b8b95690a9eefece1e7f7b3734cd285366f1229a670d6579178dd22e3d58c25676bc8c24692399821e527aeb991ac06842665942bceca81513f0b6b6854056a65070a3b90ada721a02847333ebce01ad091ddcfa7a7932e0c15f37df061100af931dc9270104ebc1c62b34e118cde67a556dafa43653a9129a9c0a2b56bbf6bbb140406d6350855d827a522781ec777aaf09d2365aa18b8333e7939a0831fedd526cd5db29abf32112ef8e16e7e531886eacf2407a5cbb0e08497966a6b69ab2b4085762a658e2314e0caebad5c84bb748aabfcfa7435ea873c2119a7d9fe2a9820144a50a465954c32097c9cfa65ba055f2f29d9a3193d37f30f40db351606ae2fb31e9a8515eca41f4d97450b9fad1ac813b62f4fcb6d3ba0b9e4caf151629dad10b1f87ec48e02f00ba8b1c6ffd5fc92638fd3526130623bc6b937dd546252340b41b18bcfb28331cdbfcff034195499de36c0662389176d33aa3a4be187e07538234063637ee87c04e278b37166abc9c11b7b0d65bcfd118e77565dca2a5c253ed89dd8fbd5a193731c8b2a8528540dbee1f69f057fa258174df52b0995b510553cfc6efd1d54538705c90e8b45e117a405b7519a5db7e96bdb235c339cdedbbaa3e337e1a48e4cc8abadd286c06f5938639f6098e5223ffe279a1025777b7a96ff0261d796437f1760f23b74f7db40e822738b1ec58f68dfb27d7b538c614c3afd1f0e5eb19cb4938ff6f39b91cdcf8730be9315a962dcd6159053bed2b538e4918765dc1a48631ffd100dd12bc69fa5136ffe84dd47272e66fd30fdc10368dcdc0975de4bf2f8439f625407a595dfbcca1eb8f5f75bba7537190b5a2dd261955a274fc70f7c0798f1ae6d7eec0948b0ed6a8063f32106ed58ccb80fc867d39cf535e138a14c63b8b47e6f9530bfad656e7fddda4c2346fbcf15f5de08fdd0d24a7e460487b877d89cd4b13f350563e511d2153df41c55504e3ba62e76550e85888199c5f95c1cd3fab55f2fe61af035a17a6d8663f3ca3803a4b61ff77bdfe17a3bb769bb1875d731bba0cb42b602ada1b838273ed0b4e129ed539b431f402785897b35670fdbc2da58fb61f692994833816332b76d29643df4a61757a33faffaaf75cd729a463408be4c3bcc560efdc92e9037698d393e0e062168d7c29b1e05b0aff71f4f572db3fd0fdba1c00fe51e529bb1bee677b40560975ea70a4b18107fa346cd158280528e53bb28b4e2c9b2532f37f09ef362e8ede13a3f79deecf38f6da8b145978fe83c1db4d19d74841ee0efbd62d30cd1cb1f4c263e9ca9f43a6b02a9bdbec913ff74d463788136ee5f14c22c257535e189c13f3e7806cc8e605867377aaa6b303ce4c70306dadc1e131151919757f3286862423b1ea99fb0339213aef1aeec48ffa306c95ce8fcab89655bb96e9ec714b1dd02f2b94bd9720ccd46ea34f2c303f923aaf5253683a1800f6431823b02ca79a10aeedb2d72689d526d493e75ee0792397af03619d1f89e5aedc7c635fc99d126983b301434c10095635f9270a4869903965482e89d4ab8c6369e60569323a0bb678a4df1cf66838213af001ac389abb640dc6330a67d0a1317f67a8a8f7a4e67db6a33a570dc1ee995b51cc7bc49a25eb3312489ca00eeac822ba78d691dd3812ce963a091e34ca77dd3b64dd85f77ff2ad889d245927cbb762f3b321e1e4b5ddcdfa0ab050e45639c327ff3e84aebd48153fde84b7b5127cf390767c26a9077c3e70065703020aad6846aff2f56085aab108442befc845184955f5e3fa046328d04e9f09112f751d22d8934ac761aea9e45f4dcad82d6539be904201418a0040b68568aee65137f778b5e8ca89ba60850efd2a6b31155231fa3e0ecb5d475b1936e15fbd9441f974903cf628f547e2693bf681a3af2848a86f848a17c87dd6c8258827f15daa5655fc42f1591457610df1637190f8657f041697f600665413ab994af420fd7949621138be62719267ca5a579bec1c9968a34469b974f319df4cd2d46228283e6398a714355f78155a19f1996aeaee4b12d7354784a9ebf7ba3aa115486fef3b60b1b82992e7c3753627ff6c1a89c6e38359eff08f5adae22053764f218fe5050693b473e14b3e3762e38b492bdfe94bb44b9f15f8373640122e96512798e13e74d4ca6386a92cbf4468b579ac329fd6aae51a440af1d92976fb03060bb05c14c337123954e24a50eeae44967798329870e9c3a1135ccab2277a667c1d8a4ac73b35f702570e2ff85b9f917b5578f11af8252b5fa609bf9c3b00e226f4df82d98adf3fbfba8c48a72a259b6e24303a2f1777ec1278ce1d4bd87c842d555603dfa91ef978a13e84c433e3cd9e821a0574ad6f8cde41e4c199449ba12047584f5d1eb54f35df4568906a3d5d0d25198e73cbf6a1c8e95a52afd79f6f08cb4c55ab186d4a8d0ddb089f697b44b96e37e027aaa3c0b8e6624974b56f0979092943c2849fb01eafa9dfda229298f99e7a431fb9853f57b9e9cf55070fd0d6740c3c60e139c1ed9fecd60805ef9346b6c9e66926acf872174128b0dc4decc029870e7ab512d93239f08b22ca100441a209cfc45d6ecdc66fea65c53ef29befde389dc291a22e364973612e61870ea51e745000c500fd078811a905c42c3883b99053bd1dd26911290d359de5d49e4e53ca7e98cfb041c7fbb33fbfdafe83710955355558e53cb8d0d218fd301a7f580a0956000034de38283a34a4bd943062e5c7e87694f876b033e90df8f4d90c1c13f8e649618e549f9acb68ae288cc67be31bb195140eb27d8a0eb02d25f9514e1088d1553f2c7d5fd9273286ac614507fc909873d89b869e75176c47614d52da3534ac1a9fd857b755d282abc03432dab2219dc644e416756468af04d892e0e4cb206f7a06d1ed57ff5be2bff9b2ab73505a72a0a1759cf74b24b6ae228b1f4cdc75b7725dd7ddf2eb397423988f249e112e685255625c0dcb0ab8f6121c05ae7c1a66d2ca6b480ab1ffdf00453116e5fd95e61a367b6c31179c4983742226925784e859859c4a8b0a000f8c316356714b0d6c199f709ceea5a21aea6ec0dbfa3e0370ecf4a74fd2b0ae3edaa67505951f921bde5da33e050c3c8c586d8ccb644d8740ac4289adbb3db4ca83da7005f79101a8df2e9233a455e185a243fc54e3a5ff40658ef9fc37203d63a18fc715f8e47da58e909bd6872e9e7f8910be556892cacf4b45d3d8a4090be866ac706586f8b3e632c27d7722fddafd0d368d5e75ee926fb7ebc5add72d777c52e97c2da2d73d82cb8daacb5f742b5a4b44401ff53d367b9bbb78a29f860ec9cafa6375479bf165bb1a02c5219fe197b63413e2c518bf7029f70cece216654dd1c50c85ae4b2a8e929c0e2396b999a0c54357baf7e6396b7e4c64706e163607c24dfbadf466f0e4004649807dd2d7aa16d59f9fe678b40eaa2d3980c56097a9db7bc5736683a6ed94d9ff49a661f3ab511dbc11842703dc7514c58d46fad933a9171d5cfaba58f7bdf448611719332fc8892b6c95e2bcaafc7ed1e11ee5d4d40533c37726d38e889bd17731493f5d23ef18d126f13e2a72da2192fd5582b1578a0086adc6981a797714745308f595b42e41ab40a4d32ae431191c13f45974531284540dfdec07e298bcf9a854d77e6a41922867c891159a39bd99504f4c8fdef3cbd5bf693d03d8943ac0fdbee6b019f7a38f893cf0645ae1c58f7262585f68c4de5bc8f195e73ce76fec98b316c73190581aac9cc7c6918c25af7b76e27c2d0784f5f3aebde6f3f144f342a98c82292aae092c312d00233d45583417d0a1b4ba52631f6f5f3812eccdc53134b8884f2c7181cbeb7c09c0b2e2d1ba89057df007a13c9be724349ae6caa49a4fc874fa5980e5dec60279589fcbc9f234469e357fa75b611740e2e3d1ea8dc0d4233efc4c4a1673677166b595fa1f175ba49f482c3802f50d623c27fde67d975cebbdcc40e58b2963f44c82a2ea4698370f28c9d0f77b94b4c01895969dc12a89bd9272c0334ea86bfb9b5899c578f98be0e1db54e305a114df4ed5f38e6c6515d7966bb487ad5b24bf763e9cab25ba1e54057664a277eecea7c4847af94173617366b87cf3a915ca854268a3e7054aa45bf2cf548af8f7b9522b386f1efdaf6656dd6d2f572b9df8dbf6c9858564314298699ba2b33820aaafad7187f6d6e33e58be99c124e8c2c35399bbdcd199f1a7230fb1bb9533760150c41b95d7e89e3ffb8e1be9d967c28a8f812ae2c8376449d16e9ac8a62949637d6a2a269ad069b534b06e4afda385dd2083287aaea55d5744a23f9cc14777f64409e975e2446dbb22d6e510ef0f3f09508587eebf58fdb32d3a72659442e527d55fe241972fcda0e4bdb4b60699737c2e027b97a6a0168d97a2b3bb0734fcbd1904bae4008d0896f6db0ab51c07a5065a8e48e5c42f43d7ebfc6c24d501e0899f63bc6bdb0acc96e4abf4a9b4b1b88571829e0745b77fbdd10383b788dbdb4f87f135771d0fd2bfb1c5c22c07038e3ac9192771c031232e511982dcd46adb49e5a4a0892e6a4aa32b25e44d1c52770147c8ba84d56a4bbe1c723a877e1b18026c41e4d7e3f70eb7ddd96179e0608a01481f25cb8aca11116bac0d40749b4b6cc105fe8c2dd2006465befececea4dab8a3893f50da653860e74c47245783d02aabd2d06c8a075ef2d26489ac43c2aecad162fa1df7c53f07d166e968d2601fb20172a462d90685be75bc6e0f82fc7931d0706db7414c561bbf6f6ec2abb45c8aeb6b54d81b68da84225c9a8cf5c7b082d7b7ebd71b0ffd34e338d33d1b44e340a55d479698969de47ae29f6a5f1690bce27bb6128af5d4c8891e65bb47b85c92ec81a52859da461a85b33c77f55813e6757c7ed0e0e2c249ff6c16a350953052c27d460b828b2ef15255b1983071d1769b5242a0148e8d14bdf3124a34286929e4d70f1536f65dc3c4251ece0d8181823df7166279761909b759f70796c1840bba23a051a3ae5a3828149d987a1a7d9517699afb1c8b6e7703cdfd4ae7f87a658ede71cce53cd8f6bd813c3613844e31ad6f564085d510d2039b0f05c0eec1dad98d5594a3ce58ccc57ce5dead6282eb9dc45c3d009904cd78835974f95e2c04f2523d3f6992ef9a866a4156fb5fcdb88b97f2e63880465c430d70b164f766ed2f0ae16a33ce45d8b329a0f4728d482db67ab56ac4169689894b7dda8e2578bcd5efada884391eabf03cf80a1038d94d635c80a2958bf7633359fd453ee9f32708e5104f3ce9c6d1631a9f7f8d9a0523a2ff8244cbde5421e9e84de16bb1064b1054b21b28ad24770b6b5afb9e7e8fc42f2dbd570f6fa320b840f15712eaa03d49e978c1a2ad0c0c9b3c1fee3d8beeb777533525bd49cc689b57a8dffbfb3696596287a683ad830a9003e8785d7884fc7f2edac610a292306a7de35ef34f53b935c05fdd435b89980882e39e2fa59b41fd19183988488fe748ffa0b0abdbe4d0c07b654a321d87507d1219b1c5fefe8c39e152dc46fc5bba9089f560d9b7facfb829fb0a60101f8315d68b93f0d5392815af8751b67f70f4709a66b872276d7ec0eb570d1dd3af65c7e06209f17a5262802962aab6f9c4fa90180e0fe0da38a937943bb358d106a5777a5c1e8cc7849dff6480243c094a0ce7d947e0122e0678937d86bbc19557a2cf9a4f1f106ac82de2926e2d772d06986580a11e17bfebdf9726e35846b55a59f464768f6bf462dc85b7ba709082ffc11cf918397f3de43bcbd3d77f2dee4de739d3ec7a99c14e231d4ea29c8f7f586213ccb7729f7d223a31435f1b5eb24feffe2dafa821253d2c07e3ecc6a0a83912b445134d2a196b358cda866398219e8b7a3292e2bca7e1387560197df6762787f3d8d0372e5a35d993bad37f3aefc63d0c85ea0c5ff1d7f3bb7b1e4f647b6ab9f0394854a1a65369cc6ddee2073b145e6f56446ca8d0c4b158da1249b8179bc316d4b1ff75a99b0dcd598a48da6354e446c7c35bf6828f73a52ce17573434d9be76d8febe261a4e481a27c770469a071818377dc2fc9015e8862e1e6f2448765387bc24a9f98d94443e3f67e3a62a0708bf296b71b5d6ad2b90424455d77c5c8a20ebcd4fd915f7379254b3b174f2810c3fc1253a181a3e486003cec99dc1f3a09c9d81d265c6393967595afd81dd507775884a06b3fd2e391b085f4c5dca5f1ce4be85cf394e646722ed05a3b1adab5d163608ac6224823ab2e9e49b3023783c8b50fa9956d547bcb7c26d11fd9ce56b7e64ae84fc008396a5e8c0f5853bed312b9e71dd55b6ea6282976d496401833168f94b0e506e8528688bbe76c16a018ff4f589bda1d0cc5c1bdad5d519ccd78c2a39d016b4e3af0add38b9e3c382796e6755de6583315b992063d2e87e04bfbb4013999a55c5ee1d1b21d217efe6fec26a3c1f76624b07fa1c78848f1350129ac7e347f81bcbc7f499cba4c2b19f88933938dffc99f698c0166a8011dff45a1dbfca6e0639a234738fc32a825ecb928f4ce6ec0affe5eb3f75f27c1daaf8815ae265f4be643a73284d401707da5c1c23dd184a7a7d8928a657c777cf774a1a31f7deaf6106a7875b49803037ee06424db2f097e1ffdb90f6a6b819f11a50c3178f0f3364e50095707b1f5a51335279953b4dd69cfa0fa4f05ae997311f130b1961ae7a2851ca23916ba92ccade0ed7e560e8a7ad978faa504d7bc35de1a305c92d9932791abcb6034cbac8097de150312a3d7478ca07d2a4c53c1f89a70fa9e6b5b65a40a8922a1e5deb3ee875a443e73772c4e6b4a28f4f0749381ecbd692f3c70b743b52742f4a3e5aec4a5de88cbbfb610f0f4c3070e2e47939df8c9959f5c7ad79ee0797e06162692b16d6b8d7b9f3eba08ac5cf9839687705039bce4e2ddfd1288ee25e56c82acf01eec2b04fa20c58a5954d0f023c4fd21580fe933742d78f18058397df2c2304ba7e592185c94d2f8911dea5337022af1f7f3e2f03e5809df4bc721293e785162f38efd703e03a79fd04938fa00d24f6e329c47acf6cc418dae7792c0e9633e60bae45511b6636e099df9f739d326e24e21f4fc29b70d18bf69b57300275ee2c5a41d9886d400270975504a88e0d77776b91b3cd6e5f193e53e50f3ee8d3a6ae4f4f2b75c087520b2ae179c9be34e391e165abab2595d07e1c30270d7c0a123d0bd9228ca46c9491eb87cbeb037a14fe1b133801445103259b5de7856e6b04f95a0678a77051cd204ba4e44efd8da71b8ff2e16bb022649108dfccd4e44dff0e0225b1c54d250d06674716790fad7b0b69d0e6c3d2d280d40fd1bdea2a82a8ca733a5016738f42aa5aabdc7646dd2c591e6b09dd11183af6a8546e358a615a934282e914209845479172c7bca4eb428a8ed33732a3b94503195e92dfba98253ded461171d176ab456c43edbd4fb884f5c0bedd020e51e4fea02674e410ee3ff9e052145e6e59013141268a9aee54bc01b52978f8a65d3ad36c33596ba6b277c0e1b14470b4e46a8b3e2f8c48792c8e3b7eeceae2480f566620736f9d14b31f5f2752732d0ee67fbe4902a2286f2bef07b922956201dab6c57785cca5b5beff3197f569ceefc17185efcd006b68f6fa8616d26391d1bbdf447cf1c5562b30100fdfbe0d96ddbf74d66c5c2160cee228159baadb803e3be277561031ac1f48a1b5a76caa63ed6cccef7466e88fe8245c80d9047f77822c9a43ff52d7fa714ed04dd7c857a8e9b0a8fcbb557f9f7a915ed32bf908374a8be3cf759b07de0658988297642f8b0589dd0d755f7e3be847a3c051359778c5662478479a80e2837c6efcfb2648ab0755c4b6c08d98d35ce989ff279e2997a3fe918f610e28d869a9d38701c3c8321a6f3f8c7b2b096d117cf3dd19848f4dbdedd1c8abb6323f875f2d7c6cdd015e90f57e090c655a1e50f5088428a24b3c0ebc073cc64c7e97ad25954e4fb0d6af645b325d0ae96037ff3396d9c31e675eb7539b12f382e5a45d741625f2c5a359d05f24b4402db171f71d600b33335bcc57380ddd6bd672c3ae5440a55dd66e5a908f28fd53e036d1377bb1ea7d124d89e2eebec9534e1465ae96f50df540b4e909a22bfd03972c357f637365dd1acc89d9da8c3ae6a0153af8207d916bbc9f53c1873b0dc5addd213921f67586727cee09238d534365300c0e63b7ace4b772eb0c12661efef3884e625723420ad08c52ada0d8f007745299a16e5d5a18667a8fefcaf889511e33493a1d6d1f3bef86c12ae4d95a223fcd56a9a48e2558e8c04c068adec5288686539093613fb4719857e49287f42e8060c33b11d9d9943376a447847573bd7df92824b440790d66680c96c94ba18e88f9d1141d37eb8f772d932020d01658181784c9dd1cd50564aca2e3ce1b8eea3ab192c3ff0569a298f69b5018625db8ae07212a552b7d5a0e464ae173a33569e72f1610b12af436164c525f089f82c8ff68f7bcb6b6ab728f6f571b97a7843334f8e971c97e9b93cd70c1c1884f7a9677303b585cbdca05720194ab6a3ddc79d4721d96ce122e0ab24bf575a523a158ef99472a3c24ce70cd46e7e77b2afb3d3abd1a2cf12d05560a9c12303b463ba1b48acb98565cc3a9c05adb510cf65a7736f62a53b30b364fb2a3b473168cfea8a7d4ae01ebd7fc0f29cb820de33fc5e9504b5a8afff387a3bf890c906d0904ce1a41d1ebf7636948015fd2f1e06b37cc8d83a0419617e2d39534a627a3d9f7f8f099c3498eb5bf54bf16bfa865e3bbbd1bcf62c20a6494f0886c2c07adb6c05afb7cb037fd246b172f8d62ae31bd64c8d3f998037499a7a1fd0a9efe94afbd3deb8eee45bc782da2b11b543518f67819a2997935132f3fb04aa6a1650b781af2691949065298e1d91ed71b87c815ea9e94e025dc1a93d1753ef2016f361f67c776c5ecb378a85ba562ef2917edfe667a6f70e79c4a1545fbb442ef3afdba4452d7ad8dc0ca008f6cdc47b418efdeeeb6e5a272961006c33de8a5805d96d3e46223d4f996d3c67149981d74c0eb62a154df2ed41e6ef15e8c32f874a6fda36e97a2df6811682df804108652d3e34636e2afd2f26f1d22344b8fde5b5671a7158aced2380206f34dbbe58aecd66647a8a0d7ba2f4159ac746d72c08a27fb778b032147797e1f3e1a858964a4fb8e95895ef3a7d55e6366b48308ac73c65b033a49e72df780e8c9d03a0fb662299f5cd7421e10e166509aedea841b310cb9fe9ffd81210aa931b2b8dd2557f305b95ac8695d48f129227a9a860eed0655c643a913460c5e03a74c3675f8ee617c1208f83bfffc08355f6d290909fba4233ec3f486d0f1a2a9770026c6fa04e5f597853b26017009968b0467f45e97957c351fdf1a7b6f780055605f8df684232813ebc5cf22733b77e0f8df6b7810631b1adceb4b510d0e3ec32b6877b0cdaf3b07e17b04c80723eac45ad222aa99fb212ff953a025c01f27dc0f8caca01c2d88edb32441b88c77abef8ded02f44b2cc1a918bde730010c741c93dbb6e9528e0b50191d83ba3488cbcea6f07a9c3a935e5b93b73e3224c5c5254bcbba2606c4669d3154608a4957bf9fd7cc1c3330c4aa39d0b0af50974db309fb05fad3aa2bdcd0b93ec49e8467ed9afca925267842fe0bfe6f6645b2edaa2231bf055a1712376a2aa74b103ff564127ade903e2cf154f94bf3fdbf25298224ce84d376067121099f539af884a0235e9361b5bf2684acb897543efad7bffed6125ce5f0b44ab1657fb99c28a90dfe299ec5eb2cf3de0779e1070701894682b06eecedf393d3957f82992fb0d6664745b7fffbe9e73f3039ac102d174f7d923b85898c1b95d3f5bdd356a69abc22109c1060e55e13cb3160261e8e680c5e7155653528b4b456f2b060ae73ae8cafbb406faa39afd99c9f4e0da26e16194c0d7d80cd7330559b4fe20ceb1b78adff91176ded6d9bb4d4596e96d20d120238c690db7365b45d13904e5532aede106f59685b980b944a9d3dec7f6326c2c7ce633924dffc424f67dbf752b0db2a90a24ba619ffa300f224b4a16f66ffd019d213d45370ee6ec1594f386bfa862f74acfa0e03d15bcf0395431cb4309cfd6a31ba523cb234bbdf9af27f21173666fec6d48febe4eb9c0872e7247941878a291f0c61bca606c91e24195fd0afd233010a37bbbff840079cc94508bd322585d19402e6beb365803de94ba4f05b3bedf37676cd1e870f0f562cd907cf6b2c2efafdef580a9de247c39cd8a84d98ccbefc12d64f59d5ade1973982695c3574438a254b4f3b11a018a834158b1608e07254243fcfc5152c8636a4e7f8ae8c4dfbe92d4d49388ba38fea095db9e1e5af5217e7ac11cd2f51da5fd950b71306bb8bd0a4e0f03a42fe78474a62114a0410bfa9485b71cf399dcebfe28641af4f8c87600ba24c389719b933209f99ca8ad1f0e66888522349b4c1a469601c3dad8da032c4e0674a06794c47f7de47aef95af7aadb27a7c227b99ecf4cd9668ae66682a8f7e3d7c4679978b13f15d868e37bad8a2b9cf740671f032b30ca97dbac8f9adfd026d967bc1af161217ac8b7ab66e3fc0137e0734e25ec7f1cd774859f682c576d4a3d49d59bcb8dc0166a633016e67071a7598a98b05571a30136e9a0deb9c20d2d63db872cd16351e94f0fd53e34cbc0cfd91c432bf8d457beca0454f51e4afe8900b3be5facf7c1e7b0525829a3b84ad99d52a7841f7dfd15b76acbd6334e64d2411a51229a1a5111d938d1809cdec4f9aae8084787926c5636c999f6b64b20a9053367adfa9d4803098726a7c31e4659752d277622080efd732cadddbe0d56a95415b083ece20d12d5008c2939ecb27ff2a8735a93f3f11df599a8e4e9040f6e78f56d64f553a8116408d12005fe46ef4e84b0087e25d6f597df9638ca7f14837d285e022f101dc43a01d01673d649064f9148c3acfb91876fb6ee03067b39d122d63e22015b4769ce3dec206a068c876e942a5ec277be1a191e06b693e19688854d942dac8d59fe7fa35044f4e2b5bbc50c81b073db7f214940bb96348bc1d480e734e4388bf4250c7dfaec0733583479d1ef79bd543920ded215b968ab51c4157c506b632283e45a83a5ef35442e344c3c336a464c9b99a196a843668b0e2b5a265aa5010c5ec7fd205a3f79d395316819226c8f47e7cec3e8089d727c8da5ac1910b802963e2ab40da3122bb43c3f45f7aa703cf5415de5315e7ede90d5cc625741e1c3f3753d6d14f9e9e4bfbc633d17435abad3a00af2df0be68624ce7f0655fe7432a21300f8e1bfa3c795a3d5534ecfe30bb6327f775b1768e328c0123a0c6ffaaec18b80fcc8a1b7b96c1cf83ca2ca07c4508a4bb261269f33ba9c71481e0700242931e5e64c60501490c2f141adb4f6f8f8ea030e58b359de3b9c611f5d1ced0c16b31de680806d8d50f2bd8aea0df52cca473469501e8ae9b9f36ed07e44f03a1dd882a623efdf0f66dd33bc6cbc6561d716e3c65f3032d508aaa3f597c7949cd947b8eae8ff8f7aded1389c973a2b3b27fd2a9c42820c312c341002124b00015510b8f5b4afee9767ed6deaf538b433056802690617c5b431c420008eee2833fc3d308714dd20b6f436bb4f0d54249d58f559bcac6f3204ee5e4901a35cd10fbd492c4e233760cda6615348ad11a9a5cf29b02196be7765af70357974b8d829fd5e954594d10e735caa4420c1517b37bb3daaefe1494fcea53b70182823e8c9a94f2c1d7f71896c1dd077215f1961c50f6ba6cd8b4c83a7189b7401eab6eabf2a6bd671ac40ebc46153ad743058dff3df0c4b2afc9610b2da5598fe76731036504e3a72fb4b8ce1ec150a2b918235a40bc96294894b9faf1c57ee0ff97cdf3f872a7b9cc1222ef1328b622090c09fd4997d4962b96f03af78950048a215c03b83c4c8b4606085bb50359b45f9c65b4cbd0bd8be973e14ef196b838c3e3628c5fe0969982589c847c39a3a710c6464c752251e8df3bfbaa1d4c190b3174b0f082aa6bdc5a7393ddb3d9d8520dd6bc315c0c57ab4f84551e6c4c04d521a70f5e7d704561b70f4799ab732a42c79e765d61d7995c463d5f7aa357ff137f342caf4f53645fdc93c4ae4ec163d3f5a4c0781f21ddd8cda26c7da2e087dfd33aecfde2f2328bd130d0d379971d2809f8a72a92b836a9b4a3e2bd5ede9285ff3104cec43c4e436f17af8c7281bad0d3f908a3ed23601149c85ab6f79e349a6b1274c9ddc6ecd147797c000a4805ac60b51a616ac7ab58ecb36e478dd2d6ee058f1dfb62c9a201e41ea1ca775883462aa9f3ed38b50f3ec060c8ec091bf15bb1e15ccf10a449bb1acca5bc562214d2224296dbceed48399462db1fad3911564cfd646fd392569b9f75446e8efece2dc6e3c19962fe00b292210f8b4e75708b95d0cad3e55ce492e11598674396664b177f04659841da313cd62c5192e7b0d8ab1b230a6c3d2e745d54169534895fe5107edc4f4cf6eb05ee94c262d83ce5679b561ff434bf52253fee2a726c556afd200a5047a7c881e6074d846c2855e9447661c5f6fa164dc8e7b0dc7b5fdc93741a7a5c1b40dd9ffdcb4728044b3ee12f5a328684fc0dfa332ec4c72de8739ada0f3e43953ca0159dddf76a7e61657b30ae4b87e0af6f6c1bf43ce6030818a704c5901c868e515d27791d52c8e748a79833121c358277265702e19e2d7d93b7a10fa55c627a932a5eca85e5f44b8568f438f5a95f7bb304560fa30a780aab422a419996036b9acf1483884f08cfd644ad9865df8a9d5c56bed81c09ce2fee9aa2d268fd9b6ad203280b1e73ea67da36efd3c3ce90a62499d6a2c22b47509ad6e5d1eb6aed96511b7b9682132f6b743e570d2309d87f0877defb2823d196373f8f316943ea52898d68e9c81ba01c2a50573fb352660066ed1c417a45d57069a05496a27592bbbb8e2de4f79f3b09768e06d6a1f3e30183d705cd46aa406ead767c3a9b9789694f6cc7cf0288b9171e95265f38fbd9d794986e1b7f1af5f572bb5f00d9c0635e2dd8d2e21b1612706d4927ccf2f030b84acde6ea5c49e5ccbc204d1715f28cd53af8116b7f44bd4a0789146af5f7803eaea93b9ee1635d8c3f15cf34e05bb66ad2f77740ed5a6622761b580e79f6bdfc65f48ee0a8e685db8a0b456ea5b5e4699f873e3790d2f4f9920d6cf71a94f779430ad16d47a108fc7e9556e8be168f837423a15b21c0cc00064f01e4be61b154e7bb1b2dcd351bcbaba600229e2aff6e03458d6ac4fd5fdd3fe20005ce4db8d6b1558b43ad9415cb448ad2a19e6312de5b1dd23504460b72f38665d9c68d4cc923802e936fbf15c220a11e1c33a56d0ebecfee5be8f5ed672aaccce351edaa9ed5276b0b30ed6b5c9dae3139d51767bd529005d10c42459aae25399a149446415a00b0a29efffd5ee1910d88f8198711cce483123a293cb84e3f494fc861b9203381148970f94ef376ec955b58d9842925ab96c4c283563428edee6e436a006a632a9a76d29c97383daf5f8e5aaa3870695f1a9acb20bacfbbb22491b3ef561f95ce9a87301357902f274662de87fa0e33a7888ccd0e853e5814ab832de81e903e31cbefeb7cef0c6ebfa1a18c9d5b0389aecacc5d2fbb2b46eeb381fee45f0fe49bd41f2418b392e9ff47582a2d8ef1807cd714948286663aae4eeb409fd690b7294f65f3cee7f2c1cf098981d01b992710336e120a5dd0dfad59a3407a54e024f5cdffd40e5d771b329abe0fc2365afc056e9899dbb3d3112c0e4965eb66e5da33f2e8de42451fc6779ddec844712f5c885f4312fd6faf4821febcc9e655f917ce35af63328b0e34328d20c45c2322fe1df8b6105aae06a173391a22c54650a1caf0cce874f9015d9c43de49a1c99985aefb1fa7e1d696093ab0fae9ae9b394268930313265a004bea75596cf0034378e91c8462e65c95ea25c528a89b5214da29b76805dd9ed3b9c8315c59558c98d3024f66b441b74ca239bfca758f0a7533296db191c2e0353ae2c8ebb4a2a925162447fb80b3470318dadd0cfc9566ebb38e2122fd2d90de6338eb6497cf8b49180ab3dbaafa749ecdd05f2137037646c0b63c231ede019f350625526b63e579bd10c3ec731b30fabd744eda0f7a2e9acc81e89167dff2d02f92f672ea53fb9d983627618a0f19dec036e680dea065f19e703a5fed9ecc6d77d74e53388c6b476a186a5a86700dc9102eecbea2c5229a1de7dc390eb9c7205826daf1600c7ee3ef32379bbb4ead83ee24895cfc66160ebb0764ef67e985c92787e26c7eb1576bc51d28140f1a354a85a14c0a08aef03201392ecccbca1e447354afc5f23e7917449870ea80d7de098054a34504d851020576fa4fe35b6f4a095fa5551265bbb08e2485bc4c705637d49b22ef0616e1c6e649285a0cb20953d5b007aba04bb176259cccb88283d2b95f2bb130e308048e0db9030fede2cfe8b23378b0e9d716feff20ab91082d5bf34c99589c0a106bef192fca8c6087cb6f96a0d20780d665de205af439877a928e1087aeb32e80963ae10f1018dba62bcb07eddbf16c378be72425bfbd529bcab132c972e24d688cd7b4ab39be6cf9ba7551b4df0e8739219b45d8e78f34fcae7234c1c0344244559c53ccfa0c87d3d8ea71c5bb5f8825969eacb83481abba624f67a63280d4aceea3705c234a99c54b1379da0faac5c8a91bc15710f90e11a4b8d4cea70e9996e8ebfd36cca0494e47d583bfa015cebaece9b03f0754b3d3f54dbabef3cfa9f72b2919f86118e3fabafe6293b36d522ff25d837537e37aad1ac384e44e30756b4e6d7e5809fdd656abf46c67f8b7d87cf5843adcf5c74e5fd8421e757398c5e1d8039ad616986f1a242d09c455b061ba15bf9fff3a888f23fa033564c4ea92a208e6fa2e981da54988a9e8d64508d6d255234a9fb251d8df11f262f44d956ec5a6fd66450126ca978fdcf4496c7b05b3cbaec4559c335f3f290d5e148f9f78dec91149f402609fe900c9887f26857f979155633752b15425387574295c04004aa0e492d07541125c1d16d6450f9df677a9618ab358560e67af09d7cbd2cf8a7817dfb6b44aa51ea5e4946f6e1565fcd500f2739da95cf20241ac042187244193922f9e2f07e6bedaab7892b32c30b6e5e77d2628ca6d1b68531383328a08fb6a312f03042f5f288ca3ceeb1dc2ed49378e9eaedb92588806d7716a723f60bb86322c13c12e3627cb9573d376aa5ed7469e12456d6b2521b5be20d5190cbd6707531ee4fc264bd15c5e5c9caa51ede7e97b0d579f503395c8b804bc591dc9b3d934d0d1356d49ef85764a5703dccbb12bb0d8c88e582e5ca71f78444ab08d5140ed8aaad1d403f7de65c4120b8c78247222e8f68487accb0f9a148f331668597814fa06dfcb036707da3e2f867475dbaac554bf1fb7849b50f469287dcaa8fa1ad386363f81b2fb1f2abb15eac632ded0fa31c793b50b150525a97e57c3fad1d9aff76542fe82e6c24454184f39659d39c36248f85073d46686559d00cfa7275a178aa88821b9fb39ac0b7f224af811f06137bbbbf643c3a0f8c91e922018fe199efdcc6b6b9512609fafd724c82717a85767e667a467ed1f8732ff663b406ac6bdcddb824fed7fecae221ebcdd2f253ce2b54818996829bf778b7f08165915da34020618445fa67f46c7d2b066dec9407a600cac99fde2cc92c43b2b3c5389bd0e26cb7b8954059327b110d139338c220da7620ace9b999360902e793340d5131a869b60d9ae7fb652316f142ecd9b9b0de70e105a371a30b02b4382ab0da490e900a1c0a22d57edbfe4a1fdab6adeb702e4894fca6c7dc70a35420bfee59daa8df6b9ac4525965ef8fc97a69f615bbcf82df949c05614cf1d4a486b37d3316c42f00824cb32ea2eb8401adcfbb885622de4e3d0d4e0d84fde39f3fe1469049aa2606f9dee145316d913ae21585683995c48dd88f1920cad0786187a123de7ee20408b10e7034ed839daebb9b83adf481777559ec813b1fddf6219ad0a238a30027a02064641dba06b43b9b3921a0ad0c81df1dae176b9d8f559e7f9452338a31016dfd1193ff34236422d9e96d9e42441554f2f97805cd62c97cb11e9be764c50a9df3eb83548883b1fb78fbe8306a2054ed6fa2105ee33b3eb8e5e092b0ea43c1f82b839bfded9fc3e8e8c84747a703706bcc87e42ff36e3406d63aadbf010176f2f9cdc35041ec373567c25fc8200315fe162e5811e41a3a5534b10f41aef6d89bf005f5433cd2110001834ee9033fe25e66cfb1538cb9ded31186b820e19b0f063227c0600af6bbd0bb97132a7a5a3d1ac2bce02a6fb50b111ba1d2aab6bd5fcd14a377750b68964f27154ee608987dd67dd76867452527c70fad744a2ebec165d6d4fa3ea11e5c8a2f56bc8d83736cc7e59546d5c7bde8833798e815d33d8d211a4263b1fc9dac3d45cca7678c9ee588e9c14b43441bb8c4a16160187ffa8d5846250387539f168493903464c4508ba3a089228829425cfbc1af0d3d690650d64b1d5d6247105136425b2d25182628b66a18c89118e5be3f3620b56da9c1c3ebab24007ceafc088475606c8be52163c95fc9f769d24e7f6a8c80f3723fb21220c385e1684bbd1b7d0ac36077abdb391123172cd871415ae73f820520117d1f15c617c37f9b647fd529f534c579b54706f76da28bf6cc79a52044fb5982431dfc88ffa84bc71b3ed76c4598b9e21358ca94010439c5138f2766501fedf5160eab46f2ecd700ce50a34774a2b1533dc1ddead75a1460c0689d4f87d34dbd8c92c03510920914f9fea031a7f13f439176235579b9f94b64349de6ed4f860393c492ba728385ad0d35398e1ff9ed3a4726d580f37b84cba48c5254c621c02ffde445efe1374d96edcd22e380df19d4bdffe4c06e2cc11ab92e4e4af0375379ae626897ff6d08fa5ea2a74045652c683070f19c33d1fb74725e3a34a88211ae1af927ded3382b5c2d8c2cc7dbf9e126bd5abcccdf3cf2b81de6793a0154a3f7d828139cc5826c0ad00854d6ae4f3395298127590bf223604cf65fe3fe82f33c972fe4307a4d193190a008a96c9370b1a242edda8d2487f229d81da898ebe4db9d87e383492648be2f50d637bd578ead45cd7e1c3b1340c934f88b3b2fdf8e479b38f1cea525cbedbe2737c3019744d31b9862aea05b14ce13d2b46bf1f6a8ccd6fbb667f9e3f19f8cc1b133c95db6498413197f2a8f49931e3e7abdb5e6097bf4a2c4387c5848de2128bc494dc418800939be345b352fa4fe8d6dd2ace0513e0824ac5d3ddf165365a7b671ae7589a1dc5ff7659b64c45d105950d05f06ca7dca387c77c58db251e0e1d0ae784801db1095dc25736156cda022bb1fcdd3e90a3a18942eec473d79877950118eed15081015959014a887a14a262f5769879e9e78dcf8e464b8372c520fcd46ef70f0d11aa08ddcd1fe39642a13fc06df89e9e1b7e2cd11957b734bd3ef3cedd27620b11da819bd4b1943d8523502539822195d9dba60642c2772e42c4b2620bd6ce72c70d49224d3214f371089f7f6f7efde91fb9110b253ec44136a69a84f324be869596aa70738cec8e50636ae71167613fd933ac91e61267e3e651f6540567f2187d6c5ede339f376975e05d398c28f2b3ad959e485afede8d87b6dca147e85850e7aaf4b0e86df6de532d5a2f8e97c10c205d9397f642b8cfde610c74a73d274dc04f0bf1d5603a7e311a8d100e9d407c2e3a19f493f4047dbf9e264311ee69275ae861ca17ab9f290cd907cdb6afdc5a38e1850a07cfc89ec4a318d68c4970cd971bd227888465556a23b47516fcd9356b7008d412042b7fa5447455d766c96ff12b50ad7b421f16b8884893bfe119eac118b3169f0f12f3fe3f0fd23f6db9220d528baea7cd1a214d8d046c4573c17f4abeb2a50a5595ebb4769be52d8e1183cdc8ffd9136846538cd178ff91d646f1142c7f46bf6300e88ebfa6017d127a5ce2fd2e71e9d22b8532ef21815d8057823f0b287992052e2c3d8101fa8bbf10db915a3feec3414ed0cd76e83b9c1163380d8c7f3894ea56f12a36099bbd922cc2b0f6fbe3ac485990676f35fd96eb035fb4c1261ef97430940e9133d255114ab9ec9e40ef050cfa69c2f7888253e87d48a4ff3050218597f6b122df0bd060ad385b75ad2718ff8dd8aa6b166c240a32cd8a9399bae708c58d0606c9d86193dec099329bafc0c14d61323f1a560b95759b3d209b1a7161296972a788027473a516edfba946b7cf5fe60ce96f2c7ba9a73807f73c96e782f7966562017518fd73689477957924c709a11f670fe163de8b23f5488664758745e879cdd4d8e323d7b60a9e0af3d22ac7a96d39088aee5af5553b347c3a86bdaabf0863057be35ab16be439cf8f47dfbfcf4e6716a5b9411efdb7778ff202be4b5f112cf5d67bde6bb41e03549c03d82d77a488b3520fbb16a7f73cff76d688b376da6dad6f7bfd48ff157c23697bca5317711981d0dde882d21e5af7be67470e82d44b31454936f6e77a18d28fd7b8e4e3b9cca0ba54760ad517ab5cb082ca66271c96d572d7d27451d8d0e0e3b67921906c9e024831e1b1c23befd211c46d405d0b27b8b36d007d5eb2a0f486885675129ddafd6d5891224a0ba254cdb8f5f460de9663d7ea07d50af176c8d3c4063fa89f818c441baad544ef8008bd6a92d340cd92a926fb04cabad40258e13704724d538fec295fca9775ff7ac0d641bbad43acf57ce63e8d0f260f0680b171a2d012586cfded61382ea24571a809e3696509d49e29b561b777d6cc9ecefe2bba87150d4ab2f4444247e40cfa546fb179cf0458ed69f641eef2295a1cfbb3ce32a9e9ba8bdfde6d2f71016d9a204aa90a994c4f5a4a0fc759a1c945495f6bafba00a9a5b512f6f4c0dad48b2822f4d68ee2cd0c9184c9f37768d1eb06b15ccc3a5184df06d9d445601690bc5e267239361fae52d848b224e1ce5bd7c87cc22d38685289d71884103aafecbf0f9081da8e7f86bd285e15ca2b89cdd8d04830e939177809b2112f5f31a719637128b02066616c2dc55e4718634106f16e42871486503f329ff92179a1e1fdbc38725f4198d27f8f46d8b1b01ca0cb3ae47cc39904f34ca19e3707019c089c10e60afe5e8ca41dc0a41c4036af274fd0ee157426bc3524e4fc8324bf332f5cfdd23d64b27b750b0c396aee950c4d7dda1009620ee342a0af43b2b58749f7e8ab99365cd3e8b22fa47fb2608c6dad980756735eb342556219f246e0c9ecc10bda7e1eb97973c9cb16bc1d0787ebec7c5d507d858198b3d1a888180f05356ca786fd0570704bd5978cc3928755fd8320833ef4ca32a0e5be00b49ea4d5ad53f15bff7cc913652c411bbb1d3af657c5ffa69f4c2f24289f0e876d6c0d243a22a8941c6d1df053ad9b251c2a29b10aed4e7983620b3dd8e60a822db64ed3b1ca488523702d1a1e304e117c1e035e3878828da907c0e83d5fa862f113d1172efea7410437edb88e4f98fdd94ab9fccac99bf267f6c6705cd95a146bf3b25cf1e81541da741cd55bc94519ba53f32d81c8253268a8388c1af51219543f9c0c7fc79e1d4b4d29812fcad5032486f8bdc9bf9d6dbef1f9422d349a45eeb10e356bcf69227c128e5a45c44c73f868ae0b0c2bba11d4085f41fd01daebbbe16b8ce9ce261c2d7f3e1c817b34934e89b4864c1558dd100bcdf3bace5bd1f5487336c4fac91066fa262c139711be5b7489d9a6d42a41ac00460b42c7d3dd6cbedef000929c6b493c66034572ae90e89b3fd63cf6651e941a4fbab570b9a7aabe5ca7250325c0f9a03ef54bec8e1f39c6e95c99b400d6ab706bb2a61927797f6899159b5060c11ca833188b043fe7b5a7ad0c19a336e60aff949fbee7881544d4aeb7e3c1a2a5486c8f6d2c40735b1d25e0cff51f626c7ad7fbde8cfbf641a0e2f0b45fc886e39c574eb679990bd77909303c006bfb24c6abb8dad221df75cb2db1bdf2e7886f755c10670fb2c6d0c6e64be2d08245fb116934e8406d54df388a408b10ad2b920ec1d222213524bd1e88daeddc27f60533b30658332d7b5d4c19b0c41c21560047e558505d8f5985e1f52de86e8b545caa1b9c3f7cfd7efb657e7f936de811aaeb57423ea6e1e0d9708ec7b42e4201f632d6ea6aac77c8ed3442653b212e2ae0075876893900a2cdef7135f4299aca4a0a5001d0619015366910e3378aa265e289647d3e7d5a0dd39557bf7c798e6b74aba8a8b023b412eb57b69be6f69e7573d186a06664a32a769c8a649a71b97d9b907dbb91228f80d794d0daa2864bc2a544cb7633b5c524d8910a3c428022532f02c8be806e35baf4b8eb017176e70ff93a7c317834ff9c38a5f39df2df2cc87b6998527ffdf9a168092558e26787e79e1ce5f970d5637330f4dd620212ce42d21760b04afe69b727839c222ef749fb4af34ddc7f3175854c5f3234c17de9d04b5cffb04bafdc0fad90a1a6fea59b22c7a3c28e6dc762292ce13b24041cea8b6691acf9080fb46e6c659952abdc7cfdac010066ca219ad85db9d231ea83161c1a452abf235ebfe76a41d3176c1cb9fc1d5bbccfa39bc6a9bb912a920a453a36bff8ecc0d2a39c8713e2eeaddaa9c092fd5c63303b93822fca676469fa286e53311213b1015062e895306e657c48017d73ee17896a58af920c0e5990d0f064cdb33363b62addd0a1898d10234611b39b66f75fe1c8d5941e04d9f31f6d9d1568c13a742ac0496eb33037ee3568f8ccbff934c74effee2c86984f5be7d3081c4b7e1f9f2348a98402e151c4901febd920ad1285068439755cf81a8896f24075fd0c3db998992fd066a1de0a83edf4d05981aa52659040d63353f26c74cb431fc5c1c890a1da0f5019489828a022af786bc6e36458667a2a44fad0a526a90c107476b6dcc03ceea221f0ad0320f1c0b507d991c5b07f216b384283a40bb8507bfad023f629ec58e000997c45b6c5d3af55298698db7902f542e10e99ce73dee99f1b0fc7e0fb9a5181abceb1ec389508bb2ee383f6c31015a73ec3b0437ea2f0e2f1d9acdf45506317666c5dd1cb022b18ee04df04a1001c3ddf39c0b63af9d0d9ec8ccd78023d003537e335d7496e9a52674a1283c375b19abc5ae06c2bd6c1924f73a8110f6b94764bbc0f73db18cc9e478a4d9eaa83f3d54ead09eabed3f2b40acf0672b7e60ff39333d946d64b05a052af37203f88bc700ca8845dcd8dcde5a52e9007a1fc16d6a9305628f2ba982ca2d23bdda609d516e398e6bb9d12a481ca92be9fb489a3e5d1b42afa5a601d1ecabe1f73f0879cba0407623c8b970bc428d122fa92bd83a01c2b1ebe03b67ae520ecd56896164cfaaa851a16ab0adf7c4bc7cbef367354110ee0f1ae0d74ffa3aeaac79c1bd389309a9b1093570d63f279c1305a555eaf887e3d0892e0e0d4ddd9d6259cebf5461c6e1982db332e2f4b1b6c8c4be591abb00d90de91d2e550930940812cedbad427210b7b7daf293d078c3da2c2f26a4565eb343fc199f6d3bf4598005cda56595931aad923da367b8ca10a2ce928253f12e6b9b1c2cdc07d42e674c4e5aa8e9fda1b6d1c17444ac42eb0a24a50ed1d6bea8eb368d660cce02154a4bd0da417735b2f6e4806e9626eacec05288c9148858d63058f1cfcb543205045f4471582a9c764a6b1d280295c2edf3fe5ad02dd34e4e16cbd590cf5c5e3bdcc690c6d425050c8da3d74271e5906fa8611eec1fbde82ee2fb2f57abdc461e120a1b4413357d2c4ab1b39af6558e14fb6a39cd4c06ca511f5e4a0b2b08e60e72af7959e9b6feb0dd3dacf6953c948cf2981cbfc141809e69ff0afa90c6bbcd24b5fea854738c6336a0fdb7324cd74dbc64ae8bcaa03c93edf0a9d264cf990663afbd621644b299534b7a5314042f2ffb684491cd4c1956b5f646aed1e7b9adcfb87da62ef30cb3674ca4ff560d6af2bdd943072c46146f7b96ad1fd428295d77fd67fee49a9bd025b457abfb695f431774aaa9c98b9e7940ff00eb3e1f336a9a95b640c2168134bb5eb0e55af1ffbb1273aa97070158c036e901fb58909d7b0d692826e393d0ec8d3642f94aabf8de6ffe879ac6fdb7663a4de827d2295d2154f385cf2e5b3b7757212c295e814ba5a0cbce9e6628202501ae315a2c2569f945669fcaa5bf62cc14f1083883057c3f65d9053a3ff778b9a44a95833860a92720f42ebcd28ea3b3f1011d6abb81e045ff7dd886112afa7b77af010c8c7313d2598960b5121ea222bd4667f1ef65a9fbe551f207371ab8933f67ff3dd5f4a3c7f47a586c701d2b626f781a80ef9aae84f9f917edf88d1fee52192a93be45977e944f0791222a86bf10705c2953333a594011d0e0ffd6daf6a4ea27102f1be196f6941dcc883e99998579d2f3e844d95fe0e97cd25a3a9d22cc361a94ec0294591f2f5dc579e070e485a38136a486f3bc350152deefc0e27c3953efd400939d9c077b835d82007a7dd2b140eb54da691900761ae71994100371c97b34d7ef3365ae812b3414b7911ab02ed923ad9b34e34923c92fe534536da9d39bdfd726246bfde68479df0c5ab5068ee0263280e930bd8a29263f84ccf871a2679399874b3861d00d1453dbf9615dd0784b029fc2cc4afa88f898004371d200fb57e88d9f1bde11075f1178df4460fdf7d5613350e338bb8dd133b2901283b643a3f995328e4025da650503dd03d4cd1b89255051aa733abb687cb284f8c6be1a78f8bce498f4af347e6e0235ae83d6e58cb5f0831f1a864a97e30344897c07b7598932956ee5ce70de6e02423b2447c9748f93e1675e8fc82d258163606c23430cb5205eed612e01aa7466841d71ed9efe252aa33cc1c405884c1d01a40636fba9af966298f05bd7cfae6c353b0b1c83680241dd6edd9f46e667444b098e6244c1a593835f0f9328024d351d1a8202d09b9f6ef25fc499205654c01272913a187f9783d7b97f792e776fc63b5df1f3cfe4281261805619a94daae1de517af5fd2d9b4112f9f215e219f9b7ef5c0f78fc23be8b09b05e1154444dbdb6e5237533060de2ce62fe8c2777281dd7d4a6ea0c379e17a22dc8ef603a34677b1bfb4bc76cfd1a247fa34cc7487fbac798760472a0c1874793adf1c881b3a78f0a9b0eaedd37d71040ee5cf4b8ae47aec74b17ccb7959669bd1a94ae615eab421fc108b973fbd3fa97d5966b7fcb9e54299af1ad0d9e20ac679c7830172984c5e11d172aa632c8953752a0fb45977edc148820bb803977aaa54b5adc5fefa85f0e5aa62fd6194e79c807f1edcf28a96a8cc529f1a07a6117384cb41f7987b5f89e7c8d6cc881047720ac1ecbbf0be0f591a511e20e52ed23f83cab6419419a952e651fb649920c3081021b9f8d0dfc966e1e9b53f17728d4bb485b8772d12fc8a51d6f8bef3421d1a5a78e08f8c5cea54f1aa35f347a574a5598a222d437331ca8d7cb1c68b53da4cb3e668551d3b8c9efdd7e772e04127ecc8187139fded2f6272ce5cfbb148250bd39851a64eb65ae894f26ce66a2b46103ddc7cb3fc4164dd80770918f5b6ca75f3899dd5322a98accf9f4d015bda08675878c93cbf9e3fbbbd121e25b665107ed5a85e67de880a36a0b7a11cc6f61dd50a9d5e55de46770463a24aa46687b5c737a66938e80adef5999d1aba7309cf2fb116dd2db2a18be2d597b275a48f26a798f0b57f09fe60f72d14fe52e7b01bb178e457b00ddaba2eb51c56ba4708cf51edb5b7c964ce9af14f68e2248294dddae1265210a514e81aa065b747997dc8d802dc849eb5e11b7a96f66ae915385498aa6c695421d8405a1dd0d4fa244b0bb371b421ca9b00360afd31fd505cfed35c723cf8ca573290ce783850c9f41b615ccbad6ed0d774a660fb670b5968949ef85f60cd736e3785ac743be1dd9a2f231394eb1fdebc5cd4ec4e2823c63903efeed18c2d65340f404c559a0b2458281b02992ab9db071e38fb43780a6096aee942eff8611a13076d6aaef8facc4faca5f229360095f947cdf4b179124e2762d3e10a8cc44ac2397cfd0b7799f9109825e5d360b0c74ae4a22093adeaca4195d0ded5bc8bab71acbb7590551494ea6122e693deef0e70d2032530c4e2c2911e0957f0323ac87c615d6109f3c3d30a5585e29d9223aa2b373a15b490b885cc47464d4ce74f1375b27e1cd7e43539c9bd333876c9c2527000f4f38a3485093f97bb2b279101badc261f4d1d2428e0a4dcee2349c8d2462bcad24c240c387d5a3ea1d0e33ae6a5d9079b179f417c3425914979673e29e2ff8ceae542e7d69835e9f171090b3733daa317d2c6230c91f526ccb096c128f259634616fc28c1e8f6a0edce5a65d336e2a35dd26b157704a97450b837d5c8f34b4e1528854724e0db4e383cf4bf1e598e7a39758cf9489fe26ab750c668f25f5833576a97af3a71c0f652ea92d04a94529060362e7778c038a0e63cef3c85935c295c4f2b3d35ea48260e2e85c3f04a5116a76bb123af3c30aa663b4e2308d9a7d46928daec5f6096978b6a33fb69ece2b291fa7cb14c2f6b47b72786bb07ab38a3ce4c7f5e68976534c2ec06e91535d0e5810e3feb136a59a05833648b2c9f2eb81ff704f568d89847356569d219e6dedf3c2c19a24aa490dbb8054c6c13e040dca0c21db2d41251187a1fa0b4b18f1ed75a7ad6ace4ff63c5e8aded9210c906deda668c83dd589beef8eb9300e15912e3bfa4e9262cbc760d22e5243a3add3b7be00fee3807cfb58350b9d8fb5d2cb05a33ad0989781da4842a524f755e166e85d4e18d980175ebcbc7cb962bda6df60c6b6efd071504952263d05c8792c8d454f6f38c55e20c6b85607acf643ba8803918f11d0c7de68337ce7f794e1799e7df19f780bf07f05cc55438d877f34602411903528baeacd99bc4170271c91b957c17af252766a3f0fb8437d7cc9fa33d69dde34373f33114ac12d612432678f16f75c04c61465736735ecd92d1ebc0edb002baf7af7e7e2694f1501e0672f95624d26b6eec7ec9de841dafe743c655863b486e8ac3218b01b9c7c9766492c7ad801883b59f3d66916132069ff43e7c9b2fb6caee627cfda47aa9ddc9542b1202b02dd03157e0fdf7875a8c7901016b2be7b5ac7bb813e48bf05ec0601955c1d7a1a1522782e4454b63958ace7295ec994b424aec3e94922929de4b16a346f550225b5f58eae5c799913d1081f3b28e113ca50619cdbab1e4eaf789faae70d181217e84f868e1e1dd46c5836f8ea771aa20bea1477fa0455916a02a243a23b906edd977145fd112c4f6e57634cfe2bf204a2c8d105cef803466c75476c77f4d735ad5a4aff3640aca3a9fa878bc92a551d096a9547944b00019d305ba4c9df0a69e9e00a575e38c9b738c147ffa2693ae3b1b3caa685151f7666589386daf47e10f4d28a9a2cc6a8206536c11fe230fad342378a450c1175d5c24620664a67f29905dc412e489bf3999bcd8041bc9fe3031d9244318e2b62677b3743ae701ac0363c4909749e8ed51e027a785d66fd0bbb54332ad5ff0ee1afc5170bd6a7059f03c7dfbd49daeb58d8e53efc07ec458ff002765a5b8d03ddf4122a12d8995a44b997ff1efeeb9a880beb05ba503f02eb96c901b395b7db9710ecfc5851f49388783d5b432a1e0b1eca8da66754d3944c25030cf0797a1a1be759cb8cbb4433f6718fb5f32197f6573d0c9204e52fe099c4031df37219f322afc5fe8b5af5e31dbd2c2189158c12091ebe3314e62991a060366fe3040fef86b99135d9555f53d47e61642e8a242176e652f7df37485de008286197e8b76baae36b916a35ffdf3e8d84614f7b8619abb6b0c94792e9967c3c6528efb43e3b26c56420013e7dfe5f2450a2ad005fbc4c02b1533d01ea3eb3b773da78b234162af141827539da9a2d6c427da95460fc11b5c3f2cf1b46a3bfbf582bdb4d6306b215ea623da64b88439153edfaa6755bd8372ac7d73f592585b2a7b95ab7a14bca9d354a4ef507c12bcd5bbff41d3d2ee5947076e04bd85c1f6b7c9b3d077fb9cbd3db41833aa8d7e54d8c9be380e8aec374d1c15423ae1c3c1a79d5fbdbb15013d2d4245e55ecbc5737596ac8df95825e75c763e18689ce491fe490b5a49a4a62a148c0c674a1384db7e4a085204d74eedd6cf963b8063056b96cd8e2218080a07a81ada5c635f92db583071af084dd8798ad3436c47b7d06cb095cea184a9e79fba46c69313169cf28344e567446bc14faafa58a562316f9e597d211ef70ec68c153b0cc3cb3cd763fe3e91a9790d9d1961f9787d1bcec69c05aba5f55111e67559b709b7310c1b37ad2a4fbc8c4b92683c0642d383c8f30151d526114160ee2381803c23505683e9d336043aeff81e28faa5a296b18dd8a30d34e0efca7177b00cabc8a6899827f652b5aa5bca1f0253bd60673024883082a62036da0f5b875eae954ab3ff8683e4d628e1f31eec38ac68231badb44e45cec35c0550ab3aa9f11265aec5d8c8e5652f1f0108ef90c7fb05225b491e51c9acba16b96de21facc8c12ccae43b0592ab485b3f3e6c0de7d12f75497545d6f1ba592e693bd6a156c7d027fc9bad59d6267f8814fc8960317b10fa8068d32f31e457dc94bb8efd0b4d53753765ce65730cac3bf2a4c881a67b513aeb6fa7a983aa6248ff66411e459a567fed5bb7eaa5cd96328afbb12378c35549ba4951e89f0c10481e33048cf91ce6acd257fa1aa117488a1366364e624206cf4db89ae5cf525b0dc7b19349484217b970ef1dbaa5bede48f0a9bbc9730e477dbb1fb66ed1072d72957cba0a9b940ffb379d8c8075ad735ae539b6d2fcb73bf11c542fffed5a5fb848cbb3e9505295038999a7225789bcabc646e9c712e6c121a654bcdb3a8593a5bdc7570b683500468f40f6ff736c631e1be583b2c249e0fa4df190729b8d108b6c268645fea430f471e9a1a93ac94af1ee1c58130b6f5cfcf235093ccdc5c79a82d1244efeb5a7aefa9e391174a6185880a35d7ce486c17128cb95dee77d97c6605cbd8e6dbc8f3164067b33be15b6d9239f7ecedf06570818004ddc7c79e1b04e3a73c5802eaa9e0bf1c775c73dafc56542e11dd6729c213b5287ba9118c1e7166f90f5be7ceb18b04abab8f83efcd876c7c4ec7064faf3931e2506b3dfa7a05caf020933bc7437ed6a1e3c2ee255a4cea918a966adc396b2c1179cefd8c520f909f6864019d4da904872df4732bf1e9b8371bc2a32c3c148d515cd6b6b035fee05cf9ade8c3d63b7f472d7a9801f64cfdfc9ce9a77965c296a0c0ef2b7601deeaaf27517137372ad8473ea54834d525c620fe1d5fa72f7178f88bd98540a644583c72c7326d066f8aec4fe1c0d3c9d38687cead0f37f18f2f28a4a99ca191135303f4b1a21fe786169baa366d9f92f2c4e398d6cae7bb9969a6f3224910871b54782935f725e9a04ed2069e88bbfab47205248f54a61a90b50b335d3dde5fa1839778b252ce51d47e69c2518692827226af0bd64c9cd80c87f0602ca6940638bc285e2b2374f2718d34bb49ff2b64846faa99007a5ea096c0a00348c684498567d37de67e60293210f0efae86d4b86791cc0d0a582a0e72c081e132c6561ff661b8d97c97783b0070d6f581dd8f6bf8d5bd02fae2f06f758023cb25a728f0ac75b5c2a401aa3eaf123b17e6f86be7540f395b28e7f20445b934447f382d6973478adde1cdf2fa7855b998b4dc1dfc49e2bfb21d7e07e2267cd157c6141896e2eed8f4790b0911be8521613767640256ebd3fe57d23cac8e4e4eab431b7dcab75b49661ee041c5aed549cd4794cdda32f93e79fd5fe982f38d55d19e930711135981ba092f92a787fd1445116599af37f0662f996ba26fbe738cb5fd2662dcf61243b6365bef8040bbc7c0184cefd9a08b13e23abc18b0fd1f0c645ac390b0883d53958404343c2d784df7cf68ecafd324b9ae4af294f5781096571b69cefc18f2473f4f3b5e86f08137c3d6222fa79496ceed128a396e7b63455777db44f661390a563b3f8927fd65ab1f3669fe6830bfe7f58e8a1f7bd509b2575576bd1e1210ab4d76c5db0920a203a7daacebfbe20a4bd88b733bb87dd2820ec1f1d65d3eadc0a6261adb72aaed96e462735e2c4c56319d9cc05c62d42945f2366af08f4e3f4a3308f0311c0e2a5c6fa71639af45b084475ddf98c039081ca9b74d60dd1b457a43db3bb6c21c011a2db8de86b85e40e9965edf23a77b2cdf0598e9d41bdcbd7de81c552109f9007ca36868366613065fe305a1ba44f30d10394df3d3fa51f4ccb910b5b60d512901aad67d1c09687cc1f03f294e7376eafd287f2096e3f01cf353cf91f0d244f946ddace6b7b8be65eea6389587453f0cadd98369f886ef3b73aa2be3622cc03718fcb2605332a4aca42f2703dfd2c2b42c43f1238c92023d4767830bf61199241a3ff027056a05b2ec96a251f41aaa191368a7bd2fc5afd061cf3eb3b26ec801bd152cb7ed4440d8e3c3d79b46105d5620230d3677cab2a89898fdf35f0394c29d3003ac102e3d786a98c4eb25fef314f27c3609e621f693d4b14218140dc1bc50b78f2ff4404a9e74afbef7777fe88847326f974ddf423498cf5c4e61433dd910f131685941a17053acf52942690da38dd76c1fe17ee2b5fe5e0eb7564840af276f56d0f46149cd5bda9904859cf1a1b9b4523862e4b0767230a1234a34369010e49623e5b54e2c1d54561d9419494e02fce62eacd4aaaf08071801e6d1d7c7d5c51dbbeaee27b79979f62a1de7c5e780d426b120b0873de0b22ef4cc204ad81d9e275ec07d2dd6ddc94b7d3bd6a56ca5601011654cb3461b6139b6791587ce1657fa24bc43ac61d644d0d085b00b275a6af8a19ffa5894c98d2593753f71eb185fb887afeefb9590368efa894c5e4a9d27aad82563c98bf56de21574f62275c0fd7f113842eaf70e660ae88e603d6b5956847d7d6326b60b5921146e507c0470d159765894551192602e3e9636c2475d35e9f2248a502c16c4f6940930d0314b0182ae546249f0661c592ff9c91971d51ce73fbc42f15b2d012df86cf40636632fed3a9b59e70b49e71dacf377e7b3a6961af6db8b5607b513a0b26a7b3ea532f20d5a9931c333d698f329b3b0dbb848f3a590d32630b3b39eeddb5dc837e8d4f38a9651c7e9b91fcda16d5b4d38c40263e71a8c06a5f877a21529bbdedf7daafa6b1d92591b256c4b883b954a1b5f44cf52b07c54a1d9d89b1e62a40dcc9e5cf6270a280ed21095f9d9a3907bc252113ff765d17a82eed202066c735d8ac3b11a2347f75f199181d8be6f68c963d4218121ca556e869dcd3e8e8b49f821b751411f78a98edded164547629d2d176a4d63b06368d7e190a88c8a315fe8488a2e7a575490a14f1dcbe813d62fa5de190d592f8ba9428860bac9aba091aec76c8a8a2d72b7c56c762a8c8622aba388279fba82d0dae6d827aca1dc48890af993ccaa24d4d18a4fc5beff62f7b45a9d15e6f6dfa1812298841dcd238f80b85de2e549146293d7bcefbcbd2087f13d870a8634702567f3ca5cb3bdd04d48056aa25181e0c6093692bd7a3115836752f2cf01d428ee8c9dc6b2217fb53639577c58a6a5a95f2ad695a2bcf379fa84f39605c8119d48828b7726e79d3925dfe37251a276205c8a2bc89fda3d7f0f6f72749aefae0aed2bd91b865f015a4483619b973aca1c6e0799475347b22292fd37fe97156985f1559434e9022d1e6cc6e2b116c4fe6e343c9091bb34fa3d065102aeb95f854527949adc81f5afbed4ba9684c449103448e1dfca6bc877e5e03669a30b807672844421771daf5d8ed20cfe30f7a3bd5b6a9684f012a5164604b97ec146143706cc7d7e354093895d796f7aa1c36dfdff37c5b5e21730a912eff3fc7f138a32f1c6a882bc72f16a52406743f0cc785486dde126e3681a0aa62f4dbadfeb2263f9ff5c6afc003d79d502a408d98af333307451c33678732d9c53aebda4227b99bf89b3524bf96031674faa64379a9befb7d0af5ca5a29d5b033328f38fa324a490037a06c67a1ff4f60d4c3a5d95e9f695ba182b8e97604d6623e5d0739da256862cbf8da588636e6a255af372b1d20c361cdf56a48e2af8278affee7532bba3ca48905606aa71b5dab7ded6f6f2162cf12c1bb9c96c32dda67010c6c70a02bca5cb0edfd8cb18b4ab2af7e9c0d521914d2a0f821542827a9229d77ab55b3878529653292bee75e8fe95921f2ed8722a908dfa4c4743e1c9d420b5626ebc9de06c787d3f090e178632f48460fc4c966d97c4e6189dcb7b3fc25db363b47cb6b971889e91f2583e588ef7b64ecb0c23b53250513d2e1aa225826bf3d4db7f6a91be35f8ee164c2ad6d0ec87f7d33f8011c9dd1730668ce0f873faad58f7440142783da8c3436dd16f85bb6c5607da6e6789ae7048266416a180b24db06be87f09bd44356d88bc913171967b22a78af20d02bf0ace0047155ab96587d3a89116cb213aa48bf1a86273726fe6b0d69b3a2cf04f3317c9ee3a8e4e14ac5380a1be667e79f4cf55abd290f26b8f158b527c7c5e2b06007fe980b1adf3986bf59186173f366f7d45e5f68200dae15115937d981cad07e69645ac397630a6216b22684cdcac6f928a9d1920570833095a947be306b14cef54a20a594b1bb8bd1916ebf3a3b680dd0b06b2b557f3241d4f975c356e9497cb468c27af7da56da48cc934093c47fff3216040ce357c98f49b9d8beb07d4539bf57ce477284ce91490db86e065b7ac80cc6fb0907bff8b2355cd879dbff76f7729e87a6da28b1574b4e6eca121a960c96a60e03c0741c5f8164b80ef0a1f0ffc1d5b457ba820f6fe3bdb88d1f6e53b4d589073da74b27aaf021a45cdaac7464953101142c6b93d3d9be627665778f9adec9997f1566ec258ad75bb73d8d648a19b5541f9c0859f791f9ee1b33eff8d917f5dec75c7bbd2a895000d14cd34c1c152456df9c44f1a9dfc2456690221896e14f66b25d71a6a3429efe2ca08007ca666f21232cba63a14b91d3a8e24bffe85a07b11cd5642edd8fc577bf389a33d2c8e100d1b7b3ab40aa667d02396fab3f86763d24e668b935e57f47665bcf2a237a05881b03d0faa29ce5c2748843fa2ad5d4c1947b3e66a687b6e9b024454d594b28c4044880c0b7caee2e3fe3143eb27fef2c410e7d798b195c62ba303f61a330833f6ae0c5a97fd7857eb04f15d42b3bb5f839360437802ad1f5042674118cf3d8bb068f11f205c7968c427a92759c45cc03200c5e413bbb7333793c56be91970f7baf2721d9419a435cc089a4c81d658c95521ae51731e27ebbe0f3cbbbb9edb65e1f6dd341dd30f3846b4d28a043f7590607081ecab78b12b558cbfdaa2d45c748aa79327d74055b95511db1b18556c266184b19983b79cadd84087a2b4f0b876b71fb4d19b965ed011f80d87e15c806c466f88af7571819ced1e0eda1e35e2c70a4babd3904ac49a25432993661a904563ba707e266b6e1838f0b35b6844301af23edf4a53e67db143ecdb60c1665d33379678a3825044b62b9cd3f52bd22b8a14d9d7b8e5221f11d97b1037840c76ec89daf0521270341ccbba148c31e4b87686778e8967ce7954dc42e32fd52f6c1e64b291189435fcd396f4fd7f3296c700fcef9629f06933ec61c40fc2a670fe0767407400ac1800e91cb8aaf97c6ec42eedaa10cf5f632edd388104e56e5ba3d5f17c2037049c86463dd2f575357a44bb774a394e802dcd06cb40850e1f4f4a21f55cf23d7c18470fc8cf9372d3c2e75c328ca2a1774155faa2529e1ddc5037c470dc83e3db5052f30eee4c04efaad3e4eca8a5a9fec7ebc3a5befc2064642c2552ce70e2ced98ef2be668a6dc627ce7c668f80acea92d771d576589baab5c4e4dcf5e8b2e965c1781ad84f028c8bad16b47ddaa9e33cd4685b35f79a967ce19e6a1960aa3ff0217866e1d849057db7b63798017f7a75036f257da5e9b0aafa1d58c1a17e3b1cd3e2d8c872351d1362790e9ee3e687fb1cf061f0902656c4a78ec033e6c8f4f9a6a93b40b62cfc2cd286bf5f125a2e20d0c724d4757b43bf280ecb17878de99ffc6ef3782262e24ea7a523bc6ff36f223e82bfe43580d47311bf8529dd6261e83d4058052df67e770ac84243687043a8bb8eff53ffa83118c5617fbffb5c473f8ba140bb868c1f8a9d9761a7814a2f8b856e08aaed98126b9c58496618037587cfbf3ae3804e060f7834e573355944b0e2a0e36a4a076c4c328b2454eb9d52739bad4c01906aa864e26255a19e62513042858c1a56549464f17f34325e0e085f7b4c49b4724254089ac22e48f83c053468203a30eead7c23df059cd3099f1727161c71c82033d6b38b57fa44279c673531a96c665ddd296afb4982055ff89f1f921454720228a52a26523a4047cef6122aa1fce88aa8260999caee290d77d7001299e71765ed4407ee40291e53e2f9f16459fe964672248cb6981dd137b4df04e557c94a75778d85e701f5b9444f50e785a8c937e836c817ea52e54ecc092615777edfcaffbe34eae2306470f6b91272890187d6ed8923040b41f429f71e1d79f1769f84caea35e61cb40cc08130d64e6db429ef6ede96f3a39c4606339849fe2e84a8f477e5852d1894f1af73c76628223682fdbdda00d575c278e43e0c47d431afe3ae5269cd774cb0121a4348f279d71222fce8731292e1b28abbad4d4435e1a2045e869b16285bc040a8657218c7995f93f07d2679abdf339087ee3e1f6a8bbd588301ec6a2451bef488afa553af349dca8f2a70e32ee262134e911394e4f3a59cede2df6bf730d07e5c07f58aca695b9357e1e24852ce9d249646fabbfda8f344e9698f4a185b89cf3bf76bc32f6a7bcf0c511bb67bd8d673fa06e51d4ae86caf51e75d290d88b6417222c295f9b4529c8300270b3b666d488ccfcf3a434da66bc3103c74d250021120dcd5b63658768ee1fc98e1a27b7ef6783e968a753f31f15d2414c51b5989daf9b0d8d62fa88ed54e60f7223ac5026797bec5cdefdc2fd88963318c910eee8fd1b0c2cedfa1e3e127489d77329d9a86ac97383dbdefec44410addb2eb293be0fff31bf49a6c1ae2c2c41630e5b16eb005eedbeb79f6fd051ac7aa28ab82a0357535f5ef761005227d794cfada93d085bda93e9f5a1bbfebe994e92004688db9c63d06f185cc003c4b6e704922b86e11502f64d9410e141cde304db6d3c0e841929759cd7ade71bd1f651829042ae94fc872d6bfbc829f9a360a9d11ba19d5d97e03546fdbb55a22cb29bb0eb5abe0a00b0d85cfdcb6086468d5854fb54cc7c249dfd4ea482a35347f358fc0e5a2bc9d61b39f318886f697aa7a40858a53df34ba982ba064eed792c611d36bf3e34a4d9594c84429f71c628cfa3731bd4f0ad439299fbdd62f01e83ccb48c382b9e31df0e34d707256f6f7657b78669eff0110abbf907fb0dcf47cd636c18825519db63eed1691e2875a52d5f6ca072bdc6436cae8aeb2235021da102d009c07303bc7e3d36868b0e11beb2cbce09426da04599db6407b8dcf11e28b0ce6e88e6cc990d96d9860c03a1509b71e85f6b13069628cbab29ef87eb9bf39c87d884fa4d90562630e14a096985fb6b633e6344b39da891fa821db53aeeb2bc66d64d24a42cb00902e90cf6ed05a5ad101177ead3df54a77c43fd6f915f87511ac8c978d6dd126c462d794e15e831855649226eba1891cfcb28ef35bb4f9852609dc54af6c067f5dee597158c8f8597098d66508bb29bd4b40410263b4dda7c0c9200836094cc22380bbd62fbc595471651b3f89596db2b76cae9ba96161309006e1371a280ca3f91bec5afca6e031dbfd6f3602561a57b928590a3cbc33978a1578261109f1dc52c532d1e544699b1d42e267cda8a87f9d72c428c786eb0a4d5f163f51d1ef679bedd787058f561206752bdc70fb123023af25be8fee8159e39928a73f508a96c82c519530f3affd2c70d315a9c10392ee5fb6e8bf50c15043c2da4bcb50c77b1531471f7ab7cfa76c15fcc09183f1750b13a54a9c76a385d1ff427a519ace602d0930fae1faa41e9a1f250cd505550c0a3532ceb1da3d021899638f11d8bf5c196377344ee6c54dc61d9293629f30ac905ab54c6a9130f5439bc2ae0d85bd2d38dc84080fc81b85aa037ada29b63abe415ac3741a774a5d16426fcdb0b6087a115fa1f58fc019a90dafec7cf4cd968fe47a4fe0fb9ca2b2d54e0cc2fc8e763d97112d1f7bd4ea7aa00bd9728cc60236ce40af1c5465c1c7201a28bf4eda90e97fbcdc7fd36ab13e13bc857cfe6ecb411461288d253b614fb4432f0cb2110f289b6c2da523fbd5fdded9aa32c8510819b6773d4ff34b03e4021502db77334252e6bbcd54e5b41c9dee6930ab4f7eaf4a0559ad3cf6b89350963df872180e5db7eaefabc5dd59cb1356ef6862cb187e79263d94d57c5c00295b4c137aa57aed6f3aa5798c4bb2fb26f8cbba39833d6a219961cd50d3f82bd89442cbf4b82c81760426c4ebf11dd8aaa3e73bb716abc8679e7baffa75c6b7a67e2852904557d97dd04d27b4b923ef4311c61273432b3f9017745e84e4109d0dbd39572b5d6907045b3531fd48a4eef99c1fe4e03f3ee5c9f88059e8d26761818baf9d891747a9e50782f299b970ce2c8db67c95b36db591ee1a90eb6c68a9d364cf177c80c420e8dca93dc1918ae65d0953cf7184259a891626445d6bcb630fd3e4627b67f448f9795eac5d0a94e127d1e3669e0f4c261bdec7ca49a35b91e258596f0e253c303d8309cbdff207a0f22e3134ba072cfb98195e9c18e9060262ad88921762447947c29488ff0294650e1fdd20cfd44e65b4b938563e104540d175171e09a3bce64cde37c9c42ecd22287789283899af79ba4f878b6269f53f22c0bc871a7ff8cb793c19df9636cba17e518515dbf9568b07843e06de2fd3d0b10ce46d558fe7473c181b06cb077e69d844a1a16995ce0316ef4c543b0ce483a47193c141979537eb922f52e7cbde27ad1505263b5b8752c4224d298962b11c1ae88bf41037ef25f83a11f2a7de25ebe92e5eca06356228ba9dac9b2ba8ab1144af5f9611fc88caa52f610d83c17cb91f29f8d4a9bcbc5d67d2da88804ea2ec68f4cb8aa06049ccb217ab845962ce0d6d6f2fdc92c785966df5f3c883ee52b141feea3ecf0881c87480e00bdc87cae23b5f646b1a13a3a887d0062b3d4dc2dcea48105cb557f25db05891bdef0abdfc32159ff7dbaa992661246a58ae795977fa38e7ee3dd36a7b5951b336d544b3972b47ae0f8ca26ff1550e830f1e03bdd95877299eb1c6b9f194f0c9e2cae2fcc5cad8ba2442210015d80982f4f810e92150b13e2894e15f8f0f9cbb46a39320cd1a3d8521fd1ceb6e5f5677afc0cea901e11185775ace85e7957a684bd7914d0f287c882965936a896845941cd10c44a8ac5470a5b1b50581617230cdeb405cd995f179990b0599ffa3b2fd72e3facfc21948110905c96de0e86625b08c4795e426938185df6a2b36068258d6ac7ac1ab76adfacdeaf64b772ff5028e8b19d7b87528eb357e96592e974da2f80b4f5e77b44523a68ae5437713b391eeeb668e7a1335a69d08ae6b8965a8ff0762341741b09f0ec3bdbcfbe36ccd89667a88367655c7c9acc9f36d4d5d6c27eb0e389d572da0e2280f83b91c877dd41bf1295395a967fa2d3dd3b78e0d0e1aeb79319979cd792162d683657cac44e4bcf998cd995736a87deb9dff14fea6b59e598114b65ce3111556db48811bc9fc79a9aa6c365b8a5c697805fcf7f5724a3dba731eac7600a3641121fc5d8b2a1a60a3678ab3067751b17adc8e5d1ff09fc2764f9827d0c62e81e95d9050b39fafb681bfa372ec9c20696f716e31e171dde44be577207bd19a4b2ee9d8aa4638110111789083924ed43485c101b264e4b7618808f293625da8926376e5494b42a53b0047241cef88a4e0803c9fc91ae43a74732aa513ca5d12bc1a1a8f7f95a011bd6769beb1dbb5a8b238aff48bf574b3be3d51005facacacf5d686cc275a5563dc27d1a77d50e0f0138c37377b96416ecf6fe5519dfc52c569aa2c3b05d6be896ed579b2fb34ceccd84ded8de39d128cc0be4e8b6a317edfc4b57ba8bdfff6aa9545d0d3836a35d5b161ab967f7ceedd38ea28dbf05c1c6a5829d50f2b2dd8f57291d65c123950ef43f47444d572a52d7b3a3a67b2b1abb999b4e8fab7c2b940a5e8be1d5892c92e874b1dbe2de647ebe97919db6868725463c16393c4f5a1ac2a10ccf1d589b610341df8072c8dfc3884a9bad635591d53ec50bcad397f9a05b839072dc2af74e2fef474b323f1f0b2f3c3e3b2a88b19c963ed6ba94000fc42c0069652bd5b3dcce75ac04bd79a53d992442f9bde8c6ee9468b8ec485055ec85a98d8317f2a3614f3f906e553e853cfada07ef08c69e7c794408db3e017ff800b30cef700281cac463625e8f65995dfa2b7036094adc7ed9568d87a0f59230e2397bd5f4eb05b2fc2b2e1598a427336b595458bd224d2ca31badba9e991da4739de4ca441f827a3f6b4a418081760273780880c1f9971fd3d05f6fdcac82848b210a572144aa35c8f1165fef343bc3f582b7e275ce1cb08e348d4ad963a4888fd3ec93f858a44bd8d766075b590deca73d17d2dccc3d03a0a094c4dda6a1a2d575c31693cd57d537d66766cf930bd955c1fdb22a83039f4afa287e39269a911cc767583e1a1cd2e885bdc2103542d1da46ec33fe24e09b04f41943f7523d31a61a69fbdfb8edbe3407fd00cf4f9f7d97defc2355ed6b13e67a88c709f7b6d457b327c9f500f0c5af4266e80c1e64fc135e60c7250d66b17a54cce85c24e63a14ade6ef6791abfd740aacab78ed891fd4aa701ec6d9d34fd8c3008345f84b4ed37a6d962adcb908b46f97aaa2eb2f346f0335114b26fc596a4211ec8a9205447769677865eebf9bbb5c9e64c747a8260370b5c016778b24d96f592f0714a8ffdca0bc2afe723d49a44cd63c09459e6f0e02e0fd761be0c8f97596702a4990872885a5680bd7655d7318a53337a32dffdbdbf0eb79641bf67afc12f19fd97d8dcb69c7d4b25ea9570673a2ad53c0c254448fedffe38cfa5b09fad2f89ef14a936cb56ab3b208ab346750ddc6757306107db978004ba66ab9150d0a7984911eb10ace74c13eb070c458424e936f2932ef4d5acbbb64aa30b6a390016b8043e5de7978a895dbab7a049e558f02178c7fc3f508d167cafc090f1ccabc233ed940180d0932c0b96972af7f33d6ece6d1b360afc5a9ac6dbb01b42d21dea9d6578d7ff4778bf7570c70c216b15272886be354d6df2a0f9b78df67e1c998f8818b414f06cdf45a455768f1b7bd101d3232abe826c5b130f4d7797c0674031c97a5a61802c839c4a4758fe44511d3fbd9ab6b04b98e58baf933ec606b7a02a74a5cb69797e344eae7107e3efe87f0511d2d49a5cb6a9d0712c8a49eedecab79b8b4c5a545ebbf563f87a48835ee4e2c9b11a4aca41bffa78694ff1a2253c6fc0c06aecbae8538df46fd62085f6057be651abe2aeb2248d05d4024da802f6466fca6166a6db91f6c7bd2c71db14910b05b402742a10d43af73b13083d434200a6cacf35edf19a643b1f99d786af708fcad0fbb28a96879f3e3fdfaf30343a08ec4379628230b57d07952eb933d8d21af86f058cc99fafd0851a2e49fc6e40af9957daa41d6285c4524d62f8f42394e058d98fae118f2094adae6b6c019dd1a10b743bb8219211eff30cabcf9f69d08922a2c57cdade37cd1e0bc2278d8e92a3dc494053b9721c9a79909cc33c8e63e9e9f15c23a095fcf3fc9b012400b6817064d8fc3a810d3ab746303cf2979516cd0337f126a3ca502f43bfbf9a15c2d62bda1026631f73a6dbc7ebe95cc5bea646d7ea5c4f18fa4971343ef86019532d3f77bc9f2c13a9980233a6d4818a7f06d9d2046735efc828c2644a6e407d3c3ac05fa33bc8d0b8f1e42455314aa5ca495f43e984f83a21f8b91758afc06eefe381dae78f3166886cf4fac6c1436ae6afdeb25a44ae730273dc139d8c6ca52da0465dafedd4f8eeec12a03687fdc345f12da5a48d063c3d990f2cc4d77015e0eaafe8064d67636d2c66338b37c0f4ec41408878b882f916c549161a4a43cb6da1f205212e78c346a33bb7dfc9a6f5c22513282fa9488fdc0caa322b037f956b306c4d99378343f03be281064ef2847be9f849b168f5c736314ec7fee70b687c9dc0c0300fb35ecd47258bf2f94fd3f37a5d7f7fb1724099c2af18c391fe9035b883a0a1fe4460f8ccf82490960b6165fd2b62a92e13483f87ef48ee18f78e35dbc4eaad1ce50bba8bf18e700f8d286e57cc502171515932912325caff9038d113e890d3b05827179f8c07e54b0298d7056a51955660f6355ffc177ab983097fbc1977e2e82d9bba7c3ebd05c1056587e69af4bedf25deff28a4c103fbd190dbdc6e5ff9a220da9fee2ecf9453c1ed16cd57ebf3dff02c4292c58d2c4de788bd4e3756f63ffe254b36953e35cb3e37b59c469d4dbf7df52c9ac3ad34790efb44e4eb87736ccbf506f4278f95e1f28e7bec07ac4625a28d21354308f165ad5387e773a578f743df5929e6c8b9fef6de294a52c467abcc959d409e16ec6afdf80913f2313ea8b1f5bf0a7a940c175e10500e10f1a6ed80a53df0322d176c8047ab391f0dd2a9e0173d9e974e087d9b87f9db958c18645d0fbc0c523428bdefe4cbaae2c7ba84f65cc7c9ba3923cc4a6262da9a6fb3b80f6eabe34092f2a52358a66cf6088c1951e4f730a689dcbbf26f9af2c7db5594ace3c0b69a86e0a014e1d7aab079e5d66723d041cfa9e066d9c42d1078d09f8931446c2f06f9ec1f0d2221e89fc83aa1f890b2e9fcceba313fe3e0f1c09f0052ace1614392f9eae028edf68bfbc6297fa4918e37cd790b709ef3f8b026b5bf6caa7153acea69b0b94fccafbb4d356a7d6b1423f748b42ca90f858e936a20d09b0983cf83d8b162473046616ba421fc50b30d67bbd5cb552fc1657327c83e0318e4d2e0168c16aea7dd53c0afcee2bd9f51d7c7d823bb329e3da709af38efff93e7a3ab46b5b37bfd960b904c3690b54cd2c690e21a0004f457748afe12f465206ef8a1e5aa31379f529cfb82506153a37d5aa9f25e55e6afde995256278ec56eeefb98f9e80c8b676e8bc8d5a21b54c457f84c27667395a800fa1d555029daae85d9df500d0252f2287e928753173e149327a28dc677c3bc0ff7c35b17c3d4b62242e6d1d74fc1b6fe5db1037fe29ff4010f4f60ba3800dcbcf2dd66d07bf5aa1c223442bf3669457aa486faf189375286b7d82a1e5b1e1ec8ff52b99cf5a10b81e20ea816aa2aa69dc59073bf933eb999acd5241185c376ff554931571eefc842a51114ff39d5aa4f5b6d2e20c380e0cf5551e6b690614d222890ce8d01db98ec6398d559fc32e2dfcbcbb7237c0e9c039cdb8fc4f750e04960d2e9523975b88773c7f193dd74718dd1f8d726f9b90b7f506971ad1800033187be9b5136f8b8c21f4228ea797fafc39dc7b338dd4fa74c435a6e66468b4a2d8fd6438e5e220c3dbc3e743d4e1fe9b195b3900bf3f900ca1857133b29a79839ba77c037493b6395684037eca14f1a8e5e5955a0bd5133b5a9d6fadfb698c0ea30cd56a859121376ea222316a4badc5d58b7a45a4de4bae335b21d69326465f154f4549b5df11236afa67187123b44e91031aa75fa4409ed1f5822e52bc231cba950d6c97690798e26e804a714acdd70dc75364bcfde3675c2653b25591e76b8c40cf46212ab67782549e9dedbf40db1fd96b4c50015649bf311a0fe2bddee8973f30c980f9769a09c5dc30c635adcb6f2e91308110410c53fa991c5e3f0b3fc3178aa15ef5ca3c1179628c2ca37454887ac7ce40675d3e633ac882a2b765a81c8b6ba0f4b132c63c9ed3c260ba7d8b223753c453c6b2e3e95bb1679962a88f657b40f67971ae82b697ce2b2051f0ac8ef224ae1bae300cda1cae45b49be98392104d52b50ab9687310e2ab3fd86e0b02ba1a7338b4d338f654147ca8578e4d219d3cb828fb287682e387a1eb774ce508b3ef4c25fff99958da8f86baeeb851afca08fc2bcd44461db07e63033dbdc6e0d8ebf07de8a25890f3dc5899d2dba819aec6051f86126fa10de7070e85972d44c0fa0e51c20efe1858f640811c91fcdfc3e22116fb53fd8f9c27b26d94c667a7669321d5d2458f59efe3b694802efd0f523a92ca651ff71c8889a33d8432337197b66ebda02a0698213ee6fd0eac7ce88cee59f9c41adfee3c4a68c459c8bd564892c35bc1fee1a0b4aa09490d2d35b738c5b325427aa5ae5a5ae4b9799f9f6d4839aea7b2bc50bd9cca3c672b6a56142894be0353b80b3599e295c32073116a63b50693fac801d5998f5b29ea03473ec3342479d862d1fc9df550dd4819e445492bb1f7b0628569faad7bb469815b2504584b6a7793d5556ac7e971436b892067f1caf859f34cf8c3439d6b4df423f12b8b500dd7b99482c446ba65f2d1a01669c1e35834ca21aa720c5ffd1d1377e5b172bfe79a6d8b97ba1c1d7c1c30f8563c408d3cee4c3fa84f16f93abac1cd27603620d5a498728f27d4aef8bcaaeb09825f10a3e9916955087030f5115b2c35be6f927caaa7edab0021adc27f5ef57642cec693b788fe590744375971c69a5346d6e7e24f3c6c430d00432c84bc91f0acb4ab8f3a375dea6d65850e2ccd3792bf76582393a731dbf9a3a302a528f202ff29c62e08537c119b3c92b113084ff9718fe8a1be2742fc00998bd37c522d054bcaf88f39f9ef6c7a75b2300772041ca916048af903a96a9c06c82fc060f7d5a5394bda9485cb06deb34cb50c157681b6ce311562b4df66fe4cc4dd550fa8e48827fef448922043cc293344be6a6b11fb2b445d4da714e4180890861a1c101ba7cdac76d7bb38d558d0277fb244ffcab8c85753b3ede55157a5147eab937f0aa5d69145f28cf7fb66dde5b901ff75eb41d7ee9c8ea575fbed7addee6139dcda40098b8c0bd6c8560e2de58b279e7b072ced700b54082ce2f170963e71ac9c1d032f7755e1dd6fa499b6313641bceb60d33f5d4c20d3cabfa616297567c59d1ea95950eb12e0413f8fc0b6f6fa51e992db30ad3a6fc2078b6bf78dd49eb2f08950ade9ff145c21b320e876202f27bc6bace67fcf43497aaecc8cad878fb9d07776de80e85cd308e0427f12af8d9f84de2e88f2093cb3b3e8e0660ac9628a816cb434386f91ac3e1990c6f601d3bd2c63595c5f5c38bc8dbfce34f80db3a24caedc898f512291955af119d0ff8e347d91caf81243d81dfc485d015277154b0f539c7207c51418aede99274188327160daf674c09a626b5268848296189dcbed6bc732bfd4cc602fe46451e7ddefd4e4ee2afb6f8ea1eb088ea3386c1e9b656895d04baff90867cfc1f72159c13e7db0ad28fe835055f1a47319ce2838162077346ba66b11ddf6b88a5555635daa0a998005060ce39679a3b2b1be21a75a1c515f84fcdd752356d778a13d995a5539b4d2c31bbab481b17475dcf56c3efc127b8aea7a99780979c075ff6a8294e1e2ddbaec941abe4dc658e9d6645682d1807bfd90bd2814e8098f098ef58188f1347f1e39580fe001ed61eb23a0a7742fd8d9b661fc3e88b1ba004d73d1fa274be5ccf489bac1c841a4f4934e0da3665facbddfdc76a6899cf6ba42c2ed16b99927653d36348d02f2f107d6c6fe76786d4dedb68ff65e510dcd6a84f75c3db2dc89c44d674c971167d7fec2b314d434c67680b1d6c049b2712e3ba6d2aed6139e16ba4c56d6e839671cb25f1f323a75b0376c390f15950fb2847418848d6d2baa1a7e114781d87d8b20dc1eff5b33a2d060798716aafd1cc65cef985de18ae9e421af41f536cf7cd1b284b23d0a3cda7443c4afff0873195d8e99561a3945a94837a038900e9b6a0685966cc9ab9fb3d464a7baf7975e714dd5e0ddc0c459395c979d7ac922aded37663b19c7ed2f5c25f3c3d4a25afba26d47faf62ebca0d9cf7b974f5284f859e200a19966215a0a52dd8bad9ce62466d776528c4c9a2996cbd494c3327b932adc00fd72176e5067b8da74a044e5b1eaa62419e0e1cb0de299e1ac90d4c444195e6a1e7da0abf122790ed1e8799dac4443c0e1f58e197978c714fb589529eb1156fcabc522f7ff9d0696a0bc3097ce8cfecb223db85d6bb026359c0c146f17f87a188ddaa959c4101e1a9e670c1a6d7e4f125764a2ac06497b3be2e684d5a9be391621bd4e7a4547f104dc467e3f4a75b76d7278e5403567426a9344e4be100fbee64290bfaf0121feb65f61920e28e790152201c00289ad165c4c6c2d31285f3f9c2c580f375c65cd3294ba5da8a11f285d1f07bd8f20cac409bc7514e64e154b6e871704b04c415152be14ec7eca1e9a950c949800cc60874c805f44899475626157531113129a8eeac3ecb68cb9df5245b1a5b81397610a2347c0051840841e186c11fee7292f3ac11df7cbd225815877cfb06c657262f6ce994aaf5e5bedf83d36deac8f766e668ff402dc2e2864fbab0c640e0ea313890d9eb3ad2015927a766d829a4d6be6fb37035e8a362245857432e3267bc971629667af49f7c199cf3e39dd246ef450f830ca8e3b22c370bcf65f29f6b6e711165eff9893f525fa53ab4fe230f9b24d8309c147d1f02b409e7690caa094efff519d378da1c84256f9dc8e1410becc677845fc75f5b0985ecff48d54eed2691a8c15d1795ec8f79a923deeb544f6884e37c051e87229e1a9360b099b0e61e9ba2e2c4cd903e3139fbc0d581eaccf9330a0399b5850732edcccb04b6288edfd8f577feaea641f75acc7f4f2f9c986291f9b21e593a54f991eaa228690407548916c76019ffc6c3c2d0c503d127745105c04e68db7db7142665a0fb79b578455b60508746f163361cdf0fe05fd19767da7ed246d945cbc22c24979741f9d131b414fcf3ca8dc3305c0ebe250d9515319d42248ead652986ca1b4b12fd25cef876541da57fb5cfeb814662df8e84eead5bb9538da2d8935254e9338ebdb73d5c814fdddf5ed06a8dee9a8fc9e9506a6bff966ec3fdb5f032a5c7a129a373c19551a99a5cdd175a8aaed10a6b81a14200a5da24f7f4dfd278732bc9df9dfc601a9ceff857f794e7e0d6763db0a68a1ee77cd6718cf0a77df04114353003d7f2acdfee9d1b9129487a5f5c85c91fb439ace8d9b0cef4f06f474ec1ac2b346d93b0da7920afa3a36d775f91e01b9a5d800d1dad64497cb13ea73c5abea9a8693f6b2ab5603951a4b4251d34897ff83bde7383cbc5f6509f1233de3c25f2e46ce0b577b6961f620074d1b5be79f55174229d862f3ea42d36e798d072d07602a1d6229daa67e7abf23d298766e20a4d89936edba4c2fd58e54776314cebf677f5007762be62701201ebde3a59e6b718b589ec287d7f6893558def0b61a9b1f384849c58de28ec46d0966aaeb71ff8f10a3a8952be6fa4bc64954dd6191386d67992ce31ffa9df918787cdc79e9262efc54f064e3ff903a00fe261944c8789851c42b5bb26ae212ae11901edeb0d07bf4df279190f57965bc0372e1675aae388485127d90e62c13170a87dbdc1695d86981a6aab434b362cd494e186687580ca915938a3a940810a0e1fe8b03f5486aea584540978d4b5f6f1c5fe2f4527b2cac7e859a66e942cbe804c137d1712fbc87e9e29eaf2e8e4567fe6971dfa5fc9a160e8349840e33a6db7d86677896518510c1499ccde53dfa6e91cdb5db5f4ccd823e7b77fe3ad9e9ec894362755bde71aaa2127f00fde73983edc59ef8f200bb908f48965e9eca7875fa9a6c13e233f1a3ebfd877e6fbf4d17eb9c70e6a1c391279e77df2d435425972a57545b7a7fb25b5cff538d1605db59d7201d0f848ba401756ecb8d143a513fbe0cd0d3156dbe9056d02aafd976a0c747f5e18f059d0b27d805cb92bc38cf87880a136bb542450e5f2220b4a54a644ece5d025caa084cf7835add918e5eb7a9250219a1542c29b41a06818a1db9ee68cc0932eae9332c575d6b4cfa1c03a0deedbf4fa1a5421ce60294dd09ff0d4a68832cd6d5860fb6c48c0e6393185f3bb12d85297161562de9f5c8845cef2b8086e7e777189da87c786fdeca9815955dd2490e4defd5803252af0aaa88e42cb704059628f4a8c23ac729eb38ca99f56cc63bc34f2f15af1feafe3b6f1bfec934875d895569155f2a81afc98e0912d3af26ca5dea156411ab4e07de995ec97a593dabd0d216295208e5db3e525b75fd47da8615ed7898b11703c171f48e3fe549b6068e0dfe30aa4df7618e00fa0da3643c972d6392db3d0d969f6a60db342264a93de0a5b1d6679d5e7da0038d36959212557aeca442e0d93c2a55e51211962fd8f30ace740666f4f8fbfdeed29c8c246d6f3436b23e9c3cb577ab6dad22f2739821d8143d09278e32ad25552e99b0c240fbdc5b9ca075e0a2ddb9e58747d3acfc2f91563836126decc947ba7bccdc714f7f7588a50622abbae2a95ddbeeb70431a7fe0568c94e431f1e065a43ec6429c289947949f5e6b75da210977860b6051d9031ad0f1bd4bc50bfdfe9ffbe8e76548ec9535ef554a0c3429772bdfd9f50bc45d672424f2f925031d33e6c10baa8ae80583b2ecb460ad0b08d25844f98a1e736499831334dc3b2abd3b440997bfd5c039a59c7e41c8f2a0e7d194bbb4a04442ee286cb8526f79906619da3ca95a45c1d50224f2c3a405349e926d0cf8b69c2514c67ef128148cafcd8bde57b8c6d3acfdba56f2ad42ef5a56ef3a7878efaa817d6cc0f983fd402958488fa0cfcc74701e25feb8bcf1c48c6359307bccc6c31cc569df6bebce6b4b1bd1229b0cc80a086fa69534de75425b218c9a394dd1b7196dc881b8f92a780671976ea8fde638c840341f9d534f42e3b3301a69a18234e08fba05504fee2fce354dbcc4c94e789191e72434d0266da8456adced606aea385172d1b85f4a4ef5500b22f9356e058d01a89363a2f3a1e8fba330f83266f7a6e73048922e72859dd804684d760453608e13f0b75474b725a812934771dab47d19c4fa4b1eed1628d769da2f382d7e21d1eb549df24e58f2484e85567184223659e00d74d1e3ed4559a4b56723eb5347a173baf8a48663d33e2af2d9d69d033809a4bd9c5c9b9baff0662969bcc687cb53dc2231b6a4d3cc95bc8b9ebdab6862f10c861bfba9a8c8c9cde8fa26834b41422595c19e9c010ad260c3d6f605c2461ad70fbac74ab96966df28865dc4cb233ef4d5d5937006c03fb89d48883afd91a52df93f74f2dad09df8d0b6265614e9a2870ba24edeb3a499fc19aebbc1c58a8a9c1f60e6a06f7083be040c1dcbdd77150976cc4e6cb77c183d210716211245dc30b1b7c9ac1dde81ca2b0171ada0dd5c0676470f0f350817cc3eca546d4805d9c1583dbbb2d1695fbbd6407fd1fb452dc622d105612b4910920d4050b6714cf292ec64864dd8cfba02b75764f56cf10997a5fdb72aabc73850747c954883788c1efba5c15c7cca1d4ed33205c0ec767dc1d568a6eeea77a7f61d712368414414044a5502cbed4cc1cd76ec0fd128bb3b0fab8d5be8e085813288166fd3742f4518f9ad86cd964016aae2e1dd6859ecca2519894427c46fdf591444c71999c099480a2992e876989d125db0884a316492cbd6f0b45da79ad683758babbca39c97b55dfbf348881361a7501411065f906537fd72427d5aef06de8829bc16d963388688ed684668f23e728583783eb3bc15e68f503e2bd0f236fc9a7e20d0c0baec032e36549255ae3599c811506f8d6d46caec80203e6f594d455abfd08a8a62a819c6697daef2236b6d423978632980a1e2f7d3c5c6627042e7426bcfa90e6a1e1bc62574c13f81999eca8227c4896042e9ca5024644648e9d4c0670aec007b6d94fb3ef96d45e45f19830204e09abed154724bf3b1439fa31306851540becb8b8d23040699ff21458059533966cdd4d08dc73c0df47a3576593e23cb2c3372e50f11f9a957ecd8c605c1acd09497ed1651fe454a7341504e0034c110c4db1fc5d0a9c751dda6a01a7d49166245c3ffa854a46df1d91ca19819ff11b2185d98f7040a5ad9d9e1ec17de308a48ba72daca9af5fec173efc630d8302d154a98d11048be178860a3f3b91792c12637e4001fbc1774ff65fd48fd3b14f53bffcd2ea6744dedeb90f6e0d3a4f5f4721cb87c07edd12d37188b655a9aea6f22784d6bb9660b533124f19006a816b664fe8868781652fb852bc080d2a1fb9c842a5233caa61fa36d0595c86a4886c1a348c3d3b4bea9f7fdb7e0d29a3d1f6475410aa25534b04e89e251987a5fc823e877405964a23a941917d0228a33bb131bb8dbb5f4f31dcfa77966f465091c24af8f15cb790027e2b30fd32fdbf9e796aa90edb0ca7fe65b3b5471c23f6990f37fc7e9dcecf9b7c5e18227eaf441164b065c8c306f9017e2af393e94e1243a6ac548fc419ccf82f8fa22a4a36851ac03ff725571878dde0cf8a1a3e6869b68f12b58571bcb875c101c10e470413698168817f7b83530a22ddd542b8756e7d1bc0c39582eb12bd80740735c31dec7cfd8c2306e63f8d61a60f9fd09ac8b421278def14e515779be385064305af3d1d2729f1d0a5f020f8677da13c2ea86ca729d7e2e5ed4899bfe6966e6b59386fecaef616063c6232327e955607d407675567bf965abd4011c4638e9995ba05497cb7bc6d3df91b331ebe756db14d7f86c4afe2fa68fbeaa9b5cb260e8b27b180351c2100d1d4dfdec5763fd3f29c081a4cd0a9301cf3dda7d57f4edf4bec6b4c43a95228d923bd71527b966361c9a26c6f34c91fb839af1ded3d483e06dac943bbd0d2d320178de6c8b77f962030ff35f3609075029a93cf9b994f13b51696192875f3c31a4e1c6d77a47ae5179901e8ad4c56342f0bfc88e2b81ddda06e197b99bbba9384d117cde0326bb9735e55023b69aa0fd89e6a809974b4a8d8eec531ad05f87ced4e98767ac7a934453b12570c1ef7dd0dbb0b9aee8b787a04762aa44c0cfedbb2a6e03db10d5920ed48be0d15dcd2123356b5fa3f259b003ab040554d0ea794916359db85f210defce175a99ee5c879b03f90325b4db7a9e99b34c5420f1db0fc885e31bf7e92ad3697752a889773000c0e65ec5efc83d4c15ec960b8f1302bfe17362e50f5fdddfba5acf6b855ed23ac82cf14027398bb0bb3c2287e9c7651b7c1c3ad2851b2a73730f5b58cfb3ae796315a4ff417e9e1029327ebef501e7dcabf7c682ebb61236e24bbd1025aa9307986a7d971878369e2647505587f23e89166faaa54b8a9f30505ad035b9ab015a1e92142514afd1e323069f70ea49e7b028dfda7b23087db3b316e4db950a5e304861f93764d62c238c43e294573eba3e2fe5548577bdfd4622bb9b67be015ab6faee883e493c7123f159ceacbd70ae5ad5d06a0f70324de7b25353599e2f64f092b225929675c4d08f76e1a744b3f24824526f4c120c1d23b0c376f6547e8e8d098ad764e19aba954dc735d140dfc210e852f59b6443a5a30e769f5ef2272109d64d2c7993b42e5d90d185f69a8bae6568127ed3182b310ad4c29ac776ec882ac5ccf7ecbffc2bd3e51c93e35fc17d4a8487fed9da494eae167ee7566408c7e8109be06bb036ba3982a7183e20586d2d85b3645e99b48a3515449cd66376b10029df593b6d10eda1055cea647a4bb33f3b328f47396b62621c8c1d081706865ee45899ea90e06fbfe4e275b74dafbac32cd8e4569345d3fb5f9e3ce3eb495f501abf755ad07fadf40f90671d41ef33944f0b4a2a18e161912377cc75eb2e8fada512459801f11dbfa0a324a91c7bd92f7d66169e8d98ab7bb994065b76a528db26ac563c9bf4bac3a69952133c1453167c43ba97fbdde5a88091bb13bc38d7f5e20fe56649c15df60ad35e391ac4c634e16e948df880f1a4a3021b02f9585e8a45422baa019ca43d65780eedf5ae03a6d2f103b99c96da84c0b03bac9939a50f47fe4cc98c2f78fe81db4e78b4b27026556db8e480f780289a85eadfd71b829bb0eef068b9359648bb2449a3b40883df36ad9af04837ff81b6f2b4921562af878044034a990681273348d5690786a97117a31be2d95ccdb8f53e523ff8fa247b07f74e5479214e8e7492c9acc406b9c7c04792e8d0413406b65a467d982b2776ecdfaa364aa6ca8ff20887af0694a6080bf73134776fc76ec1f651edaae7393714ad23189c71eda8019725e1cb1e18a534790d8be010d8f5f20f15f43ecfd75f51f6409a772abafc7aa1c0e147d60c82bc90e0a9c15dc3e450d669e9a18dc2e7a207729d97203127e1cc5a8a0b251aba34f5e0bf6d4694c74f15f9a95bd6e6700e8e343ad30ed546890b8895451ecdc6afae16ddd8bb7c613abe7c645adb19229d68092bfbdd6f304c6edb8e0b163000d819ca07a2fd1d76fefbd613b0f6ec541f51be148399ad75f03cb8ae306f960baaae34ddddb7527b4435c14d979a65720317e388a5f97ee62eb1e7b9a58f0510be9ed4b1a9f42711b21fbd085ddb5367eb27a4b53c1887885afcbfb46078d4f45e8b7b6157461a7b320d28705111fb4da4ae64a7df2c0e0dbdbfb803ce01a5c986d3a8adceda9edef2aee4d1acc5dd71129bd60a532716f7604ebc86878f060a712f8163def39ee8990fef6aca9804c1614a48fd23b6d899c5a890483e0a186e2fc9110be0f0c0b6b458f88f5c59cb6ac5b9f2c5b4a5f792efa46177a43fe956b19f4eca5f921b3b63288cd4f861d624c34d12912687f8ccbb86ff754d8ef21ab7dd652ca6e29163e5c33ac6d2c32d2836cbc377c1151b93c542f2add519c6d9e281fb85f168ea1b1a79bc59542c04d441234adf2564046b8d77548f18179e9927d14c4c9b0218153b3b451c3137ad85b8aae6a3d4c550426f8be4614a758de3076e21fe89db26de02402821e37990453618799303a240babc7c843103d8ae8399e7c58632c4727388452a1f3b2dd97e001c0ecbc67cf546c2e13488495b56d990d285c5f60688881e48fc7eefda7f9d1afe459f41a39d5c61ce93e689e6dafc9d2dcee3cee49f95e3f4be8cec098ed3ac2c465b845ec30756d929c0759d05fc2e46a7205ccb4dc99e24e446f20675497b077e4a24f1185c689a2e5b89fe3e7707b2f4a9fc6db25c41b7c419194876af84082c3abdbedecfce4328898f2a2bd56dc0617a5d2d43a8e0f128b82bad613182396ea63914a3345912da0d30a303748216f100e387d66ba4b63d323e7c368ea4aa26907fe98c76bcc1f6647337f80e3e5c2c84396d4c1012fc19bd7e8854b5865e10b2c76159ccd0718bae4cbbeceb9486c8711cb659c6a5ea6d63f62bbc9c5aa047f8264920655e577656f125c9be16a87481825b54a48dd9163d38ba9c7e6fc195a123cdd0ecfdd7d70fa5db841846cf8d673dd3709cec114b182d04a7873fcce6b6e864d23c6635aa5e47a6b41599dea0a34b79a02f8909dba04b8e94c3ce59d1b5eab70f882ddabaf984a6804cd79c08d611bf22d686b9d66e28878be77812d26a7d32d6d2de78b756230de825d1e26cb0eecbfe91e055d3f9f870e562d2164a03e1f2028683f502721ef4d9c0111ce308bccd2a9b92cd6f8fc3f6562fd9242ded62a869687ea5a9200d8ed04c1c7dd431396353d79aefb609a545bc264c5493728c29a2d0e3d6a75b99046417f1843b847a7b170dc799cccd477261b16ec497817d5a8eee8ea844da7eacf5126bd396ec4dbbeaaa6a2527f006ff112fb3bbdc2c965e254460c441a7137193f2fcaaed83b58bbdb20d61bc0830e646ac21c240981e40c7c1b8f6a0bb681e7838a8286cc6cc84119097fe074cce7fdc88385d1f15780b4fc8b4e066a502371ef0e782869c0c8a180c9c0d4efd71e19f993700afd11dcefde45cd163b4509326bd5de7f11ec7c55a0da216e8e13a372efa06ddd4da2c25c68d3016c6f7e80392a7907fa9fd3b6f9528e666fee290a01e8706947eb9d31ca7f99d2d89989d1a2c26bd9eae7a2734b1f3e2b27d8c121f73fea8b88b9cac5a3e647501eb451f53df14517ab9728daea0cb145e8d2f156fbc0ba69ef426ad4a0affdfac33907c86936177027aa46e575d73ea8fa1f7a42d34580998a8f66dc4b9596cd69a8567eb017c846c2e31da949391f65c341d2099eca8d5115c9a49fc0759a28185195f5b30049fd80ab8337c6d2b3b53bfc0b656888327d08e50c5367708b96af4aacf708654587a50177b977707a50360bde3dfb45ad1e325eb5f00463cda2fe1f6975cffa3b8b7b36815dd9e94a4c69a58f77253419758c2a8b448ecc02f529285b27d16f98c97d5a7e0a4f98553da3cb1c5f003ae436d12ea77c36d77be95557da9fe69198517052c9827e8648adc5011db3499c13ba881542bbfd47e2559ba2f55f2cb6f520bea8ad5bf318cbdf6bbd11acc46ce1c59e73340687a89a263468eca90d0c7d26698f82b6df67e6c5ecc83cf4b42e6707babadc1da11b7c77fce87f53c64159463b70337f80500053694a1d378ccba776cee3d36850433dd6742cbc6df128389634fa0baaa22a5bbd835d1e09de853a7d17780777ef42479b267ef6a7177a4bfa5b43d200b038a81fdeb3d4cab5ebf6160721ef9f70bc96a16ca2febd5142c454a4148860e2ed89739689c5b6c1ece45e7286d79e7a660adfb681ab505ed86ccf0404a93a502440b12be8cb1d06aba2f2c4b257c30ce1d6e61b08266a69669a3456289b9d6079e900e7b802c72e7adfb05a6e275f16d91f2f8bed8c2d242bd939c373114270905031f377d34f09e73732f9575c6a90d6bb1864d8a9d24661cbb14ea0e17e4be1ab4aeca42a23e1c57b24a47c5218878559fb5e72f78137b0520dcdc16932fd1ffd325fcd8e56281cac4ee03fcfe926644c38d9016abf5df7f8248a4f835a79b693f2b60dfd1ce7874f87592f27092d77c72ad4844b5748090805285be0d2a12546eb7484be1edba1e42e711bc51ca1a452aa0e2d00a0230af0d8c94b14384ad745396ec48559dfe6dc05657ddab175409d985f3eee868e35393ddad508ad40305bde5c34c2f2ef46290e4d8a3a647983e870ec5e77c019ce60f89ece23aaf05e8beb132c57d32f6effba505764ee6901dcc162e172abed54d484d4bd98efc54bacf1d899d23311931d3e56962f018dbb8f0c9f012567dcb5530d7c87c38283e5b1ba83c00946a89ac1874944c1ae384b844796e6045e821f4fc005c87c045b4f007a73b4cdce39f11a6ac0499fb31b3ba1549ea1db93e515365ee852f1a8253a6ca615f26ed845aeed67eef737fe189af6cbb7b37ddb255d6eba3a725f7e2f6c9235905288879c0e286ef1e2517666df741543e666e79a98633afe120bf91b0e14e7e3900dd7f50c2df2427acc7fbc72357f64a68ee04e321a7452d0dfb9728846badad71cf448fb0becaf0c935ba39226e49205b2639cf1e1a0f982fe773d9e67648820e2844fd1bde3bf6e575baa6ab5f832cc8d12dc45464def89a3a243b927d6fa33d026e81b029f3223d2793019add4389476bda425c551e05b77d309d2363d8b45e8f52347ee2e10a55463994ebc0875d4ae427052b376e2ab35ac72c0e1c9407f7168985651b4832d8f21a4c006d40ff19b7dde20bf206b4ad3503bdf1a65c216e9fb2430b882e4e14fdbbf149cd6e46c0a0fd135c5d585f3cdefb82183f526914ab0837c81b4a8e859e1043a0c4eb344662b7fdd4beb4008fdbe96bf59252e5302d14b6d1edefe77e29ca1348e4635c5592707509aa591f8a8f3c6cd017de2c461e4fa931e38dd5ed23136530c91aa647e4d6ac50e09c82da8fb4a5e4ecbae28a76c83b0ead1c9438baa2bc0fd2bba80479e28051b1a218ec837b8eb0d2a61904724e5ebfd38a566dfe1ccc92d55ce9f9a06fe842a314ca6861c8966fa170ab7cbd15a12a72d78a649ed3eef2de05713889ec7d2a0423072eba126e677916dd4928f0d0ad501ec1acba3ff4c601c066bcd96fd4a69136b97c472eb856a4bbd7854338e469ae31d604cd1a84c4f89a57d40e1fd90ca8dc413feb0699b00bb2a760d653dd0620809a1779a581dfd43b5edb611c5b0f9821a42edb5ce3027c7a4722993706f6b3241c9b9f7eeb3d4929c60d2e1fb7a0838be04a56dac08783c5db3249d3eab75388cf69fcd18f586a8d7e97bc7505a9b897982f86d6df18419dc9534cfe15454a4641e67991b40a2ae8b2d8e7bc19efa4c3c4cd052fa7587a203748a9c00ffea4f608aa3fad954185ff04a64859d849196db4eb57fab7239b1af865af989ff74c289fe2b3ed8451c6ad37b45344d678841928aecb351c6eef7e74bfff269fce524b99da275669b6f41936d2c0a300e1d02d8b19f9c23358bd2159a03d8b788421f12ea8ec1802ef7ef02f5a60a2bd96dce149492292d1ee821391c3efbee645b20c26d6e55a2be4bacabb346ef40d6002faa9cbb7db3a8d0b5898bce5f3d78c93b2f2b8f03597b8c8564c6ccb9e1b9e94037402b4516ed95d4ba389cd4ecee5ab57ded9667c39a03069f79646e20dbd7482930c13b0fb32f252a9db8d8eb42043d78e52205089b8473e005d8c90e4e46fd6fd838fca2f82e4ae633828483ea242b5fbee09f4f8f5e0af400723aba4dbad535e0227baf638bbb6505346c6f4ecb624e47f0ef53a494be891f1b93373823c402be6df42100f5746ec26d0810ef4e8ed3ef52b1d8674fbf88957924ae965075f3796aa2372d504fb5868668550d465e26f4def2194f599ffa57739f825837d86f8fe61d0992ddf8a26592b276e9571077da6c0a3fd8392af089522d5e0d14d6628c1fb1f59aee95979a9b14aac245ee84dfeda303c12d0613cee7a1040b27dfc1d7d3f7a26174d058f13b8feadda510ee3c631028da6cbca818b83755796bc6568ad3a2da0b4b4971e526a9c3d2b4b28e3f46276307302d307299562473b804c71f5768fcb1979d3532d2e1a68355615a7ca4e1146f26b82ec9449c3dbcf891f35b7f9b4da2b3d6c5e2dc20ad3ab59de85ad824f5580bacea130b65b9cbb64f2a02c29d4dadc9d05cafcb7ba2297b53fa32254d499eee8127a36f79c0569c44a95b345e8e7ed7b41b451a029985600e11bddaaeb0f0987cec56f829a69f85566341ba65e5ed00b13241869f4840f15427c64b3a0da082671cc5ccfda00d3c842c0198e56734975382a0b2ced88542e3cf821d651dac6b55e655e4c1ef4aadbf9e78485c2f4e844651c27e8603f825db7258f7d6d7801c94459a141088e0d4a6623008dd8e51da4c8b4b6be319efd9482ce43554e62ad932c2e4500ce653c76f11f750596e739cc14533ef3c73273cf9fd3675e5e712540963cd476722c5761de16d26a379df09bb2b97f7b2fe361cc4d099e7ee1478e54314db13739392b51387357838cac1c615f0d9d2c09b27ae098413bec0046af97a9c51a8213350031049d6dfecc4fba93f2713b1c27835af3f3153884782a991522ac698e6605e408f5d344e6a954a61dd610fe7443be381a0ac8161aff61d8058d739100fe9a16f906844b648e14bcdb4cf49ea7144b5caf88e9ffc4e8bcd518c69d456862bd2eee3966402ff8a5123582f78fca90d55f49ec3cd024d080f4466132228f1ee4a8fec967eb035a33a18738aea28e524fd0d9341732dae34f5f34e483593ec7e876cdded88f6f726b48c84e4f0f5856b87363df7a39bbbde2a3ca85743c53eae80274923426b2ea8f4682becb3b92926eb56e36c347d6955c5a9468668f2c140348c1bf7a6bfc5461b124e4e6c92003be8dd0147740b60392567226ffdd91d7a73fc0e368c71245ca6b55118d5886d70075e3c3efdf6f124cc8a9d4e2fe65424a42179f41940a3254b73ff6d74bcb2c3ba63707ffe4e159e868f57009e7b7096b6bbf35a9c7580ac2c8e48bf3effa1c6e463f45c964e733307b61ab350050ab931bc814e83ebb1d068aed9d7a8c313a13619cc17142ea73bb0b72dbb854f147a5158157e7f09a8c2fa7dbcff56ceff7eb190e66e106746917a051c2ece062215c97a74c85f648c71ab802453fe6bbe4792648d12f7f4c2e02aa37906abc07446275ebe5d527b2c0103e91d995c3c1b3d5d5fde5d7e7f8bd45ed1342fc9abb29d6ba47e053c46d03d0c6f98a2a255491586cad4571f0384e78cdc2904523f9468d8074703dd411cbcc570045aed730335806343be63cac5053d23f6663eb754fef058070485b187be3e5c06835d856967be4ab964b796669b5eb5da787179502a68c51029671cd318508c9c1885966176819ef38014a524f1e107ea20f0a7574a1667e8096120186af45a4e521bd76c28a1a7e8ca565d04dd918755b81f8c557596dbb9d47d97acb872100a3d511b42e4b06c1cca639ad1a755e2f1c94227c37c04ff589bed355e272abf3d080aa3319cfeda15b726cb93b9f54d2e5e5d0881a474e3246bd527be1875b34ff709bcbe54ae07a4973225a3b3cae0ee047e997f02d97f64eb6c57ee721f0cb9a1c83c38211199f4ec13495d6493ee77593e8f532b6734c1c7d6b6824c2768aec6505932993454ff7576eef7aebd61d65a755e2ff8207ea8f7c692c4def6f5b3bbfbcdee426d9dd0534557fa71d9ec27200f55439104215912d96e5445253fe2f620b37c7fce1d302daad2b146daccc3627f38eed655c6147a708eb4ef2b17f5b1d171e524e07b7e3c857faaa61af005cfb87fe2fc3eaad4b2df8a9e36bb680d3b6d9ba19e86f195b38a84e365eadcadb7d7e08cd3bc9fa0b0c7ccfd0ccca8aacefe3145198e4fd054eba64efa7bebe4065ecab4e9aed5d8a9fce7c8c2e729af47f9015f7ec58f39ec587a46237a0fb3e1f57b9a573bf7ff9558d25ba6fdaa69cc4e417ddf207226dc1935d988a11b13534bdaed3a9639402dcd2a2f955dd05b555c72615039bcf2515ae17a0975524075fca3d84b4cbc7817e221def089510b91e518fb75fe7226df4a1cbd3d84077e190ca7eb94294fceeb56f10928ce98f7714b2bc6d8b18f7275b654ff233ad5e8d5eeff5089065033f68e31f6bcdb0b1cdf050e9b54ecd22fff585709165eae4ec774a3d8695157fdc227c1cfdbb4352d0e6e2baf7587dcb99117b69653bc032c505c8bc57bc469b2326b6ca2294d28a3718b8b16c4500accdabaead44c8723ecbc8fa35377fcd268959807ba67650163d6662eee2ce1ce86d0e2c6dbd9f86f98fedf22b8badb5a9fe26724e463089dfe83896cda48116ab90eeb6f155cab98c3436b80a7a8baa1b16e31da0b589b7ce744d091cab217f5034697e2347c7679f130cf0bf5c7a7098b2113e3b22c35d6ca2c180d3b3517a30b317cec3e95ec818b08f30c95c8b317e7739e49b36ed386c0b2424acd0779cf2d1a0c82dc0c5d4c70e3abf755df67078f791f9983a87806766e8ab66e38c02e024282eb2d97b501a790e3100d5f3320a68d7799675515d9e41ecc7e4f8fbc03d47eb2d0027635a753cfa938bd3f7422dd4cd55dec0e623f1dc89f5c7b43892f41f4241c03b2334d1a2a698b070e5fb3078d510d4f8c0a10884879047c070234f480199434dc00220ef9a4005983a95e7fdf5c80f593297249c9d430ff8413b0330ba9ee936968f5a14cc4ed9cc19c5d2f4c2e030a1f0d23c5faa606432b9bf4a784cc78d73cce3dbd0be80b52e12f6370e4573ab77a5713dd52d06bb9e85415f6be182bb55b2e947b9c53aabb24dabe31c13c3a7deb5d40793dd44aebd3df9abac85e290769235b8c196988fa91c471ae5e394cab3b10d26f4ffa894fcbea543b01598273f11e64577d85f4830003381c085828fadeb75826b34a7d82e4dc6ba64f381fe5cd0aa248d4a43448ddcc0d614b120ed69b3f056fe34ea65487dfabe7bc32fa44189eb0b04bc5c563a1e6ef16008005218fce23089a373600ec9f5bcd7c4efa23e3c33eb7d1457178bfd701a4f4862b38f07abd3809ba7217ad0796ff257713dd19328fc309c4403566d235ef72cb3770349147f2026a7c96725c0ac860fced5dadf908dc57126af626bfb80ebf3543f244b0585fd6daadac84103be88fa270f7174636e7ba4ee82048ffeb0ac703ae51d867f0a74b9d2c3755307f6ed974f814d4e7c9631c17d7a92549d96a7fde3836f21b6c62538d10b969f4d839c20abf5a289100f9aae0706a25fbed69e56295156b6b1f80f3d7674842f2fdf2e8c2e3129dc12ad779cf96bd83970236516b847699286d28da32e4c5df00e716659ee3e7fe282d5960f05618c7dcc99762fc4d11da002be14889b7695d41be34e395c98cd2d2f1190c73261b0a31546aed7178c70bd104ae05c9ce9c3ff8f99dfc0e8e821883b9d8ba63a075432ef07bd1c4fd7a8c590e2e3552a80562a7ad1332390d85cfe90f2363db7083b5b9819625eff5fe9c820ca2a022615e42db4ed412ff6c3f29fe6000aab4b84c9eda322a8214f53178ebfc44eea521318aec1570938b3c8092625ca7ffb1cfd99fe51d92cdbc3063c826c9f331847da56536948cb19d3162ed8bcf5580c05f19283af2680d2622a397207aac191728f7c8201bc288fc8ad8ba90218942cf7d742fc4a5de6f45bb7fecce3b9f53c874b4ae2965b471d6025ef299490c49754b66286e1561ba98a7eb7a4cd10e9bf387987d544c3deabcf09061b0fd6934026fbacbb502e9e2364885cbe2460ac5e4ef99fc8eb25141775f94b96515c8f9c3741f4030d7bc481318c4672a81e7aa8c9f778d2dcd882f09a83b7e03bf40a2b89f31fee048315c8c89cfd1770ee813e5f0b9b8da9683783e21b6c3ba5643921d6bbba0ec45bf83ed92169510862ddb7859afeea0a7ad85bb90cd93206c79b7e0b981a8232d67d93cca8bc983f0f05325762d1aae93c5ccaf5d5765494a75cf7f78476d00e0f3adbab677fde8fdcdf8b585f1f504045ede58eaeb5d0d053433f3a4efe759f196705cd27f0db71dc8a909711edbb4a8712f1c5ff36129d0bab7b1ee665b2dae7b869c426fd7d5b80314c9f50e1d8dca9edb7fed6a399da7e408ff78bba584e2fb263e97a85eccaa366c6c1d7dccc2ab9c3677a2c648a28145c5524dd00715b745936f2b568f3972061e9d9a5aa48a0cbc64d03b656c0bc0fbfd4cd75ae1eaec3ae7c2b93e536bdc708afd2d5346a006ccac71f8d5ee47f14f6b8d44fcdbe87a01de5b6724d0a099276ea6a673e5c8850d91cdcbecaa00cc3b7cbafa485924f19c5b53bb31f201f5e5c91881e3c9fc40516dfeea576e4e76302f5b1f6ef8e63499c221d0ca31322b8784ac962d934c1d5a7828c9d6921cbeffc35a08858544f76ea63ff67baeb6283e5783307a913661aaa77b3a37bd9848bbcae56be95bee1d38e94a1132fd0d4cf358b2718c2c246113a70b62064976da63b56cdf33bfb1e981912288f501969e1cdfa06ab558a6715a22f68e53fc36a09acca84d1d3b6b3532591dea38f33ef67a7b99c4c7bcf7c44de0fd2eece87a89a9b84791106a9fcdf26c2e498e920bab5612f4a5da348cce3f3f67d4fb17b140d570d918992243eb831cc05875da914458afda64c2c275e55a8a5e501cf920da09fb23bca794a403697ded9441e80557bec3270223e38da91fa48866fd4f9eda852c876d0d188b7188206bd0bfe6a78a22a47f925c7fa1691131a399aa159059eba585e21187a26e27d947ce442fbed9681ee40141ed1760c56545c350d129a15d13dd503a21b8b424f8808ec331aee6978617fc674bef7ca8b818ada2bed1c5ea4cb2f24c6c5e4148ce7e7fa1a20e443d10a763b6616937af6c6f47df01ccda6611daeee7db5c8997a449031b3af0e7dfea982f6c2c509212611dad23e6050af672819631896e87a0574204201202708c813bcd390d608ba10538c9956c400b4d0d29b88716eca1b43f17ad68dfa7c8acf525ccc66da55e2198fe2a4391bda3e6edc36815939a09abaed6427169809c069928dc969f5769b665bc61a74715d591949e6b210cbda753a68440009f2424367a9b1bfb1edad79e9e9f1cbf58c7e02f680311bb3f18170a5a075b7db72a216e1ad9f1bd691cc9b800ea0e7b97226296f1275bbf25d5505f53fd5867d71cf34000ca282a3e554e560ba52ebce252a39745d053c3c01301c3f095f8489b5bd560cbda1b1510b27230ffe91c7e8042ae8357bf80ee4f31ddd1a64a1c217ec018cbf22e88f840c49d3f248013260d5e231efbc273d62d2082e3e6ff3dd0e15aa0c5b4f32d92ebb6e3acc90f2b53db8da96de741353584fb80e2f9888c1e4a458d658c9367673dd8da85608e23d9d46c90f6a3d51572b06940809603ea7a4efe241518da57d0dfddc88783045e1c41a1c33cced1b7fc2a1a7e8f7cef6e61a2ff021c1cc63a8f7fd2766be8185066242c3b043c59343d0ff2fc90c79f2c05e80528abf886f0cd821e51fbe2dd1e0485f2af09363273fbe9a399cdc3fa2e39bcb87650cf4acb6f7bf5d0865029423894cb79842f389c33e3aeb38edc93c54d32ee27cff9d2994951b2a1fc097b358371d1c35b6485619450fc7eb9e69953f17d1312b7ef45051b2faf5b280f31742c3c8659bad4ee7a4d01879d5dc84ccccb1874c1c444fb6d05a536c2a2f0157530abec0589325f98176ad972960f341f766e3d8f592f8e9d09845ce5cf782a5cc823b589be6890be2ca9a6f848acdaf2d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里需要密码才能访问。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>练习题</title>
      <link href="/2021/03/24/%E5%88%B7%E9%A2%98/"/>
      <url>/2021/03/24/%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a><a href="https://www.nowcoder.com/exam/oj/ta?tpId=13">剑指Offer</a></h2><h3 id="JZ3-数组中重复的数字"><a href="#JZ3-数组中重复的数字" class="headerlink" title="JZ3 数组中重复的数字"></a><a href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524">JZ3 数组中重复的数字</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span>* numbers, <span class="type">int</span> numbersLen )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> num[numbersLen];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;numbersLen;i++)</span></span><br><span class="line">    <span class="comment">//     num[i]=0; //需要初始化，清0！</span></span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, numbersLen*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numbersLen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[numbers[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(num[numbers[i]]&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了一下，排名第一的代码用的指针。我测试也不通过，不知道哪里出现的原因。以后再看看吧！</p><h3 id="JZ4-二维数组中的查找"><a href="#JZ4-二维数组中的查找" class="headerlink" title="JZ4 二维数组中的查找"></a><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e">JZ4 二维数组中的查找</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> r = array.<span class="built_in">size</span>(); <span class="comment">//行</span></span><br><span class="line">        <span class="type">int</span> l = array[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, down = r - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; l &amp;&amp; down &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = array[down][left];</span><br><span class="line">            <span class="keyword">if</span> (tmp == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; target) left++;</span><br><span class="line">            <span class="keyword">else</span> down--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ5-替换空格"><a href="#JZ5-替换空格" class="headerlink" title="JZ5 替换空格"></a><a href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68">JZ5 替换空格</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">replaceSpace</span><span class="params">(<span class="type">char</span>* s )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* te=s;</span><br><span class="line">    <span class="keyword">while</span>(*te)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*te==<span class="string">&#x27; &#x27;</span>) num++;</span><br><span class="line">        ++te;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* t=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)+num*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span>* res=t;</span><br><span class="line">    <span class="keyword">while</span>(*s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *t++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            *t++ = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            *t++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> *t++ =*s++;</span><br><span class="line">    &#125;</span><br><span class="line">    *t=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个卡了好长时间啊！</p><h3 id="JZ10-斐波那契数列"><a href="#JZ10-斐波那契数列" class="headerlink" title="JZ10 斐波那契数列"></a><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3">JZ10 斐波那契数列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 下边代码太耗时！ 尽量不要用递归调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">Fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时低！ 可以用for循环！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ44-数字序列中某一位的数字"><a href="#JZ44-数字序列中某一位的数字" class="headerlink" title="JZ44 数字序列中某一位的数字"></a><a href="https://www.nowcoder.com/practice/29311ff7404d44e0b07077f4201418f5">JZ44 数字序列中某一位的数字</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i*(<span class="built_in">pow</span>(<span class="number">10</span>, i)) &lt; n)&#123;</span><br><span class="line">            n += <span class="built_in">pow</span>(<span class="number">10</span>, i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(n/i)[n%i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>想了很长时间，最后还是看的题解。。。</p><h3 id="JZ50-第一个只出现一次的字符"><a href="#JZ50-第一个只出现一次的字符" class="headerlink" title="JZ50 第一个只出现一次的字符"></a><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c">JZ50 第一个只出现一次的字符</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="type">char</span>* str )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> num[<span class="number">125</span>]=&#123;<span class="number">0</span>&#125;, len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) num[str[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[str[i]] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要了解ascaii编码情况！</p><h3 id="JZ6-从尾到头打印链表"><a href="#JZ6-从尾到头打印链表" class="headerlink" title="JZ6 从尾到头打印链表"></a><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035">JZ6 从尾到头打印链表</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">printListFromTailToHead</span><span class="params">(<span class="keyword">struct</span> ListNode* listNode, <span class="type">int</span>* returnSize )</span> </span>&#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="type">int</span> num[<span class="number">10000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> num1[<span class="number">10000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> nums = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ListNode</span>* p = listNode;  <span class="comment">//之前不定义，想直接操作！！</span></span><br><span class="line">  <span class="keyword">for</span>(; p!=<span class="literal">NULL</span>; p=p-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">      num[nums++] = p-&gt;val;</span><br><span class="line">  &#125;</span><br><span class="line">  nums--;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;nums&gt;=<span class="number">0</span>;--nums)</span><br><span class="line">  &#123;</span><br><span class="line">      num1[i++] = num[nums];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> *arr = num1; </span><br><span class="line">  *returnSize=i; <span class="comment">//必须有返回值!</span></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JZ7-重建二叉树"><a href="#JZ7-重建二叉树" class="headerlink" title="JZ7 重建二叉树"></a><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6">JZ7 重建二叉树</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (pre.<span class="built_in">size</span>() == <span class="number">0</span> || vin.<span class="built_in">size</span>() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="comment">//先找到preorder中的起始元素作为根节点，在inorder中找到根节点的索引mid；</span></span><br><span class="line">      <span class="comment">//那么，preorder[1:mid + 1]为左子树，preorder[mid + 1:]为右子树；</span></span><br><span class="line">      <span class="comment">//inorder[0:mid]为左子树，inorder[mid + 1:]为右子树。</span></span><br><span class="line">      TreeNode* treeNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">      <span class="type">int</span> mid = <span class="built_in">distance</span>(<span class="built_in">begin</span>(vin), <span class="built_in">find</span>(vin.<span class="built_in">begin</span>(), vin.<span class="built_in">end</span>(), pre[<span class="number">0</span>]));</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_pre</span><span class="params">(pre.begin()+<span class="number">1</span>, pre.begin() + mid +<span class="number">1</span>)</span></span>;</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_pre</span><span class="params">(pre.begin() + mid + <span class="number">1</span>, pre.end())</span></span>;</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_in</span><span class="params">(vin.begin(), vin.begin() + mid)</span></span>;</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_in</span><span class="params">(vin.begin() + mid +<span class="number">1</span>, vin.end())</span></span>;</span><br><span class="line"></span><br><span class="line">      treeNode-&gt;left = <span class="built_in">reConstructBinaryTree</span>(left_pre, left_in);</span><br><span class="line">      treeNode-&gt;right = <span class="built_in">reConstructBinaryTree</span>(right_pre, right_in);</span><br><span class="line">      <span class="keyword">return</span> treeNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好难！！！！！！！！</p><h3 id="JZ9-用两个栈实现队列"><a href="#JZ9-用两个栈实现队列" class="headerlink" title="JZ9 用两个栈实现队列"></a><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6">JZ9 用两个栈实现队列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">      stack1.<span class="built_in">push</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (stack1.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">          stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">          stack1.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> value = stack2.<span class="built_in">top</span>();</span><br><span class="line">      stack2.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">while</span> (!stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          stack1.<span class="built_in">push</span>(stack2.<span class="built_in">top</span>());</span><br><span class="line">          stack2.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ11-旋转数组的最小数字"><a href="#JZ11-旋转数组的最小数字" class="headerlink" title="JZ11 旋转数组的最小数字"></a><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba">JZ11 旋转数组的最小数字</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="type">int</span>* rotateArray, <span class="type">int</span> rotateArrayLen )</span> </span>&#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, r = rotateArrayLen - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[r]) l = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[r] ) r = mid;</span><br><span class="line">      <span class="keyword">else</span> r -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rotateArray[l];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题看别人题解才写出来的。。。还是不会运用二分</p><p><a href="https://blog.csdn.net/whc18858/article/details/122379930?spm=1001.2014.3001.5501">【玩转二分查找Ⅰ】左闭右闭型，左开右闭型，左闭右开型（动图演绎）</a></p><h3 id="JZ17-打印从1到最大的n位数"><a href="#JZ17-打印从1到最大的n位数" class="headerlink" title="JZ17 打印从1到最大的n位数"></a><a href="https://www.nowcoder.com/practice/4436c93e568c48f6b28ff436173b997f">JZ17 打印从1到最大的n位数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* returnSize )</span> </span>&#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">1</span>; i&lt; <span class="built_in">pow</span>(<span class="number">10</span>, n) ; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">      a[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  *returnSize = --i;</span><br><span class="line">  <span class="type">int</span>* a1=a+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JZ18-删除链表的节点"><a href="#JZ18-删除链表的节点" class="headerlink" title="JZ18 删除链表的节点"></a><a href="https://www.nowcoder.com/practice/f9f78ca89ad643c99701a7142bd59f5d">JZ18 删除链表的节点</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* <span class="built_in">deleteNode</span>(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val ) &#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ListNode</span>* p = head;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ListNode</span>* p1 = head;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;val != val)</span><br><span class="line">  &#123;</span><br><span class="line">      p1 = p;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">  &#125; </span><br><span class="line">  p1-&gt;next = p-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(p == head) <span class="keyword">return</span> p-&gt;next;  <span class="comment">// rug</span></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JZ24-反转链表"><a href="#JZ24-反转链表" class="headerlink" title="JZ24 反转链表"></a><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca">JZ24 反转链表</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* <span class="built_in">ReverseList</span>(<span class="keyword">struct</span> ListNode* pHead ) &#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ListNode</span>* p = pHead;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ListNode</span>* q = p-&gt;next;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ListNode</span>* r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(p == pHead) p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">      r = q-&gt;next;</span><br><span class="line">      q-&gt;next = p;</span><br><span class="line">      p = q;</span><br><span class="line">      q = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写了好长时间啊！！！！</p><h3 id="JZ25-合并两个排序的链表"><a href="#JZ25-合并两个排序的链表" class="headerlink" title="JZ25 合并两个排序的链表"></a><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337">JZ25 合并两个排序的链表</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* <span class="built_in">Merge</span>(<span class="keyword">struct</span> ListNode* pHead1, <span class="keyword">struct</span> ListNode* pHead2 ) &#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">  <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ListNode</span>* pHead = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)</span><br><span class="line">  &#123;</span><br><span class="line">      pHead = pHead1;</span><br><span class="line">      pHead-&gt;next = <span class="built_in">Merge</span>(pHead1-&gt;next, pHead2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      pHead = pHead2;</span><br><span class="line">      pHead-&gt;next = <span class="built_in">Merge</span>(pHead1, pHead2-&gt;next);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JZ30-包含min函数的栈"><a href="#JZ30-包含min函数的栈" class="headerlink" title="JZ30 包含min函数的栈"></a>JZ30 包含min函数的栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param value int整型 </span></span><br><span class="line"><span class="comment">* @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> stack[<span class="number">301</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> min_num = <span class="number">99999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value )</span> </span>&#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  stack[i++] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param 无 </span></span><br><span class="line"><span class="comment">* @return 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param 无 </span></span><br><span class="line"><span class="comment">* @return int整型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="type">int</span> num = stack[--i];</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param 无 </span></span><br><span class="line"><span class="comment">* @return int整型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="type">int</span> min = min_num;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(stack[k] &lt; min) min = stack[k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看别人的题解了。。。。。</p><h3 id="JZ69-跳台阶"><a href="#JZ69-跳台阶" class="headerlink" title="JZ69 跳台阶"></a><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4">JZ69 跳台阶</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(number == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(number == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">jumpFloor</span>(number <span class="number">-1</span>) + <span class="built_in">jumpFloor</span>(number - <span class="number">2</span>);  <span class="comment">// ?? </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看别人题解了。。。</p><h3 id="JZ71-跳台阶扩展问题"><a href="#JZ71-跳台阶扩展问题" class="headerlink" title="JZ71 跳台阶扩展问题"></a><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387">JZ71 跳台阶扩展问题</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number )</span> </span>&#123;</span><br><span class="line">  <span class="comment">// write code here</span></span><br><span class="line">  <span class="keyword">if</span>(number == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">jumpFloorII</span>(number<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一遍自己写不出来。</p><h3 id="JZ70-矩形覆盖"><a href="#JZ70-矩形覆盖" class="headerlink" title="JZ70 矩形覆盖"></a><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6">JZ70 矩形覆盖</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">rectCover</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(number &lt;= <span class="number">3</span>) <span class="keyword">return</span> number;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">rectCover</span>(number<span class="number">-1</span>) +<span class="built_in">rectCover</span>(number<span class="number">-2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ8-二叉树的下一个结点"><a href="#JZ8-二叉树的下一个结点" class="headerlink" title="JZ8 二叉树的下一个结点"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e">JZ8 二叉树的下一个结点</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># 方法一 中序遍历递归（推荐使用）</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeLinkNode*&gt; nodes;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeLinkNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">InOrder</span>(root-&gt;left);</span><br><span class="line">        nodes.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="built_in">InOrder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode* root = pNode;</span><br><span class="line">        <span class="comment">// 获取根节点</span></span><br><span class="line">        <span class="keyword">while</span> (root-&gt;next) root = root-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序遍历用nodes储存所有节点指针</span></span><br><span class="line">        <span class="built_in">InOrder</span>(root);</span><br><span class="line">        <span class="type">int</span> n = nodes.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            TreeLinkNode* cur = nodes[i];</span><br><span class="line">            <span class="comment">// 将结点进行匹配</span></span><br><span class="line">            <span class="keyword">if</span> (pNode == cur) &#123;</span><br><span class="line">                <span class="comment">// 如果有匹配到给出的结点，则下一个结点即返回结果</span></span><br><span class="line">                <span class="keyword">return</span> nodes[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则如果没有下一个结点则返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 方法二 分类直接寻找 需要考虑所有情况！！</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有右子树，找到最左下节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeLinkNode* rchild = pNode-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(rchild-&gt;left) rchild = rchild-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无右子树且当前节点是其父节点的左子节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;next &amp;&amp; pNode-&gt;next-&gt;left ==pNode)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无右子树 且当前节点是其父节点的右节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeLinkNode* ppar = pNode-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(ppar-&gt;next &amp;&amp; ppar-&gt;next-&gt;right == ppar) ppar = ppar-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> ppar-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ54-二叉搜索树的第k个节点"><a href="#JZ54-二叉搜索树的第k个节点" class="headerlink" title="JZ54 二叉搜索树的第k个节点"></a><a href="https://www.nowcoder.com/practice/57aa0bab91884a10b5136ca2c087f8ff">JZ54 二叉搜索树的第k个节点</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"># 递归处理</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">InOrder</span>(root-&gt;left);</span><br><span class="line">        nodes.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="built_in">InOrder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 中序</span></span><br><span class="line">        <span class="keyword">if</span>(proot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">InOrder</span>(proot);</span><br><span class="line">        <span class="type">int</span> n = nodes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> nodes[k<span class="number">-1</span>]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 递归不存储！</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">midOrder</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">midOrder</span>(root-&gt;left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            res = root;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">midOrder</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">midOrder</span>(proot, k);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            <span class="keyword">return</span> res-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 方法二：非递归中序遍历 栈</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(proot ==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> count =<span class="number">0</span>;</span><br><span class="line">        TreeNode* p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//用栈辅助建立中序</span></span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || proot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (proot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(proot);</span><br><span class="line">                <span class="comment">//中序遍历每棵子树从最左开始</span></span><br><span class="line">                proot = proot-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == k)  <span class="comment">//第k个直接返回</span></span><br><span class="line">                <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">            proot = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ68-二叉搜索树的最近公共祖先"><a href="#JZ68-二叉搜索树的最近公共祖先" class="headerlink" title="JZ68 二叉搜索树的最近公共祖先"></a><a href="https://www.nowcoder.com/practice/d9820119321945f588ed6a26f0a6991f">JZ68 二叉搜索树的最近公共祖先</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="comment">// 保证 q &lt; q</span></span><br><span class="line">        <span class="keyword">if</span> (p &gt; q) &#123;</span><br><span class="line">            num = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; node-&gt;val &amp;&amp; q &gt; node-&gt;val) <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; node-&gt;val &amp;&amp; q &lt; node-&gt;val) node = node-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (p &gt; node-&gt;val &amp;&amp; q &gt; node-&gt;val) node = node-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val == p || node-&gt;val == q)  <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ12-矩阵中的路径"><a href="#JZ12-矩阵中的路径" class="headerlink" title="JZ12 矩阵中的路径"></a><a href="https://www.nowcoder.com/practice/2a49359695a544b8939c77358d29b7e6">JZ12 矩阵中的路径</a></h3><p><strong>知识点：递归与回溯</strong></p><p>递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。因此递归过程，最重要的就是查看能不能讲原本的问题分解为更小的子问题，这是使用递归的关键。</p><p>如果是线型递归，子问题直接回到父问题不需要回溯，但是如果是树型递归，父问题有很多分支，我需要从子问题回到父问题，进入另一个子问题。因此回溯是指在递归过程中，从某一分支的子问题回到父问题进入父问题的另一子问题分支，因为有时候进入第一个子问题的时候修改过一些变量，因此回溯的时候会要求改回父问题时的样子才能进入第二子问题分支。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param matrix char字符型vector&lt;vector&lt;&gt;&gt; </span></span><br><span class="line"><span class="comment">     * @param word string字符串 </span></span><br><span class="line"><span class="comment">     * @return bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;&gt; &amp; matrix, <span class="type">int</span> n,<span class="type">int</span> m, <span class="type">int</span> i,<span class="type">int</span> j, <span class="built_in">string</span> word,<span class="type">int</span> k, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;&gt; &amp; flag )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i &gt;= n || j&lt;<span class="number">0</span> || j&gt;=m || (matrix[i][j] != word[k])||flag[i][j] == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        flag[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(matrix, n, m, i<span class="number">-1</span>, j, word, k+<span class="number">1</span>, flag) </span><br><span class="line">            || dfs(matrix, n, m, i+<span class="number">1</span>, j, word, k+<span class="number">1</span>, flag) </span><br><span class="line">            || dfs(matrix, n, m, i, j<span class="number">-1</span>, word, k+<span class="number">1</span>, flag)</span><br><span class="line">            || dfs(matrix, n, m, i, j+<span class="number">1</span>, word, k+<span class="number">1</span>, flag)  )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        flag[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">hasPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; &gt;&amp; matrix, <span class="built_in">string</span> word)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = matrix.size();</span><br><span class="line">        <span class="type">int</span> m = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;&gt; flag(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(matrix, n, m, i, j, word, <span class="number">0</span>, flag))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看的题解，才写出来</p><h3 id="JZ13-机器人的运动范围"><a href="#JZ13-机器人的运动范围" class="headerlink" title="JZ13 机器人的运动范围"></a><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8">JZ13 机器人的运动范围</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  public:</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums += (i % <span class="number">10</span>);</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums += (j % <span class="number">10</span>);</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums &gt; threshold)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> i, <span class="type">int</span> j,</span></span><br><span class="line"><span class="params">             <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;&gt;&amp; flag)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || flag[i][j] == <span class="literal">true</span> ||</span><br><span class="line">                judge(threshold, i, j))</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        num++;</span><br><span class="line">        flag[i][j] = <span class="literal">true</span>;</span><br><span class="line">        dfs(threshold, rows, cols, i - <span class="number">1</span>, j, flag);</span><br><span class="line">        dfs(threshold, rows, cols, i + <span class="number">1</span>, j, flag);</span><br><span class="line">        dfs(threshold, rows, cols, i , j<span class="number">-1</span>, flag);</span><br><span class="line">        dfs(threshold, rows, cols, i , j+<span class="number">1</span>, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;&gt; flag(rows, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(cols, <span class="literal">false</span>));</span><br><span class="line">        dfs(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, flag);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="JZ64-求1-2-3-…-n"><a href="#JZ64-求1-2-3-…-n" class="headerlink" title="JZ64 求1+2+3+…+n"></a><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1">JZ64 求1+2+3+…+n</a></h3><p>方法：与运算的短路递归（推荐使用）</p><p><strong>知识点：位运算</strong></p><p><strong>在函数中，如果与运算成立，则继续，否则终止函数直接返回false。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        n &amp;&amp; (n += Sum_Solution(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ65-不用加减乘除做加法"><a href="#JZ65-不用加减乘除做加法" class="headerlink" title="JZ65 不用加减乘除做加法"></a><a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215">JZ65 不用加减乘除做加法</a></h3><p>思路很重要，但是做不出来。。。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> add =num2;</span><br><span class="line">        <span class="type">int</span> sum = num1;</span><br><span class="line">        <span class="keyword">while</span>(add != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp= sum ^ add;</span><br><span class="line">            add = (add &amp; sum) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            sum = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ15-二进制中1的个数"><a href="#JZ15-二进制中1的个数" class="headerlink" title="JZ15 二进制中1的个数"></a><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8">JZ15 二进制中1的个数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">     <span class="type">int</span>  <span class="title function_">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;<span class="number">32</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>)</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ56-数组中只出现一次的两个数字"><a href="#JZ56-数组中只出现一次的两个数字" class="headerlink" title="JZ56 数组中只出现一次的两个数字"></a><a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8">JZ56 数组中只出现一次的两个数字</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  public:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param array int整型vector</span></span><br><span class="line"><span class="comment">     * @return int整型vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; <span class="built_in">array</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">res</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span>;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++) &#123;</span><br><span class="line">            temp ^= <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((k &amp; temp) == <span class="number">0</span>)</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">array</span>.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &amp; <span class="built_in">array</span>[i]) == <span class="number">0</span>)</span><br><span class="line">                res[<span class="number">0</span>] ^= <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[<span class="number">1</span>] ^= <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] &lt; res[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;res[<span class="number">1</span>], res[<span class="number">0</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JZ16-数值的整数次方"><a href="#JZ16-数值的整数次方" class="headerlink" title="JZ16 数值的整数次方"></a><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00">JZ16 数值的整数次方</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            base = <span class="number">1.0</span>/base;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> res=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;exponent;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a href="https://www.programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">数组</a></h3><p>大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。</p><p><strong>数组的元素是不能删的，只能覆盖。</strong></p><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4><p><img src="image/image.png" alt="image.png"></p><p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>写二分法，区间的定义一般为两种，<strong>左闭右闭</strong>即[left, right]，或者<strong>左闭右开</strong>即[left, right)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.size()<span class="number">-1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="comment">// int mid = (left + right) /2;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) </span><br><span class="line">                right = mid <span class="number">-1</span>;  <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left =mid +<span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// nums[middle] == target</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.size(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(log n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><p><img src="image/image 1.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力做法  时间复杂度：O(n^2)    空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;size; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[j<span class="number">-1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 这个地方有点想不出来。。。</span></span><br><span class="line">                i--; <span class="comment">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class="line">                size--;  <span class="comment">// 此时数组的大小-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li><p>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</p></li><li><p>慢指针：指向更新 新数组下标的位置</p></li></ul><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针法，设计十分巧妙</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slowindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt;nums.size(); fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val)&#123;</span><br><span class="line">                nums[slowindex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowindex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意这些实现方法并没有改变元素的相对位置！</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4><p><img src="image/image 2.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力排序 时间复杂度是 O(n + nlogn)， 可以说是O(nlogn)的时间复杂度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针法  时间复杂度为O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A)</span> &#123;</span><br><span class="line">        <span class="type">int</span> k = A.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">result</span><span class="params">(A.size(), <span class="number">0</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = A.size() - <span class="number">1</span>; i &lt;= j;) &#123; <span class="comment">// 注意这里要i &lt;= j，因为最后要处理两个元素</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] * A[i] &lt; A[j] * A[j])  &#123;</span><br><span class="line">                result[k--] = A[j] * A[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[k--] = A[i] * A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力解法 超时！ 时间复杂度：O(n^2)   空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 最终的结果   stdint.h</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j= i; j &lt;nums.size();j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    len = j-i+<span class="number">1</span>;</span><br><span class="line">                    result = result &lt;len? result:len; <span class="comment">// 操作很神奇。。。</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)   空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, len = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;=target)&#123;</span><br><span class="line">                len = j -i +<span class="number">1</span>;</span><br><span class="line">                result = result &lt;len ? result :len ;</span><br><span class="line">                sum -=nums[i++]; <span class="comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4><p>这道题目可以说在面试中出现频率较高的题目，<strong>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; res(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop--)&#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span>(i = startx; i &lt; n -offset; i++)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++, starty++, offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>)&#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个需要多多的去练习！！！</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  ListNode *next;</span><br><span class="line">  ListNode(<span class="type">int</span> x): val(x), next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(head !=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = head;</span><br><span class="line">            head =head-&gt;next;</span><br><span class="line">            delete tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur !=<span class="literal">NULL</span> &amp;&amp; cur-&gt;next!= <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                delete tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个虚拟头结点在进行移除节点操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        ListNode *m_head = new ListNode(<span class="number">0</span>);</span><br><span class="line">        m_head-&gt;next = head;</span><br><span class="line">        ListNode *cur = m_head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                delete tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = m_head-&gt;next;</span><br><span class="line">        delete m_head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>哈希函数</p><p>哈希碰撞</p><p>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><p>拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><p>线性探测法</p><p>一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>常见的三种哈希结构</p><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li><p>数组</p></li><li><p>set （集合）</p></li><li><p>map(映射)</p></li></ul><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p><p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h4><p><img src="image/image 3.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次写的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> nums1[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> nums2[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[(s[i]-<span class="string">&#x27;a&#x27;</span>)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;t.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums2[(t[i]-<span class="string">&#x27;a&#x27;</span>)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] != nums2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4><p><img src="image/image 4.png" alt="image.png"></p><p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</strong></p><p>但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><p>此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li><p>std::set</p></li><li><p>std::multiset</p></li><li><p>std::unordered_set</p></li></ul><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是<strong>哈希表</strong>， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">1010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; records;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; nums1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[nums1[i]] == <span class="number">0</span>)   <span class="comment">// record[nums1[i]]=1;</span></span><br><span class="line">                record[nums1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;nums2.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[nums2[i]] == <span class="number">1</span>)</span><br><span class="line">                record[nums2[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i] == <span class="number">2</span>)</span><br><span class="line">                records.push_back(i); <span class="comment">// 之前写的record[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> records;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums2)</span> &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt; <span class="title function_">nums_set</span><span class="params">(nums1.begin(),nums1.end())</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_set.find(num) != nums_set.end())&#123;</span><br><span class="line">                result.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result.begin(), result.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拓展</p><p>那有同学可能问了，遇到哈希问题我直接都用set不就得了，用什么数组啊。</p><p>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。</p><p>不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。</p><h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h4><p><img src="image/image 5.png" alt="image.png"></p><p>这道题目看上去貌似一道数学问题，其实并不是！</p><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有分开写的习惯，以后要养成这个习惯</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) *(n % <span class="number">10</span>);</span><br><span class="line">            n /=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> sum = getSum(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.find(sum) != res.end())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.insert(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h4><p><img src="image/image 6.png" alt="image.png"></p><p>首先我在强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p><p>那么我们就应该想到使用哈希法了。</p><p>因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li><p>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</p></li><li><p>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</p></li></ul><p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。</p><p>C++中map，有三种类型：</p><p><img src="image/image 7.png" alt="image.png"></p><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。</p><p>同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 </p><p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</strong> 使用其他语言的录友注意了解一下自己所用语言的数据结构就行。</p><p>接下来需要明确两点：</p><ul><li><p><strong>map用来做什么</strong></p></li><li><p><strong>map中key和value分别表示什么</strong></p></li></ul><p>map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</p><p>接下来是map中key和value分别表示什么。</p><p>这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。</p><p>那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。</p><p>所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。</p><p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑过暴力法  最后还是选择看题解吧</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter =<span class="built_in">map</span>.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter != <span class="built_in">map</span>.end())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.insert(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h4><p><img src="image/image 8.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums3, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums4)</span> &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a: nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b: nums2)&#123;</span><br><span class="line">                umap[a+b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c: nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d: nums4)&#123;</span><br><span class="line">                <span class="keyword">if</span>(umap.find(<span class="number">0</span>-(c+d)) != umap.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    count += umap[<span class="number">0</span>-(c+d)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h4><p><img src="image/image 9.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> &#123;</span><br><span class="line">        <span class="type">int</span> nums[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; ransomNote.size(); i ++)&#123;</span><br><span class="line">            nums[ransomNote[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;magazine.size(); i++ )&#123;</span><br><span class="line">            </span><br><span class="line">            nums[magazine[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; <span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考代码</span></span><br><span class="line"><span class="comment">// 时间复杂度: O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> &#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//add</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.size() &gt; magazine.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 通过recode数据记录 magazine里各个字符出现次数</span></span><br><span class="line">            record[magazine[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ransomNote.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 遍历ransomNote，在record里对应的字符个数做--操作</span></span><br><span class="line">            record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">// 如果小于零说明ransomNote里出现的字符，magazine没有</span></span><br><span class="line">            <span class="keyword">if</span>(record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><p><img src="image/image 10.png" alt="image.png"></p><p>直接寄。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时！！ 还不会写。。。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="comment">//  a = nums[i], b = nums[j], c = -(a + b)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; nums.size(); i++)&#123; </span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> ) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//三元组元素a去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i <span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j&lt;nums.size(); j++)&#123;</span><br><span class="line">                <span class="comment">// 三元组元素b去重</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">2</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>] &amp;&amp; nums[j<span class="number">-1</span>]==nums[j<span class="number">-2</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> c = <span class="number">0</span> - nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">set</span>.find(c) != <span class="built_in">set</span>.end())&#123;</span><br><span class="line">                    res.push_back(&#123;nums[i],nums[j], c&#125;);</span><br><span class="line">                    <span class="built_in">set</span>.erase(c);<span class="comment">// 三元组元素c去重</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">set</span>.insert(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双指针。。。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法 位置不能变换，否则会越界！</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.push_back(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。</p><p>而且使用哈希法 在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也是可以在leetcode上通过，但是程序的执行时间依然比较长 。</p><p>接下来我来介绍另一个解法：双指针法，<strong>这道题目使用双指针法 要比哈希法高效一些</strong>，那么来讲解一下具体实现的思路。</p><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看的题解，这里边好多细节啊！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.size(); k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.push_back(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>一般来说哈希表都是用来快速判断一个元素是否出现集合里</strong>。</p><p>对于哈希表，要知道<strong>哈希函数</strong>和<strong>哈希碰撞</strong>在哈希表中的作用.</p><p>哈希函数是把传入的key映射到符号表的索引上。</p><p>哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。</p><p>接下来是常见的三种哈希结构：</p><ul><li><p>数组</p></li><li><p>set（集合）</p></li><li><p>map（映射）</p></li></ul><p>接下来是常见的三种哈希结构：</p><ul><li><p>数组</p></li><li><p>set（集合）</p></li><li><p>map（映射）</p></li></ul><p>在C++语言中，set 和 map 都分别提供了三种数据结构，每种数据结构的底层实现和用途都有所不同，</p><p>例如什么时候用std::set，什么时候用std::multiset，什么时候用std::unordered_set，都是很有考究的。</p><p><strong>只有对这些数据结构的底层实现很熟悉，才能灵活使用，否则很容易写出效率低下的程序</strong>。</p><p>哈希表经典题目</p><p>数组作为哈希表</p><p>一些同学可能想，用数组干啥，都用map不就完事了。</p><p><strong>上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！</strong></p><p>set作为哈希表</p><p>map作为哈希表</p><p>对于哈希表的知识相信很多同学都知道，但是没有成体系。</p><p>本篇我们从哈希表的理论基础到数组、set和map的经典应用，把哈希表的整个全貌完整的呈现给大家。</p><p><strong>同时也强调虽然map是万能的，详细介绍了什么时候用数组，什么时候用set</strong>。</p><p>相信通过这个总结篇，大家可以对哈希表有一个全面的了解。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><p>如果在现场面试中，我们什么时候使用库函数，什么时候不要用库函数呢？</p><p><strong>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</strong></p><p><strong>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</strong></p><p>建议大家平时在leetcode上练习算法的时候本着这样的原则去练习，这样才有助于我们对算法的理解。</p><p>不要沉迷于使用库函数一行代码解决题目之类的技巧，不是说这些技巧不好，而是说这些技巧可以用来娱乐一下。</p><p>因为字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。</p><p>对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;&amp; s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len = s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size()/<span class="number">2</span>; i++)&#123; <span class="comment">// 一开始写的len/2 </span></span><br><span class="line">            ch = s[i];</span><br><span class="line">            s[i] = s[len-i];</span><br><span class="line">            s[len-i] = ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 官方</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;&amp; s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>; i &lt; s.size()/<span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">        swap(s[i],s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>swap可以有两种实现。</p><p>一种就是常见的交换数值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = s[i];</span><br><span class="line">s[i] = s[j];</span><br><span class="line">s[j] = tmp;</span><br></pre></td></tr></table></figure><p>一种就是通过位运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s[i] ^= s[j];</span><br><span class="line">s[j] ^= s[i];</span><br><span class="line">s[i] ^= s[j];</span><br></pre></td></tr></table></figure><p><strong>在字符串相关的题目中，库函数对大家的诱惑力是非常大的，因为会有各种反转，切割取词之类的操作</strong>，这也是为什么字符串的库函数这么丰富的原因。</p><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>其实在遍历字符串的过程中，只要让 i += (2 <em> k)，i 每次移动 2 </em> k 就可以了，然后判断是否需要有反转的区间。</p><p>因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。</p><p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己写了快一个小时，还是写的乱七八糟，过了40 最后看答案去了！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.size()) &#123;</span><br><span class="line">                reverse(s.begin() + i, s.begin() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">                reverse(s.begin() + i, s.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.size()) &#123;</span><br><span class="line">                reverse(s, i, i + k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">            reverse(s, i, s.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n = s.size(),pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n)&#123;</span><br><span class="line">            <span class="comment">//剩余字符串大于等于k的情况</span></span><br><span class="line">            <span class="keyword">if</span>(pos + k &lt; n) reverse(s.begin() + pos, s.begin() + pos + k);</span><br><span class="line">            <span class="comment">//剩余字符串不足k的情况 </span></span><br><span class="line">            <span class="keyword">else</span> reverse(s.begin() + pos,s.end());</span><br><span class="line">            pos += <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>这么做有两个好处：</p><ol><li><p>不用申请新数组。</p></li><li><p>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> oldSize=s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.resize(s.size()+count*<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> newSize=s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=oldSize<span class="number">-1</span>, j=newSize<span class="number">-1</span>; i &lt;j; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/C++中的字符串。</p><p>在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\0’存入数组，并以此作为该字符串是否结束的标志。</p><p>例如这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">5</span>] = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用’\0’来判断是否结束。</p><p>例如这段代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么vector&lt; char &gt; 和 string 又有什么区别呢？</p><p>其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。</p><p>所以想处理字符串，我们还是会定义一个string类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123; <span class="comment">//翻转，区间写法：左闭右闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">removeExtraSpaces</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> &#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.size() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.resize(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">        removeExtraSpaces(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        reverse(s, <span class="number">0</span>, s.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.size() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                reverse(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p>直接看的题解，太巧妙了。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        reverse(s.begin(), s.begin() + n);</span><br><span class="line">        reverse(s.begin() + n, s.end());</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4><p>本题是KMP 经典题目。</p><p>KMP的经典思想就是:<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</strong></p><p>KMP主要应用在字符串匹配上。</p><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><p>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p><p>其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。</p><p>没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。</p><p>不仅面试的时候可能写不出来，如果面试官问：<strong>next数组里的数字表示的是什么，为什么这么表示？</strong></p><p>估计大多数候选人都是懵逼的。</p><p>前缀表</p><p>写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？</p><p>next数组就是一个前缀表（prefix table）。</p><p>前缀表有什么作用呢？</p><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p>为了清楚地了解前缀表的来历，我们来举一个例子：</p><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：</p><p>此时就要问了<strong>前缀表是如何记录的呢？</strong></p><p>首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p><p>那么什么是前缀表：<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><p>最长公共前后缀？</p><p>文章中字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p><p><strong>正确理解什么是前缀什么是后缀很重要</strong>!</p><p>那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？</p><p>我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。</p><p><strong>因为前缀表要求的就是相同前后缀的长度。</strong></p><p>而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。</p><p>所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等…..。</p><p>为什么一定要用前缀表</p><p>字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>；<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。）</p><p>前缀表与next数组</p><p>多KMP算法的时间都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？</p><p>next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。</p><p>为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。</p><p>其实<strong>这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</strong></p><p>后面我会提供两种不同的实现代码，大家就明白了。</p><p>时间复杂度分析</p><p>其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。</p><p>暴力的解法显而易见是O(n × m)，所以<strong>KMP在字符串匹配中极大地提高了搜索的效率。</strong></p><p>为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。</p><p>都知道使用KMP算法，一定要构造next数组。</p><p>构造next数组</p><p>我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 背下来吧，，，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> <span class="built_in">string</span>&amp; s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != s[j])&#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> next[needle.size()];</span><br><span class="line">        getNext(next, needle);</span><br><span class="line">        <span class="type">int</span> j =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;haystack.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i] != needle[j])&#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == needle.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> (i-needle.size()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。</p><p>接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。</p><p>其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。</p><p>然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。</p><p>又给出了直接用前缀表作为next数组，来做匹配的实现代码。</p><p>可以说把KMP的每一个细微的细节都扣了出来，毫无遮掩的展示给大家了</p><h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><p><img src="image/image 11.png" alt="image.png"></p><p>判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。</p><p>当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> t = s + s;</span><br><span class="line">        t.erase(t.begin()); t.erase(t.end() - <span class="number">1</span>); <span class="comment">// 掐头去尾</span></span><br><span class="line">        <span class="keyword">if</span> (t.find(s) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// r</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么会使用KMP</p><p>在一个串中查找是否出现过另一个串，这是KMP的看家本领。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>什么是字符串</p><p>在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\0’存入数组，并以此作为该字符串是否结束的标志。</p><p>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用’\0’来判断是否结束。</p><p>那么vector&lt; char &gt; 和 string 又有什么区别呢？</p><p>其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。</p><p>所以想处理字符串，我们还是会定义一个string类型。</p><h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><h4 id="27-移除元素-1"><a href="#27-移除元素-1" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><h4 id="344-反转字符串-1"><a href="#344-反转字符串-1" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><h4 id="剑指-Offer-05-替换空格-1"><a href="#剑指-Offer-05-替换空格-1" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><h4 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h4><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next; <span class="comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span></span><br><span class="line">        <span class="comment">// slow-&gt;next = tmp-&gt;next;</span></span><br><span class="line">        <span class="comment">// delete nth;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;  <span class="comment">//不加头节点，会出问题！！尤其是空指针！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> &#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            swap (lenA, lenB);</span><br><span class="line">            swap (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ListNode *<span class="title function_">detectCycle</span><span class="params">(ListNode *head)</span> &#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="15-三数之和-1"><a href="#15-三数之和-1" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.push_back(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.size(); k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//剪枝一定要break！！！！</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.push_back(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p><p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p><p>栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p><p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><p>直接抄！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span></span><br><span class="line">        <span class="keyword">if</span> (stOut.empty()) &#123;</span><br><span class="line">            <span class="comment">// 从stIn导入数据直到stIn为空</span></span><br><span class="line">            <span class="keyword">while</span>(!stIn.empty()) &#123;</span><br><span class="line">                stOut.push(stIn.top());</span><br><span class="line">                stIn.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = stOut.top();</span><br><span class="line">        stOut.pop();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> res = this-&gt;pop(); <span class="comment">// 直接使用已有的pop函数</span></span><br><span class="line">        stOut.push(res); <span class="comment">// 因为pop函数弹出了元素res，所以再添加回去</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stIn.empty() &amp;&amp; stOut.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; que2; <span class="comment">// 辅助队列，用来备份</span></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> size = que1.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">            que2.push(que1.front());</span><br><span class="line">            que1.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = que1.front(); <span class="comment">// 留下的最后一个元素就是要返回的值</span></span><br><span class="line">        que1.pop();</span><br><span class="line">        que1 = que2;            <span class="comment">// 再将que2赋值给que1</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.empty()) &#123; <span class="comment">// 清空que2</span></span><br><span class="line">            que2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">////一个队列优化</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> size = que.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">            que.push(que.front());</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que.front(); <span class="comment">// 此时弹出的元素顺序就是栈的顺序了</span></span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s的长度为奇数，一定不符合要求</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.empty() || st.top() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.pop(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.empty() || s != st.top()) &#123;</span><br><span class="line">                st.push(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.pop(); <span class="comment">// s 与 st.top()相等的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123; <span class="comment">// 将栈中元素放到result字符串汇总</span></span><br><span class="line">            result += st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse (result.begin(), result.end()); <span class="comment">// 此时字符串需要反转一下</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当然可以拿字符串直接作为栈，这样省去了栈还要转为字符串的操作。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.empty() || result.back() != s) &#123;</span><br><span class="line">                result.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是<code>Segmentation fault</code>（当然不是所有的<code>Segmentation fault</code> 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。</p><p>而且<strong>在企业项目开发中，尽量不要使用递归</strong>！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong></p><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4><p>看的题解</p><p><strong>栈与递归之间在某种程度上是可以转换的！</strong> 这一点我们在后续讲解二叉树的时候，会更详细的讲解到。</p><p>那么来看一下本题，<strong>其实逆波兰表达式相当于是二叉树中的后序遍历</strong>。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。</p><p>但我们没有必要从二叉树的角度去解决这个问题，只要知道逆波兰表达式是用后序遍历的方式把二叉树序列化了，就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> &#123;</span><br><span class="line">        <span class="comment">// 力扣修改了后台测试数据，需要用longlong</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt; st; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.push(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.push(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.push(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.push(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(stoll(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = st.top();</span><br><span class="line">        st.pop(); <span class="comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么将中缀表达式，转化为后缀表达式之后：[“4”, “13”, “5”, “/“, “+”] ，就不一样了，计算机可以利用栈来顺序处理，不需要考虑优先级了。也不用回退了， <strong>所以后缀表达式对计算机来说是非常友好的。</strong></p><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><p>暴力方法，遍历一遍的过程中每次从窗口中再找到最大的数值，这样很明显是O(n × k)的算法。</p><p>有的同学可能会想用一个大顶堆（优先级队列）来存放这个窗口里的k个数字，这样就可以知道最大的最大值是多少了， <strong>但是问题是这个窗口是移动的，而大顶堆每次只能弹出最大值，我们无法移除其他数值，这样就造成大顶堆维护的不是滑动窗口里面的数值了。所以不能用大顶堆。</strong></p><p>此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p><p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong></p><p>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列</strong></p><p><strong>不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。</strong></p><p>直接题解。。。。。。。。。。。。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span> <span class="comment">//单调队列（从大到小）</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">        <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">        <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">        <span class="type">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.empty() &amp;&amp; value == que.front()) &#123;</span><br><span class="line">                que.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">        <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.empty() &amp;&amp; value &gt; que.back()) &#123;</span><br><span class="line">                que.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            que.push_back(value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">front</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> que.front();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// 先将前k的元素放进队列</span></span><br><span class="line">            que.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(que.front()); <span class="comment">// result 记录前k的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            que.pop(nums[i - k]); <span class="comment">// 滑动窗口移除最前面元素</span></span><br><span class="line">            que.push(nums[i]); <span class="comment">// 滑动窗口前加入最后面的元素</span></span><br><span class="line">            result.push_back(que.front()); <span class="comment">// 记录对应的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4><p>首先统计元素出现的频率，这一类的问题可以使用map来进行统计。</p><p>然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p><p>什么是优先级队列呢？</p><p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p><p>而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p><p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p><p>什么是堆呢？</p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p><p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p><p>为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。</p><p>那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p><p>而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？</p><p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(nlogk)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">mycomparison</span> &#123;</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="type">bool</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 要统计元素出现频率</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="built_in">map</span>; <span class="comment">// map&lt;nums[i],对应出现的次数&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对频率排序</span></span><br><span class="line">        <span class="comment">// 定义一个小顶堆，大小为k</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); it++) &#123;</span><br><span class="line">            pri_que.push(*it);</span><br><span class="line">            <span class="keyword">if</span> (pri_que.size() &gt; k) &#123; <span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">                pri_que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">result</span><span class="params">(k)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = pri_que.top().first;</span><br><span class="line">            pri_que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>拓展</strong></p><p>大家对这个比较运算在建堆时是如何应用的，为什么左大于右就会建立小顶堆，反而建立大顶堆比较困惑。</p><p>确实 例如我们在写快排的cmp函数的时候，<code>return left&gt;right</code> 就是从大到小，<code>return left&lt;right</code> 就是从小到大。</p><p>优先级队列的定义正好反过来了，可能和优先级队列的源码实现有关（我没有仔细研究），我估计是底层实现上优先队列队首指向后面，队尾指向最前面的缘故！</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ol><li><p>C++中stack，queue 是容器么？</p></li><li><p>我们使用的stack，queue是属于那个版本的STL？</p></li><li><p>我们使用的STL中stack，queue是如何实现的？</p></li><li><p>stack，queue 提供迭代器来遍历空间么？</p></li></ol><p>相信不仅仅是C++中有这些问题，那么大家使用其他编程语言，也可以考虑一下这四个问题，栈和队列是如何实现的。</p><p>栈与队列是我们熟悉的不能再熟悉的数据结构，但它们的底层实现，很多同学都比较模糊，这其实就是基础所在。</p><p>可以出一道面试题：栈里面的元素在内存中是连续分布的么？</p><p>这个问题有两个陷阱：</p><ul><li><p>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。</p></li><li><p>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。</p></li></ul><p>所以这就是考察候选者基础知识扎不扎实的好问题。</p><p>大家还是要多多重视起来！</p><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</strong></p><hr><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的种类</p><p>有两种主要的形式：满二叉树和完全二叉树</p><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p>这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。</p><p><img src="image/image 12.png" alt="image.png"></p><p>完全二叉树</p><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1) 个节点。</p><p><img src="image/image 13.png" alt="image.png"></p><p><strong>之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p><p>二叉搜索树</p><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li><p>它的左、右子树也分别为二叉排序树</p></li></ul><p><img src="image/image 14.png" alt="image.png"></p><p>平衡二叉搜索树</p><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><img src="image/image 15.png" alt="image.png"></p><p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p><p><strong>所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！</strong></p><p>二叉树的存储方式</p><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p><img src="image/image 16.png" alt="image.png"></p><p><img src="image/image 17.png" alt="image.png"></p><p>用数组来存储二叉树如何遍历的呢？</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i <em> 2 + 1，右孩子就是 i </em> 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p><p>二叉树的遍历方式</p><p>二叉树主要有两种遍历方式：</p><ol><li><p>深度优先遍历：先往深走，遇到叶子节点再往回走。</p></li><li><p>广度优先遍历：一层一层的去遍历。</p></li></ol><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候 还会介绍到。</p><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li><p>深度优先遍历</p><ul><li><p>前序遍历（递归法，迭代法）</p></li><li><p>中序遍历（递归法，迭代法）</p></li><li><p>后序遍历（递归法，迭代法）</p></li></ul></li><li><p>广度优先遍历</p><ul><li>层次遍历（迭代法）</li></ul></li></ul><p>在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。</p><p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li><p>前序遍历：中左右</p></li><li><p>中序遍历：左中右</p></li><li><p>后序遍历：左右中</p></li></ul><p><img src="image/image 18.png" alt="image.png"></p><p>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p><p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><p><strong>这里其实我们又了解了栈与队列的一个应用场景了。</strong></p><p>具体的实现我们后面都会讲的，这里大家先要清楚这些理论基础。</p><p>二叉树的定义</p><p>刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left;</span><br><span class="line">  TreeNode *right;</span><br><span class="line">  TreeNode(<span class="type">int</span> x): val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里要提醒大家要注意二叉树节点定义的书写方式。</p><p><strong>在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。</strong></p><p>总结</p><p>二叉树是一种基础数据结构，在算法面试中都是常客，也是众多数据结构的基石。</p><p>本篇我们介绍了二叉树的种类、存储方式、遍历方式以及定义，比较全面的介绍了二叉树各个方面的重点，帮助大家扫一遍基础。</p><p><strong>说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。</strong></p><h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h4><p>递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li><p><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><p><strong>前序遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; vec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; vec)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; vec)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.push_back(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h4><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><h4 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h4><h4 id="二叉树层序遍历登场"><a href="#二叉树层序遍历登场" class="headerlink" title="二叉树层序遍历登场"></a>二叉树层序遍历登场</h4><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) que.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="type">int</span> size = que.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                tmp.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><p>针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。</p><p><strong>二叉树解题的大忌就是自己稀里糊涂的过了（因为这道题相对简单），但是也不知道自己是怎么遍历的。</strong></p><p>这也是造成了二叉树的题目“一看就会，一写就废”的原因。</p><p><strong>针对翻转二叉树，我给出了一种递归，三种迭代（两种模拟深度优先遍历，一种层序遍历）的写法，都是之前我们讲过的写法，融汇贯通一下而已。</strong></p><p>大家一定也有自己的解法，但一定要成方法论，这样才能通用，才能举一反三！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">invertTree</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);  <span class="comment">// 中</span></span><br><span class="line">        invertTree(root-&gt;left);         <span class="comment">// 左</span></span><br><span class="line">        invertTree(root-&gt;right);        <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="type">bool</span> outside = compare(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="type">bool</span> inside = compare(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><p><strong>而根节点的高度就是二叉树的最大深度</strong>，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getdepth</span><span class="params">(treenode* node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = getdepth(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = getdepth(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + max(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxdepth</span><span class="params">(treenode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getdepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftDepth = getDepth(node-&gt;left);           <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightDepth = getDepth(node-&gt;right);         <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + min(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getNodesNum</span><span class="params">(TreeNode* cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftNum = getNodesNum(cur-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightNum = getNodesNum(cur-&gt;right);    <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> treeNum = leftNum + rightNum + <span class="number">1</span>;      <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> treeNum;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNodesNum(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><p>此时大家应该明白了既然要求比较高度，必然是要后序遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftHeight = getHeight(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rightHeight = getHeight(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span> + max(leftHeight, rightHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode* cur, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result)</span> &#123;</span><br><span class="line">        path.push_back(cur-&gt;val); <span class="comment">// 中，中为什么写在这里，因为最后一个节点也要加入到path中 </span></span><br><span class="line">        <span class="comment">// 这才到了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> sPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sPath += to_string(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += to_string(path[path.size() - <span class="number">1</span>]);</span><br><span class="line">            result.push_back(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左 </span></span><br><span class="line">            traversal(cur-&gt;left, path, result);</span><br><span class="line">            path.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            traversal(cur-&gt;right, path, result);</span><br><span class="line">            path.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        traversal(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><p>此时就要通过节点的父节点来判断其左孩子是不是左叶子了。</p><p><strong>平时我们解二叉树的题目时，已经习惯了通过节点的左右孩子判断本节点的属性，而本题我们要通过节点的父节点判断本节点的属性。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = sumOfLeftLeaves(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// 左子树就是一个左叶子的情况</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue = sumOfLeftLeaves(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = leftValue + rightValue;               <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            traversal(root-&gt;left, depth);</span><br><span class="line">            depth--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            traversal(root-&gt;right, depth);</span><br><span class="line">            depth--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        traversal(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">find</span><span class="params">(TreeNode* node, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; val==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">            val -= node-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(find(node-&gt;left, val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            val += node-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">            val -= node-&gt;right-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(find(node-&gt;right, val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            val += node-&gt;right-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> find(root, targetSum- root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="comment">// 递归函数不需要返回值，因为我们要遍历整个树</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">traversal</span><span class="params">(treenode* cur, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) &#123; <span class="comment">// 遇到了叶子节点且找到了和为sum的路径</span></span><br><span class="line">            result.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> ; <span class="comment">// 遇到叶子节点而没有找到合适的边，直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左 （空节点不遍历）</span></span><br><span class="line">            path.push_back(cur-&gt;left-&gt;val);</span><br><span class="line">            count -= cur-&gt;left-&gt;val;</span><br><span class="line">            traversal(cur-&gt;left, count);    <span class="comment">// 递归</span></span><br><span class="line">            count += cur-&gt;left-&gt;val;        <span class="comment">// 回溯</span></span><br><span class="line">            path.pop_back();                <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右 （空节点不遍历）</span></span><br><span class="line">            path.push_back(cur-&gt;right-&gt;val);</span><br><span class="line">            count -= cur-&gt;right-&gt;val;</span><br><span class="line">            traversal(cur-&gt;right, count);   <span class="comment">// 递归</span></span><br><span class="line">            count += cur-&gt;right-&gt;val;       <span class="comment">// 回溯</span></span><br><span class="line">            path.pop_back();                <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; pathsum(treenode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> result;</span><br><span class="line">        path.push_back(root-&gt;val); <span class="comment">// 把根节点放进路径</span></span><br><span class="line">        traversal(root, sum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    TreeNode* <span class="title function_">traversal</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">        <span class="type">int</span> rootValue = postorder[postorder.size() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = new TreeNode(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (postorder.size() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line">        <span class="type">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.size(); delimiterIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割中序数组</span></span><br><span class="line">        <span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">leftInorder</span><span class="params">(inorder.begin(), inorder.begin() + delimiterIndex)</span>;</span><br><span class="line">        <span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">rightInorder</span><span class="params">(inorder.begin() + delimiterIndex + <span class="number">1</span>, inorder.end() )</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// postorder 舍弃末尾元素</span></span><br><span class="line">        postorder.resize(postorder.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割后序数组</span></span><br><span class="line">        <span class="comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span></span><br><span class="line">        <span class="comment">// [0, leftInorder.size)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">leftPostorder</span><span class="params">(postorder.begin(), postorder.begin() + leftInorder.size())</span>;</span><br><span class="line">        <span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">rightPostorder</span><span class="params">(postorder.begin() + leftInorder.size(), postorder.end())</span>;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = traversal(leftInorder, leftPostorder);</span><br><span class="line">        root-&gt;right = traversal(rightInorder, rightPostorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.size() == <span class="number">0</span> || postorder.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> traversal(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">trans</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; preorder,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; inorder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> rootValue=preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode* root=new TreeNode(rootValue);</span><br><span class="line">        <span class="keyword">if</span>(preorder.size()==<span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">        <span class="keyword">for</span>(d=<span class="number">0</span>; d&lt;inorder.size(); d++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[d]==rootValue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">leftInorder</span><span class="params">(inorder.begin(), inorder.begin()+d)</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">rightInorder</span><span class="params">(inorder.begin()+d+<span class="number">1</span>, inorder.end())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">Preorder</span><span class="params">(preorder.begin()+<span class="number">1</span>, preorder.end())</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">leftPreorder</span><span class="params">(Preorder.begin(), Preorder.begin()+leftInorder.size())</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">rightPreorder</span><span class="params">(Preorder.begin()+leftInorder.size(), Preorder.end())</span>;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = trans(leftPreorder, leftInorder);</span><br><span class="line">        root-&gt;right= trans(rightPreorder, rightInorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.size()==<span class="number">0</span> || inorder.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> trans(preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前序和中序可以唯一确定一棵二叉树。</p><p>后序和中序可以唯一确定一棵二叉树。</p><p>那么前序和后序可不可以唯一确定一棵二叉树呢？</p><p><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。</p><h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">// 在左闭右开区间[left, right)，构造二叉树</span></span><br><span class="line">    TreeNode* <span class="title function_">traversal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割点下标：maxValueIndex</span></span><br><span class="line">        <span class="type">int</span> maxValueIndex = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = new TreeNode(nums[maxValueIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左闭右开：[left, maxValueIndex)</span></span><br><span class="line">        root-&gt;left = traversal(nums, left, maxValueIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左闭右开：[maxValueIndex + 1, right)</span></span><br><span class="line">        root-&gt;right = traversal(nums, maxValueIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> traversal(nums, <span class="number">0</span>, nums.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。</strong></p><p>一些同学也会疑惑，什么时候递归函数前面加if，什么时候不加if，这个问题我在最后也给出了解释。</p><p>其实就是不同代码风格的实现，<strong>一般情况来说：如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整。</strong></p><h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><p>自己没写对。。。 最后还是题解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br><span class="line">        <span class="comment">// 修改了t1的数值和结构</span></span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             <span class="comment">// 中</span></span><br><span class="line">        t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* result = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) result = searchBST(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) result = searchBST(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p><p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p><p><strong>注意二叉搜索树中不能有重复元素</strong>。</p><ul><li>陷阱1</li></ul><p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。</p><p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong>。所以以上代码的判断逻辑是错误的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        traversal(root-&gt;left);</span><br><span class="line">        vec.push_back(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">        traversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        vec.clear(); <span class="comment">// 不加这句在leetcode上也可以过，但最好加上</span></span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p><p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p><p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。</p><p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p><p><strong>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</strong></p><p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    traversal(root-&gt;left);</span><br><span class="line">    vec.push_back(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    traversal(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        vec.clear();</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">if</span> (vec.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.size(); i++) &#123; <span class="comment">// 统计有序数组的最小差值</span></span><br><span class="line">            result = min(result, vec[i] - vec[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4><p>好难搞。。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">searchBST</span><span class="params">(TreeNode* cur, <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; <span class="built_in">map</span>)</span> &#123; <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">map</span>[cur-&gt;val]++; <span class="comment">// 统计元素频率</span></span><br><span class="line">    searchBST(cur-&gt;left, <span class="built_in">map</span>);</span><br><span class="line">    searchBST(cur-&gt;right, <span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="type">static</span> <span class="title function_">cmp</span> <span class="params">(<span class="type">const</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">findMode</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="built_in">map</span>; <span class="comment">// key:元素，value:出现频率</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        searchBST(root, <span class="built_in">map</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; vec(<span class="built_in">map</span>.begin(), <span class="built_in">map</span>.end());</span><br><span class="line">        sort(vec.begin(), vec.end(), cmp); <span class="comment">// 给频率排个序</span></span><br><span class="line">        result.push_back(vec[<span class="number">0</span>].first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 取最高的放到result数组中</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i].second == vec[<span class="number">0</span>].second) result.push_back(vec[i].first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>所以如果本题没有说是二叉搜索树的话，那么就按照上面的思路写！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">0</span>; <span class="comment">// 最大频率</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计频率</span></span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">searchBST</span><span class="params">(TreeNode* cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        searchBST(cur-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">                                    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur; <span class="comment">// 更新上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">            result.push_back(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值频率</span></span><br><span class="line">            maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">            result.clear();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">            result.push_back(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        searchBST(cur-&gt;right);      <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">findMode</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        result.clear();</span><br><span class="line"></span><br><span class="line">        searchBST(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>接下来就看如何判断一个节点是节点q和节点p的公共祖先呢。</p><p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong> 即情况一：</p><p>题目强调：<strong>二叉树节点数值是不重复的，而且一定存在 q 和 p</strong>。</p><p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong> 情况二：</p><p>不会。。。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == q || root == p || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>  &#123; <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>那么我给大家归纳如下三点</strong>：</p><ol><li><p>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过<strong>后序</strong>遍历（即：回溯）实现从底向上的遍历方式。</p></li><li><p>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</p></li><li><p>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</p></li></ol><p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p><p>本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。</p><h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    TreeNode* <span class="title function_">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> cur;</span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;   <span class="comment">// 左</span></span><br><span class="line">            TreeNode* left = traversal(cur-&gt;left, p, q);</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) &#123;   <span class="comment">// 右</span></span><br><span class="line">            TreeNode* right = traversal(cur-&gt;right, p, q);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> traversal(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><p><strong>到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = new TreeNode(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><p>还是得看题解，情况想不出来。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr) <span class="keyword">return</span> root; <span class="comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                delete root;</span><br><span class="line">                <span class="keyword">return</span> nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == nullptr) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;right;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                delete root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == nullptr) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;left;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                delete root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">            <span class="comment">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right; <span class="comment">// 找右子树最左面的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;left != nullptr) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur-&gt;left = root-&gt;left; <span class="comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">                TreeNode* tmp = root;   <span class="comment">// 把root节点保存一下，下面来删除</span></span><br><span class="line">                root = root-&gt;right;     <span class="comment">// 返回旧root的右孩子作为新root</span></span><br><span class="line">                delete tmp;             <span class="comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>普通二叉树的删除方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == nullptr) &#123; <span class="comment">// 这里第二次操作目标值：最终删除的作用</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *cur = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(root-&gt;val, cur-&gt;val); <span class="comment">// 这里第一次操作目标值：交换目标值其右子树最左面节点。</span></span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。</p><p><strong>因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整</strong>。</p><p>这里我们依然使用递归函数的返回值来完成把节点从二叉树中移除的操作。</p><p><strong>这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚</strong>。</p><p>而且就算想清楚了，对应的代码也未必可以写出来，所以<strong>这道题目既考察思维逻辑，也考察代码能力</strong>。</p><h4 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h4><p>看题解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr ) <span class="keyword">return</span> nullptr;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low) &#123;</span><br><span class="line">            TreeNode* right = trimBST(root-&gt;right, low, high); <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; high) &#123;</span><br><span class="line">            TreeNode* left = trimBST(root-&gt;left, low, high); <span class="comment">// 寻找符合区间[low, high]的节点</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, low, high); <span class="comment">// root-&gt;left接入符合条件的左孩子</span></span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, low, high); <span class="comment">// root-&gt;right接入符合条件的右孩子</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    TreeNode* <span class="title function_">traversal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> nullptr;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        TreeNode* root = new TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = traversal(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = traversal(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        TreeNode* root = traversal(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode* cur)</span> &#123; <span class="comment">// 右中左遍历</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        traversal(cur-&gt;right);</span><br><span class="line">        cur-&gt;val += pre;</span><br><span class="line">        pre = cur-&gt;val;</span><br><span class="line">        traversal(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* <span class="title function_">convertBST</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><h5 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h5><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p><p>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p><p>记住组合无序，排列有序，就可以了。</p><h5 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h5><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><p>这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。</p><h5 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h5><p>回溯三部曲</p><ul><li><p>回溯函数模板返回值以及参数</p><ul><li><p>回溯算法中函数返回值一般为void。</p></li><li><p>```<br>void backtracking(参数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 回溯函数终止条件</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>回溯搜索的遍历过程</p><ul><li><p>```text<br>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</p><pre><code>处理节点;backtracking(路径，选择列表); // 递归回溯，撤销处理结果</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">模板：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>void backtracking(参数) {<br>if (终止条件) {</p><pre><code>存放结果;return;</code></pre><p>}</p><p>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</p><pre><code>处理节点;backtracking(路径，选择列表); // 递归回溯，撤销处理结果</code></pre><p>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 组合问题</span><br><span class="line"></span><br><span class="line">##### [77. 组合](https://leetcode.cn/problems/combinations/)</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backtracking(int n, int k, int starIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        if(path.size()==k)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=starIndex; i&lt;=n ;i++) //优化 i&lt;=n-(k-path.size())+1</span><br><span class="line">        &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            backtracking(n, k, i+1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtracking(n, k, 1);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtraking</span><span class="params">( <span class="type">int</span> k, <span class="type">int</span> targetSum, <span class="type">int</span> sum, <span class="type">int</span> starIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; targetSum) &#123; </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum == sum)</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=starIndex; i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtraking</span>(k, targetSum, sum, i+<span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtraking</span>(k, n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p>这么说有点抽象，来举一个例子：</p><p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p><p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p><p>再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。</p><p>什么时候用贪心</p><p><strong>说实话贪心算法并没有固定的套路</strong>。</p><p>所以唯一的难点就是如何通过局部最优，推出整体最优。</p><p>那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？</p><p><strong>不好意思，也没有！</strong> 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p><p>有同学问了如何验证可不可以用贪心算法呢？</p><p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p><p>可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。</p><p>一般数学证明有如下两种方法：</p><ul><li>数学归纳法</li><li>反证法</li></ul><p>看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。</p><p><strong>面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了</strong>。</p><p>举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。</p><p>虽然这个例子很极端，但可以表达这么个意思：<strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p><p><strong>例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！</strong></p><p>所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，<strong>因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！</strong></p><p>贪心一般解题步骤</p><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。</p><p>做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p><h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干数组的下标</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 遍历胃口 </span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123; <span class="comment">// 遍历饼干 </span></span><br><span class="line">                result++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h4><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p><p>所以贪心解决不了动态规划的问题。</p><p><strong>其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了</strong>。</p><p>而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。</p><p>大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p><p>上述提到的背包问题，后序会详细讲解。</p><h5 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h5><p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。</p><p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中</strong>。</p><p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？</p><p><strong>因为一些情况是递推公式决定了dp数组要如何初始化！</strong></p><p>后面的讲解中我都是围绕着这五点来进行讲解。</p><p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p><p>其实 确定递推公式 仅仅是解题里的一步而已！</p><p>一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p><p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p><h5 id="动态规划应该如何debug"><a href="#动态规划应该如何debug" class="headerlink" title="动态规划应该如何debug"></a>动态规划应该如何debug</h5><p>相信动规的题目，很大部分同学都是这样做的。</p><p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。</p><p>写动规题目，代码出问题很正常！</p><p><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p><p>这是一个很不好的习惯！</p><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p><p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p><p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了</strong>。</p><p>这也是我为什么在动规五步曲里强调推导dp数组的重要性。</p><p>发出这样的问题之前，其实可以自己先思考这三个问题：</p><ul><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ul><p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。</p><p>然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。</p><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何debug。</p><p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p><p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的01背包，leetcode上的题目都是01背包的应用，而没有纯01背包的问题，那么就需要在把对应的理论知识讲解一下。</p><p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p><p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。</p><h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h4><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p><ol><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0] = 0;</span><br><span class="line">dp[1] = 1;</span><br></pre></td></tr></table></figure><ol><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">2</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fib</span>(N - <span class="number">1</span>) + <span class="built_in">fib</span>(N - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><p>我们来分析一下，动规五部曲：</p><p>定义一个一维数组来记录不同楼层的状态</p><p>1 确定dp数组以及下标的含义</p><p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p><p>2 确定递推公式</p><p>如何可以推出dp[i]呢？</p><p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p><p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p><p>所以dp[i] = dp[i - 1] + dp[i - 2] 。</p><p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</p><p>这体现出确定dp数组以及下标的含义的重要性！</p><p>3 dp数组如何初始化</p><p>在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。</p><p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但基本都是直接奔着答案去解释的。</p><p>例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。</p><p>但总有点牵强的成分。</p><p>那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.</p><p><strong>其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1</strong>。</p><p>从dp数组定义的角度上来说，dp[0] = 0 也能说得通。</p><p>需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。</p><p>所以本题其实就不应该讨论dp[0]的初始化！</p><p>我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。</p><p>所以我的原则是：不考虑dp[0]如何初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。</p><p>4 确定遍历顺序</p><p>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p><p>5 举例推导dp数组</p><p>举例当n为5的时候，dp table（dp数组）应该是这样的</p><p>1 2 3 5 8</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一  空间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n; <span class="comment">// 因为下面直接对dp[2]操作了，防止空指针</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">// 注意i是从3开始的</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">1</span>] + dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.programmercarl.com/">代码随想录</a></p></blockquote><p>  <a href="https://interviewguide.cn/">阿秀的学习笔记</a></p><p>快排</p><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, j), quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
