<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用命令</title>
      <link href="/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it hexo /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 使用</title>
      <link href="/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Docker/"/>
      <url>/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/Docker/</url>
      
        <content type="html"><![CDATA[<p><strong>Docker</strong> 包括三个基本概念</p><ul><li><strong>镜像</strong>（<code>Image</code>）</li><li><strong>容器</strong>（<code>Container</code>）</li><li><strong>仓库</strong>（<code>Repository</code>）</li></ul><blockquote><p>参考：<a href="https://yeasy.gitbook.io/docker_practice/basic_concept">https://yeasy.gitbook.io/docker_practice/basic_concept</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog 入门</title>
      <link href="/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><blockquote><p><a href="https://blog.csdn.net/qq_39196431/article/details/123797279">https://blog.csdn.net/qq_39196431/article/details/123797279</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get update -y</span><br><span class="line">apt-get upgrade -y</span><br><span class="line"></span><br><span class="line">apt install git</span><br></pre></td></tr></table></figure><h4 id="ubuntu-解决tab无法自动补全"><a href="#ubuntu-解决tab无法自动补全" class="headerlink" title="ubuntu 解决tab无法自动补全"></a>ubuntu 解决tab无法自动补全</h4><blockquote><p><a href="https://blog.csdn.net/u012849539/article/details/119965164">https://blog.csdn.net/u012849539/article/details/119965164</a></p></blockquote><h4 id="docker进入容器命令"><a href="#docker进入容器命令" class="headerlink" title="docker进入容器命令"></a>docker进入容器命令</h4><blockquote><p><a href="https://blog.csdn.net/m0_67393827/article/details/124174418">https://blog.csdn.net/m0_67393827/article/details/124174418</a></p></blockquote><h4 id="linux环境安装nvm"><a href="#linux环境安装nvm" class="headerlink" title="linux环境安装nvm"></a>linux环境安装nvm</h4><blockquote><p><a href="http://www.manongjc.com/detail/29-fwamcbugdjljgip.html">http://www.manongjc.com/detail/29-fwamcbugdjljgip.html</a></p><p>nvm使用<br><a href="https://blog.csdn.net/qq285744011/article/details/120779124">https://blog.csdn.net/qq285744011/article/details/120779124</a><br><a href="https://blog.csdn.net/zjjcchina/article/details/122298335">https://blog.csdn.net/zjjcchina/article/details/122298335</a></p></blockquote><h4 id="linux生成ssh"><a href="#linux生成ssh" class="headerlink" title="linux生成ssh"></a>linux生成ssh</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;571xxx303@qq.com&quot;</span><br></pre></td></tr></table></figure><h4 id="Git问题：解决“ssh-connect-to-host-github-com-port-22-Connection-timed-out”"><a href="#Git问题：解决“ssh-connect-to-host-github-com-port-22-Connection-timed-out”" class="headerlink" title="Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”"></a>Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</h4><blockquote><p><a href="https://blog.csdn.net/weixin_41287260/article/details/124368189">https://blog.csdn.net/weixin_41287260/article/details/124368189</a>   方法2</p></blockquote><h4 id="Git问题：gnutls-handshake-failed-The-TLS-connection-was-non-properly-terminated-错误解决"><a href="#Git问题：gnutls-handshake-failed-The-TLS-connection-was-non-properly-terminated-错误解决" class="headerlink" title="Git问题：gnutls_handshake() failed: The TLS connection was non-properly terminated. 错误解决"></a>Git问题：gnutls_handshake() failed: The TLS connection was non-properly terminated. 错误解决</h4><blockquote><p><a href="https://blog.csdn.net/u013895878/article/details/123724019">https://blog.csdn.net/u013895878/article/details/123724019</a></p></blockquote><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装Hexo</span><br><span class="line">npm install -g hexo</span><br><span class="line">hexo init # 初始化hexo</span><br><span class="line">hexo g #生成</span><br><span class="line">hexo s #启动服务</span><br></pre></td></tr></table></figure><h4 id="ubuntu换清华源"><a href="#ubuntu换清华源" class="headerlink" title="ubuntu换清华源"></a>ubuntu换清华源</h4><blockquote><p><a href="https://blog.csdn.net/kp19373771/article/details/115983815">https://blog.csdn.net/kp19373771/article/details/115983815</a></p></blockquote><h4 id="docker-使用-（不可行）"><a href="#docker-使用-（不可行）" class="headerlink" title="docker 使用 （不可行）"></a>docker 使用 （不可行）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a &quot;mcy&quot; -m &quot;hexo&quot; f84a3936482a hexo:v0</span><br><span class="line">docker exec -it 44fc0f0582d9 /bin/bash</span><br><span class="line">docker run --name hexo -p 4000:4000 hexo:v0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=666 -v D:/blogs:/blog --net=host  hexo:v0</span><br></pre></td></tr></table></figure><h4 id="docker-使用-（可行）"><a href="#docker-使用-（可行）" class="headerlink" title="docker 使用 （可行）"></a>docker 使用 （可行）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name hexo -p 4000:4000  -v D:/blogs:/blog  ubuntu:18.04</span><br><span class="line">docker exec -it hexo /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>安装git </p><p><a href="https://blog.csdn.net/qq_39196431/article/details/123797279">https://blog.csdn.net/qq_39196431/article/details/123797279</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apt-get update -y</span><br><span class="line">apt-get upgrade -y</span><br><span class="line"></span><br><span class="line">apt install git</span><br><span class="line">apt install vim</span><br><span class="line"></span><br><span class="line">vim /etc/bash.bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo 自动部署</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">butterfly主题</span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装本地搜索插件</span></span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装置顶插件</span></span><br><span class="line">npm install hexo-generator-index --save</span><br></pre></td></tr></table></figure><h4 id="docker-容器备份"><a href="#docker-容器备份" class="headerlink" title="docker 容器备份"></a>docker 容器备份</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">docker commit  -p 57b11527a2d4 hexo_backup</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://wenku.baidu.com/view/0283acc31ae8b8f67c1cfad6195f312b3169eb7c.html">https://wenku.baidu.com/view/0283acc31ae8b8f67c1cfad6195f312b3169eb7c.html</a></p></blockquote><h4 id="butterfly主题配置"><a href="#butterfly主题配置" class="headerlink" title="butterfly主题配置"></a>butterfly主题配置</h4><blockquote><p><a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言</title>
      <link href="/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/go/"/>
      <url>/2022/06/20/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/go/</url>
      
        <content type="html"><![CDATA[<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><hr><blockquote><p>参考教程：<a href="https://tour.go-zh.org/welcome/1">https://tour.go-zh.org/welcome/1</a></p></blockquote><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h2><h3 id="1-1-包、变量和函数"><a href="#1-1-包、变量和函数" class="headerlink" title="1.1 包、变量和函数"></a>1.1 包、变量和函数</h3><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h4><p>就类似于c中的常量（固定不变），名字以大写字母开头，那么它就是<strong>已导出的</strong>。“未导出”的名字在该包外均无法访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(math.pi)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上述代码输出错误。应该改为<code>math.Pi</code></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数可以没有参数或接受多个参数。类型在变量名 <strong>之后</strong>。(<a href="https://blog.go-zh.org/gos-declaration-syntax">为何和c家族不一样！</a>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h4><p>函数可以返回任意数量的返回值。<code>swap</code> 函数返回了两个字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := swap(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world hello</span><br></pre></td></tr></table></figure><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p><p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p><p>没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 <code>直接</code> 返回。</p><p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。</p><p>就像在这个例子中看到的一样，<code>var</code> 语句可以出现在包或函数级别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 false false false</span><br></pre></td></tr></table></figure><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>变量声明可以包含初始值，每个变量对应一个。</p><p>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line">fmt.Println(i, j, c, python, java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 true false no!</span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p><p><strong>函数外</strong>的每个语句都必须以<strong>关键字</strong>开始（<code>var</code>, <code>func</code> 等等），因此 <code>:=</code> 结构<strong>不能</strong>在函数外使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">k := <span class="number">3</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(i, j, k, c, python, java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>Go 的基本类型有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line"></span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">int  int8  int16  int32  int64</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">byte // uint8 的别名</span><br><span class="line"></span><br><span class="line">rune // int32 的别名</span><br><span class="line">    // 表示一个 Unicode 码点</span><br><span class="line"></span><br><span class="line">float32 float64</span><br><span class="line"></span><br><span class="line">complex64 complex128</span><br></pre></td></tr></table></figure><p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/cmplx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ToBe   <span class="type">bool</span>       = <span class="literal">false</span></span><br><span class="line">MaxInt <span class="type">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">z      <span class="type">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, ToBe, ToBe)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, MaxInt, MaxInt)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, z, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type: bool Value: false</span><br><span class="line">Type: uint64 Value: 18446744073709551615</span><br><span class="line">Type: complex128 Value: (2+3i)</span><br></pre></td></tr></table></figure><h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h4><p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p><p>零值是：</p><ul><li>数值类型为 <code>0</code>，</li><li>布尔类型为 <code>false</code>，</li><li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %v %v %q\n&quot;</span>, i, f, b, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 false &quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p><p>一些关于数值的转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure><p>或者，更加简单的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="type">float64</span>(i)</span><br><span class="line">u := <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure><p>与 C 不同的是，Go 在不同类型的项之间赋值时<strong>需要显式转换</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = math.Sqrt(<span class="type">float64</span>(x*x + y*y))</span><br><span class="line"><span class="keyword">var</span> z <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br><span class="line">fmt.Println(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p><p>当右值声明了类型时，新变量的类型与其相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line">j := i // j 也是一个 int</span><br></pre></td></tr></table></figure><p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := 42           // int</span><br><span class="line">f := 3.142        // float64</span><br><span class="line">g := 0.867 + 0.5i // complex128</span><br></pre></td></tr></table></figure><p>尝试修改示例代码中 <code>v</code> 的初始值，并观察它是如何影响类型的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := <span class="number">42</span> <span class="comment">// 修改这里！</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;v is of type %T\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v is of type int</span><br></pre></td></tr></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p><p>常量可以是字符、字符串、布尔值或数值。</p><p>常量不能用 <code>:=</code> 语法声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)</span><br><span class="line">fmt.Println(<span class="string">&quot;Happy&quot;</span>, Pi, <span class="string">&quot;Day&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, Truth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello 世界</span><br><span class="line">Happy 3.14 Day</span><br><span class="line">Go rules? true</span><br></pre></td></tr></table></figure><h4 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h4><p>数值常量是高精度的 <strong>值</strong>。</p><p>一个未指定类型的常量由上下文来决定其类型。</p><p>再尝试一下输出 <code>needInt(Big)</code> 吧。</p><p>（<code>int</code> 类型最大可以存储一个 64 位的整数，有时会更小。）</p><p>（<code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class="line"><span class="comment">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class="line">Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"><span class="comment">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class="line">Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(needInt(Small))</span><br><span class="line">fmt.Println(needFloat(Small))</span><br><span class="line">fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">21</span><br><span class="line">0.2</span><br><span class="line">1.2676506002282295e+29</span><br></pre></td></tr></table></figure><h3 id="1-2-流程控制语句"><a href="#1-2-流程控制语句" class="headerlink" title="1.2 流程控制语句"></a>1.2 流程控制语句</h3><p>for、if、else、switch、defer</p><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>Go 只有一种循环结构：<code>for</code> 循环。</p><p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p><ul><li>初始化语句：在第一次迭代前执行</li><li>条件表达式：在每次迭代前求值</li><li>后置语句：在每次迭代的结尾执行</li></ul><p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p><p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p><p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化语句和后置语句是可选的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1024</span></span><br></pre></td></tr></table></figure><h4 id="for-是-Go-中的-“while”"><a href="#for-是-Go-中的-“while”" class="headerlink" title="for 是 Go 中的 “while”"></a>for 是 Go 中的 “while”</h4><p>此时你可以去掉分号，因为 C 的 <code>while</code> 在 Go 中叫做 <code>for</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1024</span></span><br></pre></td></tr></table></figure><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.4142135623730951 2i</span></span><br></pre></td></tr></table></figure><h4 id="if-的简短语句"><a href="#if-的简短语句" class="headerlink" title="if 的简短语句"></a>if 的简短语句</h4><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p><p>该语句声明的变量作用域仅在 <code>if</code> 之内。</p><p>（在最后的 <code>return</code> 语句处使用 <code>v</code> 看看。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9 20</span></span><br></pre></td></tr></table></figure><h4 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if 和 else"></a>if 和 else</h4><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p><p>（在 <code>main</code> 的 <code>fmt.Println</code> 调用开始前，两次对 <code>pow</code> 的调用均已执行并返回其各自的结果。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%g &gt;= %g\n&quot;</span>, v, lim)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里开始就不能使用 v 了</span></span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 27 &gt;= 20</span></span><br><span class="line"><span class="comment">// 9 20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="练习：循环与函数"><a href="#练习：循环与函数" class="headerlink" title="练习：循环与函数"></a>练习：循环与函数</h4><p>为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。</p><p>计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z -= (z*z - x) / (2*z)</span><br></pre></td></tr></table></figure><p>重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。</p><p>在提供的 <code>func Sqrt</code> 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。 要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 …）， 你得到的答案是如何逼近结果的，猜测提升的速度有多快。</p><p>提示：用类型转换或浮点数语法来声明并初始化一个浮点数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z := 1.0</span><br><span class="line">z := float64(1)</span><br></pre></td></tr></table></figure><p>然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。 尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 <a href="https://go-zh.org/pkg/math/#Sqrt">math.Sqrt</a> 接近吗？</p><p>（<em>注：</em> 如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离， 除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。 这种通用方法叫做<a href="https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿法</a>。 它对很多函数，特别是平方根而言非常有效。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">z := <span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> math.Abs(z*z-x) &gt; <span class="number">1e-10</span> &#123;</span><br><span class="line">z -= (z*z - x) / (<span class="number">2</span> * z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;牛顿法求平方根:Sqrt(10) = &quot;</span>, Sqrt(<span class="number">10</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;库函数求平方根:Sqrt(10) = &quot;</span>, math.Sqrt(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//牛顿法求平方根:Sqrt(10) =  3.1622776601683795</span></span><br><span class="line"><span class="comment">//库函数求平方根:Sqrt(10) =  3.1622776601683795</span></span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p><p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Go runs on Linux.</span></span><br></pre></td></tr></table></figure><h4 id="switch-的求值顺序"><a href="#switch-的求值顺序" class="headerlink" title="switch 的求值顺序"></a>switch 的求值顺序</h4><p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p><p>（例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch i &#123;</span><br><span class="line">case 0:</span><br><span class="line">case f():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>i==0</code> 时 <code>f</code> 不会被调用。）</p><p><em>注意：</em> Go 练习场中的时间总是从 2009-11-10 23:00:00 UTC 开始，该值的意义留给读者去发现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;When&#x27;s Saturday?&quot;</span>)</span><br><span class="line">today := time.Now().Weekday()</span><br><span class="line"><span class="keyword">switch</span> time.Saturday &#123;</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">0</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Today.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Tomorrow.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;In two days.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Too far away.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//When&#x27;s Saturday?</span></span><br><span class="line"><span class="comment">//Too far away.</span></span><br></pre></td></tr></table></figure><h4 id="没有条件的-switch"><a href="#没有条件的-switch" class="headerlink" title="没有条件的 switch"></a>没有条件的 switch</h4><p>没有条件的 switch 同 <code>switch true</code> 一样。</p><p>这种形式能将一长串 if-then-else 写得更加清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good evening.</span></span><br></pre></td></tr></table></figure><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>defer 语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//world</span></span><br></pre></td></tr></table></figure><h4 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a>defer 栈</h4><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p><p>更多关于 defer 语句的信息，请阅读<a href="http://blog.go-zh.org/defer-panic-and-recover">此博文</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">counting</span></span><br><span class="line"><span class="comment">done</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="1-3-更多类型：struct、slice-和映射"><a href="#1-3-更多类型：struct、slice-和映射" class="headerlink" title="1.3 更多类型：struct、slice 和映射"></a>1.3 更多类型：struct、slice 和映射</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>Go 拥有指针。指针保存了值的内存地址。</p><p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p *int</span><br></pre></td></tr></table></figure><p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := 42</span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure><p><code>*</code> 操作符表示指针指向的底层值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(*p) // 通过指针 p 读取 i</span><br><span class="line">*p = 21         // 通过指针 p 设置 i</span><br></pre></td></tr></table></figure><p>这也就是通常所说的“间接引用”或“重定向”。</p><p>与 C 不同，Go 没有指针运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">p := &amp;i         <span class="comment">// 指向 i</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 通过指针读取 i 的值</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针设置 i 的值</span></span><br><span class="line">fmt.Println(i)  <span class="comment">// 查看 i 的值</span></span><br><span class="line"></span><br><span class="line">p = &amp;j         <span class="comment">// 指向 j</span></span><br><span class="line">*p = *p / <span class="number">37</span>   <span class="comment">// 通过指针对 j 进行除法运算</span></span><br><span class="line">fmt.Println(j) <span class="comment">// 查看 j 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">42</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">73</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>一个结构体（<code>struct</code>）就是一组字段（field）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="type">int</span></span><br><span class="line">Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;1 2&#125;</span></span><br></pre></td></tr></table></figure><h4 id="结构体字段"><a href="#结构体字段" class="headerlink" title="结构体字段"></a>结构体字段</h4><p>结构体字段使用点号来访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="type">int</span></span><br><span class="line">Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">v.X = <span class="number">4</span></span><br><span class="line">fmt.Println(v.X)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><p>结构体字段可以通过结构体指针来访问。</p><p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code> 就可以。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="type">int</span></span><br><span class="line">Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;1000000000 2&#125;</span></span><br></pre></td></tr></table></figure><h4 id="结构体文法"><a href="#结构体文法" class="headerlink" title="结构体文法"></a>结构体文法</h4><p>结构体文法通过直接列出字段的值来新分配一个结构体。</p><p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p><p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125;</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p><p>表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a [10]int</span><br></pre></td></tr></table></figure><p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p><p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="type">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(primes)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Hello World</span></span><br><span class="line"><span class="comment">[Hello World]</span></span><br><span class="line"><span class="comment">[2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p><p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p><p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high]</span><br></pre></td></tr></table></figure><p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p><p>以下表达式创建了一个切片，它包含 <code>a</code> 中下标从 1 到 3 的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[1:4]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[3 5 7]</span></span><br></pre></td></tr></table></figure><h4 id="切片就像数组的引用"><a href="#切片就像数组的引用" class="headerlink" title="切片就像数组的引用"></a>切片就像数组的引用</h4><p>切片并不存储任何数据，它只是描述了底层数组中的一段。</p><p>更改切片的元素会修改其底层数组中对应的元素。</p><p>与它共享底层数组的切片都会观测到这些修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">names := [<span class="number">4</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;John&quot;</span>,</span><br><span class="line"><span class="string">&quot;Paul&quot;</span>,</span><br><span class="line"><span class="string">&quot;George&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ringo&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(names)</span><br><span class="line"></span><br><span class="line">a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">fmt.Println(names)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[John Paul George Ringo]</span></span><br><span class="line"><span class="comment">[John Paul] [Paul George]</span></span><br><span class="line"><span class="comment">[John XXX] [XXX George]</span></span><br><span class="line"><span class="comment">[John XXX George Ringo]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切片文法"><a href="#切片文法" class="headerlink" title="切片文法"></a>切片文法</h4><p>切片文法类似于没有长度的数组文法。</p><p>这是一个数组文法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure><p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">q := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(q)</span><br><span class="line"></span><br><span class="line">r := []<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br><span class="line">fmt.Println(r)</span><br><span class="line"></span><br><span class="line">s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="type">int</span></span><br><span class="line">b <span class="type">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">[true false true true false true]</span></span><br><span class="line"><span class="comment">[&#123;2 true&#125; &#123;3 false&#125; &#123;5 true&#125; &#123;7 true&#125; &#123;11 false&#125; &#123;13 true&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="切片的默认行为"><a href="#切片的默认行为" class="headerlink" title="切片的默认行为"></a>切片的默认行为</h4><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p><p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度。</p><p>对于数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a [10]int</span><br></pre></td></tr></table></figure><p>来说，以下切片是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[0:10]</span><br><span class="line">a[:10]</span><br><span class="line">a[0:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">s = s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s = s[:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[3 5 7]</span></span><br><span class="line"><span class="comment">[3 5]</span></span><br><span class="line"><span class="comment">[5]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a>切片的长度与容量</h4><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p><p>切片的长度就是它所包含的元素个数。</p><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p><p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p><p>你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展其长度</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 舍弃前两个值</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">len=6 cap=6 [2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">len=0 cap=6 []</span></span><br><span class="line"><span class="comment">len=4 cap=6 [2 3 5 7]</span></span><br><span class="line"><span class="comment">len=2 cap=4 [5 7]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a>nil 切片</h4><p>切片的零值是 <code>nil</code>。</p><p>nil 切片的长度和容量为 0 且没有底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;nil!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[] 0 0</span></span><br><span class="line"><span class="comment">nil!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="用-make-创建切片"><a href="#用-make-创建切片" class="headerlink" title="用 make 创建切片"></a>用 make 创建切片</h4><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p><p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := make([]int, 5)  // len(a)=5</span><br></pre></td></tr></table></figure><p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b := make([]int, 0, 5) // len(b)=0, cap(b)=5</span><br><span class="line"></span><br><span class="line">b = b[:cap(b)] // len(b)=5, cap(b)=5</span><br><span class="line">b = b[1:]      // len(b)=4, cap(b)=4</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">c := b[:<span class="number">2</span>]</span><br><span class="line">printSlice(<span class="string">&quot;c&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">printSlice(<span class="string">&quot;d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="type">string</span>, x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s len=%d cap=%d %v\n&quot;</span>,</span><br><span class="line">s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a len=5 cap=5 [0 0 0 0 0]</span></span><br><span class="line"><span class="comment">b len=0 cap=5 []</span></span><br><span class="line"><span class="comment">c len=2 cap=5 [0 0]</span></span><br><span class="line"><span class="comment">d len=3 cap=3 [0 0 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h4><p>切片可包含任何类型，甚至包括其它的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个井字板（经典游戏）</span></span><br><span class="line">board := [][]<span class="type">string</span>&#123;</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个玩家轮流打上 X 和 O</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, strings.Join(board[i], <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X _ X</span></span><br><span class="line"><span class="comment">O _ X</span></span><br><span class="line"><span class="comment">_ _ O</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h4><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数。内建函数的<a href="https://go-zh.org/pkg/builtin/#append">文档</a>对此函数有详细的介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func append(s []T, vs ...T) []T</span><br></pre></td></tr></table></figure><p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</p><p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</p><p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p><p>（要了解关于切片的更多内容，请阅读文章 <a href="https://blog.go-zh.org/go-slices-usage-and-internals">Go 切片：用法和本质</a>。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个空切片</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个切片会按需增长</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">len=0 cap=0 []</span></span><br><span class="line"><span class="comment">len=1 cap=1 [0]</span></span><br><span class="line"><span class="comment">len=2 cap=2 [0 1]</span></span><br><span class="line"><span class="comment">len=5 cap=6 [0 1 2 3 4]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p><p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2**0 = 1</span></span><br><span class="line"><span class="comment">2**1 = 2</span></span><br><span class="line"><span class="comment">2**2 = 4</span></span><br><span class="line"><span class="comment">2**3 = 8</span></span><br><span class="line"><span class="comment">2**4 = 16</span></span><br><span class="line"><span class="comment">2**5 = 32</span></span><br><span class="line"><span class="comment">2**6 = 64</span></span><br><span class="line"><span class="comment">2**7 = 128</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="range（续）"><a href="#range（续）" class="headerlink" title="range（续）"></a>range（续）</h4><p>可以将下标或值赋予 <code>_</code> 来忽略它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i, _ := range pow</span><br><span class="line">for _, value := range pow</span><br></pre></td></tr></table></figure><p>若你只需要索引，忽略第二个变量即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i := range pow</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pow := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;</span><br><span class="line">pow[i] = <span class="number">1</span> &lt;&lt; <span class="type">uint</span>(i) <span class="comment">// == 2**i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">32</span></span><br><span class="line"><span class="comment">64</span></span><br><span class="line"><span class="comment">128</span></span><br><span class="line"><span class="comment">256</span></span><br><span class="line"><span class="comment">512</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：切片"><a href="#练习：切片" class="headerlink" title="练习：切片"></a>练习：切片</h4><p>实现 <code>Pic</code>。它应当返回一个长度为 <code>dy</code> 的切片，其中每个元素是一个长度为 <code>dx</code>，元素类型为 <code>uint8</code> 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。</p><p>图像的选择由你来定。几个有趣的函数包括 <code>(x+y)/2</code>, <code>x*y</code>, <code>x^y</code>, <code>x*log(y)</code> 和 <code>x%(y+1)</code>。</p><p>（提示：需要使用循环来分配 <code>[][]uint8</code> 中的每个 <code>[]uint8</code>；请使用 <code>uint8(intValue)</code> 在类型之间转换；你可能会用到 <code>math</code> 包中的函数。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/tour/pic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="type">int</span>)</span></span> [][]<span class="type">uint8</span> &#123;</span><br><span class="line">out := <span class="built_in">make</span>([][]<span class="type">uint8</span>, dy)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; dy; i++ &#123;</span><br><span class="line">out[i] = <span class="built_in">make</span>([]<span class="type">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; dx; j++ &#123;</span><br><span class="line">out[i][j] = <span class="type">uint8</span>(i * j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pic.Show(Pic)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>映射将键映射到值。</p><p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。</p><p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;40.68433 -74.39967&#125;</span></span><br></pre></td></tr></table></figure><h4 id="映射的文法"><a href="#映射的文法" class="headerlink" title="映射的文法"></a>映射的文法</h4><p>映射的文法与结构体相似，不过必须有键名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="映射的文法（续）"><a href="#映射的文法（续）" class="headerlink" title="映射的文法（续）"></a>映射的文法（续）</h4><p>若顶级类型只是一个类型名，你可以在文法的元素中省略它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line"><span class="string">&quot;Google&quot;</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="修改映射"><a href="#修改映射" class="headerlink" title="修改映射"></a>修改映射</h4><p>在映射 <code>m</code> 中插入或修改元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[key] = elem</span><br></pre></td></tr></table></figure><p>获取元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure><p>删除元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(m, key)</span><br></pre></td></tr></table></figure><p>通过双赋值检测某个键是否存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure><p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code>。</p><p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值。</p><p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p><p><strong>注</strong> ：若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok := m[key]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])</span><br><span class="line"></span><br><span class="line">v, ok := m[<span class="string">&quot;Answer&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The value: 42</span></span><br><span class="line"><span class="comment">The value: 48</span></span><br><span class="line"><span class="comment">The value: 0</span></span><br><span class="line"><span class="comment">The value: 0 Present? false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：映射"><a href="#练习：映射" class="headerlink" title="练习：映射"></a>练习：映射</h4><p>实现 <code>WordCount</code>。它应当返回一个映射，其中包含字符串 <code>s</code> 中每个“单词”的个数。函数 <code>wc.Test</code> 会对此函数执行一系列测试用例，并输出成功还是失败。</p><p>你会发现 <a href="https://go-zh.org/pkg/strings/#Fields">strings.Fields</a> 很有帮助。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;golang.org/x/tour/wc&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WordCount</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">words := strings.Fields(s)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        n, ok := m[word]</span><br><span class="line">        <span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">            m[word] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m[word] = n + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wc.Test(WordCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h4><p>函数也是值。它们可以像其它值一样传递。</p><p>函数值可以用作函数的参数或返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">float64</span>, <span class="type">float64</span>)</span></span> <span class="type">float64</span>) <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(compute(hypot))</span><br><span class="line">fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">81</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h4><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p><p>例如，函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">1 -2</span></span><br><span class="line"><span class="comment">3 -6</span></span><br><span class="line"><span class="comment">6 -12</span></span><br><span class="line"><span class="comment">10 -20</span></span><br><span class="line"><span class="comment">15 -30</span></span><br><span class="line"><span class="comment">21 -42</span></span><br><span class="line"><span class="comment">28 -56</span></span><br><span class="line"><span class="comment">36 -72</span></span><br><span class="line"><span class="comment">45 -90</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：斐波纳契闭包"><a href="#练习：斐波纳契闭包" class="headerlink" title="练习：斐波纳契闭包"></a>练习：斐波纳契闭包</h4><p>让我们用函数做些好玩的事情。</p><p>实现一个 <code>fibonacci</code> 函数，它返回一个函数（闭包），该闭包返回一个<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波纳契数列</a> <code>(0, 1, 1, 2, 3, 5, ...)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个“返回int的函数”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">1</span> <span class="comment">//定义初始的两个值</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">c := a</span><br><span class="line">a, b = b, a+b</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">34</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Go 没有类。不过你可以为结构体类型定义方法。</p><p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p><p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p><p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h4 id="方法即函数"><a href="#方法即函数" class="headerlink" title="方法即函数"></a>方法即函数</h4><p>记住：方法只是个带接收者参数的函数。</p><p>现在这个 <code>Abs</code> 的写法就是个正常的函数，功能并没有什么变化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h4 id="方法（续）"><a href="#方法（续）" class="headerlink" title="方法（续）"></a>方法（续）</h4><p>你也可以为非结构体类型声明方法。</p><p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code>。</p><p>你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法。</p><p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.4142135623730951</span></span><br></pre></td></tr></table></figure><h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><p>你可以为指针接收者声明方法。</p><p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p><p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法。</p><p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p><p>试着移除第 16 行 <code>Scale</code> 函数声明中的 <code>*</code>，观察此程序的行为如何变化。</p><p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure><h4 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h4><p>现在我们要把 <code>Abs</code> 和 <code>Scale</code> 方法重写为函数。</p><p>同样，我们先试着移除掉第 16 的 <code>*</code>。你能看出为什么程序的行为改变了吗？要怎样做才能让该示例顺利通过编译？</p><p>（若你不确定，继续往下看。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(v *Vertex, f <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">Scale(&amp;v, <span class="number">10</span>)</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure><h4 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h4><p>比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">ScaleFunc(v, 5)  // 编译错误！</span><br><span class="line">ScaleFunc(&amp;v, 5) // OK</span><br></pre></td></tr></table></figure><p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">v.Scale(5)  // OK</span><br><span class="line">p := &amp;v</span><br><span class="line">p.Scale(10) // OK</span><br></pre></td></tr></table></figure><p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">2</span>)</span><br><span class="line">ScaleFunc(&amp;v, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">p.Scale(<span class="number">3</span>)</span><br><span class="line">ScaleFunc(p, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(v, p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;60 80&#125; &amp;&#123;96 72&#125;</span></span><br></pre></td></tr></table></figure><h4 id="方法与指针重定向（续）"><a href="#方法与指针重定向（续）" class="headerlink" title="方法与指针重定向（续）"></a>方法与指针重定向（续）</h4><p>同样的事情也发生在相反的方向。</p><p>接受一个值作为参数的函数必须接受一个指定类型的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(AbsFunc(v))  // OK</span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) // 编译错误！</span><br></pre></td></tr></table></figure><p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var v Vertex</span><br><span class="line">fmt.Println(v.Abs()) // OK</span><br><span class="line">p := &amp;v</span><br><span class="line">fmt.Println(p.Abs()) // OK</span><br></pre></td></tr></table></figure><p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AbsFunc</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">fmt.Println(AbsFunc(v))</span><br><span class="line"></span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(p.Abs())</span><br><span class="line">fmt.Println(AbsFunc(*p))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h4><p>使用指针接收者的原因有二：</p><p>首先，方法能够修改其接收者指向的值。</p><p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p><p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p><p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。（我们会在接下来几页中明白为什么。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Before scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">v.Scale(<span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;After scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Before scaling: &amp;&#123;X:3 Y:4&#125;, Abs: 5</span></span><br><span class="line"><span class="comment">After scaling: &amp;&#123;X:15 Y:20&#125;, Abs: 25</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p><p>接口类型的变量可以保存任何实现了这些方法的值。</p><p><strong>注意:</strong> 示例代码的 22 行存在一个错误。由于 <code>Abs</code> 方法只为 <code>*Vertex</code> （指针类型）定义，因此 <code>Vertex</code>（值类型）并未实现 <code>Abser</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line"><span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line">a = &amp;v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="接口与隐式实现"><a href="#接口与隐式实现" class="headerlink" title="接口与隐式实现"></a>接口与隐式实现</h4><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p><p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p><p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M() &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello </span></span><br></pre></td></tr></table></figure><h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><p>接口也是值。它们可以像其它值一样传递。</p><p>接口值可以用作函数的参数或返回值。</p><p>在内部，接口值可以看做包含值和具体类型的元组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value, type)</span><br></pre></td></tr></table></figure><p>接口值保存了一个具体底层类型的具体值。</p><p>接口值调用方法时会执行其底层类型的同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span></span> M() &#123;</span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = F(math.Pi)</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&amp;&#123;Hello&#125;, *main.T)</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">(3.141592653589793, main.F)</span></span><br><span class="line"><span class="comment">3.141592653589793</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="底层值为-nil-的接口值"><a href="#底层值为-nil-的接口值" class="headerlink" title="底层值为 nil 的接口值"></a>底层值为 nil 的接口值</h4><p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</p><p>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</p><p><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">i = t</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, *main.T)</span></span><br><span class="line"><span class="comment">&lt;nil&gt;</span></span><br><span class="line"><span class="comment">(&amp;&#123;hello&#125;, *main.T)</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="nil-接口值"><a href="#nil-接口值" class="headerlink" title="nil 接口值"></a>nil 接口值</h4><p>nil 接口值既不保存值也不保存具体类型。</p><p>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class="line"><span class="comment">panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"><span class="comment">[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x47f2e1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">/tmp/sandbox1265149038/prog.go:12 +0x61</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>指定了零个方法的接口值被称为 <em>空接口：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#123;&#125;</span><br></pre></td></tr></table></figure><p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p><p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class="line"><span class="comment">(42, int)</span></span><br><span class="line"><span class="comment">(hello, string)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure><p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p><p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。</p><p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p><p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p><p>请注意这种语法和读取一个映射时的相同之处。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="type">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello true</span></span><br><span class="line"><span class="comment">0 false</span></span><br><span class="line"><span class="comment">panic: interface conversion: interface &#123;&#125; is string, not float64</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p><p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch v := i.(type) &#123;</span><br><span class="line">case T:</span><br><span class="line">    // v 的类型为 T</span><br><span class="line">case S:</span><br><span class="line">    // v 的类型为 S</span><br><span class="line">default:</span><br><span class="line">    // 没有匹配，v 与 i 的类型相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p><p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Twice 21 is 42</span></span><br><span class="line"><span class="comment">&quot;hello&quot; is 5 bytes long</span></span><br><span class="line"><span class="comment">I don&#x27;t know about type bool!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h4><p><a href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">fmt.Println(a, z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Arthur Dent (42 years) Zaphod Beeblebrox (9001 years) </span></span><br></pre></td></tr></table></figure><h4 id="练习：Stringer"><a href="#练习：Stringer" class="headerlink" title="练习：Stringer"></a>练习：Stringer</h4><p>通过让 <code>IPAddr</code> 类型实现 <code>fmt.Stringer</code> 来打印点号分隔的地址。</p><p>例如，<code>IPAddr&#123;1, 2, 3, 4&#125;</code> 应当打印为 <code>&quot;1.2.3.4&quot;</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 给 IPAddr 添加一个 &quot;String() string&quot; 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dot IPAddr)</span></span> String() <span class="type">string</span>&#123;</span><br><span class="line">  str := <span class="string">&quot; &quot;</span></span><br><span class="line">  <span class="keyword">for</span> _, s :=<span class="keyword">range</span> dot&#123;</span><br><span class="line"><span class="keyword">if</span> str!=<span class="string">&quot; &quot;</span>&#123;</span><br><span class="line">str +=<span class="string">&quot;.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">str += strconv.Itoa(<span class="type">int</span>(s))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hosts := <span class="keyword">map</span>[<span class="type">string</span>]IPAddr&#123;</span><br><span class="line"><span class="string">&quot;loopback&quot;</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line"><span class="string">&quot;googleDNS&quot;</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, name, ip)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">loopback:  127.0.0.1</span></span><br><span class="line"><span class="comment">googleDNS:  8.8.8.8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p><p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p><p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, err := strconv.Atoi(&quot;42&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;couldn&#x27;t convert number: %v\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Converted integer:&quot;, i)</span><br></pre></td></tr></table></figure><p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">When time.Time</span><br><span class="line">What <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">time.Now(),</span><br><span class="line"><span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">at 2009-11-10 23:00:00 +0000 UTC m=+0.000000001, it didn&#x27;t work</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：错误"><a href="#练习：错误" class="headerlink" title="练习：错误"></a>练习：错误</h4><p>从<a href="https://tour.go-zh.org/flowcontrol/8">之前的练习</a>中复制 <code>Sqrt</code> 函数，修改它使其返回 <code>error</code> 值。</p><p><code>Sqrt</code> 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。</p><p>创建一个新的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ErrNegativeSqrt float64</span><br></pre></td></tr></table></figure><p>并为其实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (e ErrNegativeSqrt) Error() string</span><br></pre></td></tr></table></figure><p>方法使其拥有 <code>error</code> 值，通过 <code>ErrNegativeSqrt(-2).Error()</code> 调用该方法应返回 <code>&quot;cannot Sqrt negative number: -2&quot;</code>。</p><p><strong>注意:</strong> 在 <code>Error</code> 方法内调用 <code>fmt.Sprint(e)</code> 会让程序陷入死循环。可以通过先转换 <code>e</code> 来避免这个问题：<code>fmt.Sprint(float64(e))</code>。这是为什么呢？</p><p>修改 <code>Sqrt</code> 函数，使其接受一个负数时，返回 <code>ErrNegativeSqrt</code> 值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span></span> Error() <span class="type">string</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;cannot Sqrt negative number:  %v&quot;</span>, <span class="type">float64</span>(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">res := <span class="type">float64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">if</span> x&lt;<span class="number">0</span>&#123;</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">err = ErrNegativeSqrt(x)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">res = math.Sqrt(x)</span><br><span class="line">err = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">fmt.Println(Sqrt(<span class="number">-2</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.4142135623730951 &lt;nil&gt;</span></span><br><span class="line"><span class="comment">0 cannot Sqrt negative number:  -2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p><p>Go 标准库包含了该接口的<a href="https://go-zh.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p><p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (T) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure><p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p><p>示例代码创建了一个 <a href="https://go-zh.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]</span></span><br><span class="line"><span class="comment">b[:n] = &quot;Hello, R&quot;</span></span><br><span class="line"><span class="comment">n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]</span></span><br><span class="line"><span class="comment">b[:n] = &quot;eader!&quot;</span></span><br><span class="line"><span class="comment">n = 0 err = EOF b = [101 97 100 101 114 33 32 82]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="练习：Reader"><a href="#练习：Reader" class="headerlink" title="练习：Reader"></a>练习：Reader</h4><p>实现一个 <code>Reader</code> 类型，它产生一个 ASCII 字符 <code>&#39;A&#39;</code> 的无限流。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/tour/reader&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 给 MyReader 添加一个 Read([]byte) (int, error) 方法</span></span><br><span class="line"><span class="comment">// 向MyReader添加一个Read([]byte) (int, error)方法。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r MyReader)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>,<span class="type">error</span>)&#123;</span><br><span class="line">    <span class="comment">//赋值并返回</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader.Validate(MyReader&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OK!</span></span><br></pre></td></tr></table></figure><h4 id="练习：rot13Reader"><a href="#练习：rot13Reader" class="headerlink" title="练习：rot13Reader"></a>练习：rot13Reader</h4><p>有种常见的模式是一个 <a href="https://go-zh.org/pkg/io/#Reader"><code>io.Reader</code></a> 包装另一个 <code>io.Reader</code>，然后通过某种方式修改其数据流。</p><p>例如，<a href="https://go-zh.org/pkg/compress/gzip/#NewReader"><code>gzip.NewReader</code></a> 函数接受一个 <code>io.Reader</code>（已压缩的数据流）并返回一个同样实现了 <code>io.Reader</code> 的 <code>*gzip.Reader</code>（解压后的数据流）。</p><p>编写一个实现了 <code>io.Reader</code> 并从另一个 <code>io.Reader</code> 中读取数据的 <code>rot13Reader</code>，通过应用 <a href="http://en.wikipedia.org/wiki/ROT13">rot13</a> 代换密码对数据流进行修改。</p><p><code>rot13Reader</code> 类型已经提供。实现 <code>Read</code> 方法以满足 <code>io.Reader</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇blog</title>
      <link href="/2022/06/19/blog/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2022/06/19/blog/%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>第一次哦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 读取大文件</title>
      <link href="/2022/06/19/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
      <url>/2022/06/19/blog/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>处理 WorldKG 乱码问题的片段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import linecache</span></span><br><span class="line"><span class="comment"># text = linecache.getline(&#x27;./planet_osm.ttl&#x27;, 12743421)</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;./planet_osm.ttl&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">line = file.readline()</span><br><span class="line">counts = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line"><span class="keyword">if</span> counts &gt;= <span class="number">13352055</span>:</span><br><span class="line"><span class="built_in">print</span>(line)</span><br><span class="line"><span class="keyword">if</span> counts &gt;= <span class="number">13352056</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">line = file.readline()</span><br><span class="line">counts += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 待归档 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPARQL</title>
      <link href="/2022/06/19/blog/SPARQL/SPARQL/"/>
      <url>/2022/06/19/blog/SPARQL/SPARQL/</url>
      
        <content type="html"><![CDATA[<h1 id="SPARQL-1-1-查询语言"><a href="#SPARQL-1-1-查询语言" class="headerlink" title="SPARQL 1.1 查询语言"></a>SPARQL 1.1 查询语言</h1><blockquote><p>原文：<a href="https://www.w3.org/TR/sparql11-query/">https://www.w3.org/TR/sparql11-query/</a></p></blockquote><p><strong>摘要</strong></p><p>RDF 是一种有向的、标记的图形数据格式，用于表示 Web 中的信息。本规范定义了 RDF 的 SPARQL 查询语言的语法和语义。 SPARQL 可用于表达跨不同数据源的查询，无论数据是本地存储为 RDF 还是通过中间件查看为 RDF。 SPARQL 包含查询必需和可选图形模式及其连接和分离的功能。 SPARQL 还支持聚合、子查询、否定、通过表达式创建值、可扩展值测试以及通过源 RDF 图约束查询。 SPARQL 查询的结果可以是结果集或 RDF 图。</p><p>目录：</p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><h3 id="1-1-文档大纲"><a href="#1-1-文档大纲" class="headerlink" title="1.1 文档大纲"></a>1.1 文档大纲</h3><h3 id="1-2-文档约定"><a href="#1-2-文档约定" class="headerlink" title="1.2 文档约定"></a>1.2 文档约定</h3><h4 id="1-2-1-命名空间"><a href="#1-2-1-命名空间" class="headerlink" title="1.2.1 命名空间"></a>1.2.1 命名空间</h4><h4 id="1-2-2-数据描述"><a href="#1-2-2-数据描述" class="headerlink" title="1.2.2 数据描述"></a>1.2.2 数据描述</h4><h4 id="1-2-3-结果描述"><a href="#1-2-3-结果描述" class="headerlink" title="1.2.3 结果描述"></a>1.2.3 结果描述</h4><h4 id="1-2-4-术语"><a href="#1-2-4-术语" class="headerlink" title="1.2.4 术语"></a>1.2.4 术语</h4><h2 id="2-进行简单查询（信息性）"><a href="#2-进行简单查询（信息性）" class="headerlink" title="2 进行简单查询（信息性）"></a>2 进行简单查询（信息性）</h2><h3 id="2-1-编写简单查询"><a href="#2-1-编写简单查询" class="headerlink" title="2.1 编写简单查询"></a>2.1 编写简单查询</h3><h3 id="2-2-多重匹配"><a href="#2-2-多重匹配" class="headerlink" title="2.2 多重匹配"></a>2.2 多重匹配</h3><h3 id="2-3-匹配-RDF-文字"><a href="#2-3-匹配-RDF-文字" class="headerlink" title="2.3 匹配 RDF 文字"></a>2.3 匹配 RDF 文字</h3><h4 id="2-3-1-将文字与语言标签匹配"><a href="#2-3-1-将文字与语言标签匹配" class="headerlink" title="2.3.1 将文字与语言标签匹配"></a>2.3.1 将文字与语言标签匹配</h4><h4 id="2-3-2-将文字与数字类型匹配"><a href="#2-3-2-将文字与数字类型匹配" class="headerlink" title="2.3.2 将文字与数字类型匹配"></a>2.3.2 将文字与数字类型匹配</h4><h4 id="2-3-3-将文字与任意数据类型匹配"><a href="#2-3-3-将文字与任意数据类型匹配" class="headerlink" title="2.3.3 将文字与任意数据类型匹配"></a>2.3.3 将文字与任意数据类型匹配</h4><h3 id="2-4-查询结果中的空白节点标签"><a href="#2-4-查询结果中的空白节点标签" class="headerlink" title="2.4 查询结果中的空白节点标签"></a>2.4 查询结果中的空白节点标签</h3><h3 id="2-5-使用表达式创建值"><a href="#2-5-使用表达式创建值" class="headerlink" title="2.5 使用表达式创建值"></a>2.5 使用表达式创建值</h3><h3 id="2-6-构建-RDF-图"><a href="#2-6-构建-RDF-图" class="headerlink" title="2.6 构建 RDF 图"></a>2.6 构建 RDF 图</h3><h2 id="3-RDF-术语约束（信息性）"><a href="#3-RDF-术语约束（信息性）" class="headerlink" title="3 RDF 术语约束（信息性）"></a>3 RDF 术语约束（信息性）</h2><h3 id="3-1-限制字符串的值"><a href="#3-1-限制字符串的值" class="headerlink" title="3.1 限制字符串的值"></a>3.1 限制字符串的值</h3><h3 id="3-2-限制数值"><a href="#3-2-限制数值" class="headerlink" title="3.2 限制数值"></a>3.2 限制数值</h3><h3 id="3-3-其他术语约束"><a href="#3-3-其他术语约束" class="headerlink" title="3.3 其他术语约束"></a>3.3 其他术语约束</h3><h2 id="4-SPARQL-语法"><a href="#4-SPARQL-语法" class="headerlink" title="4 SPARQL 语法"></a>4 SPARQL 语法</h2><h3 id="4-1-RDF-术语语法"><a href="#4-1-RDF-术语语法" class="headerlink" title="4.1 RDF 术语语法"></a>4.1 RDF 术语语法</h3><h4 id="4-1-1-IRI-语法"><a href="#4-1-1-IRI-语法" class="headerlink" title="4.1.1 IRI 语法"></a>4.1.1 IRI 语法</h4><h5 id="4-1-1-1-前缀名称"><a href="#4-1-1-1-前缀名称" class="headerlink" title="4.1.1.1 前缀名称"></a>4.1.1.1 前缀名称</h5><h5 id="4-1-1-2-相对-IRI"><a href="#4-1-1-2-相对-IRI" class="headerlink" title="4.1.1.2 相对 IRI"></a>4.1.1.2 相对 IRI</h5><h4 id="4-1-2-文字语法"><a href="#4-1-2-文字语法" class="headerlink" title="4.1.2 文字语法"></a>4.1.2 文字语法</h4><h4 id="4-1-3-查询变量的语法"><a href="#4-1-3-查询变量的语法" class="headerlink" title="4.1.3 查询变量的语法"></a>4.1.3 查询变量的语法</h4><h4 id="4-1-4-空白节点的语法"><a href="#4-1-4-空白节点的语法" class="headerlink" title="4.1.4 空白节点的语法"></a>4.1.4 空白节点的语法</h4><h3 id="4-2-三重模式的语法"><a href="#4-2-三重模式的语法" class="headerlink" title="4.2 三重模式的语法"></a>4.2 三重模式的语法</h3><h4 id="4-2-1-谓词-对象列表"><a href="#4-2-1-谓词-对象列表" class="headerlink" title="4.2.1 谓词-对象列表"></a>4.2.1 谓词-对象列表</h4><h4 id="4-2-2-对象列表"><a href="#4-2-2-对象列表" class="headerlink" title="4.2.2 对象列表"></a>4.2.2 对象列表</h4><h4 id="4-2-3-RDF-集合"><a href="#4-2-3-RDF-集合" class="headerlink" title="4.2.3 RDF 集合"></a>4.2.3 RDF 集合</h4><h4 id="4-2-4-rdf-type"><a href="#4-2-4-rdf-type" class="headerlink" title="4.2.4 rdf:type"></a>4.2.4 rdf:type</h4><h2 id="5-图模式"><a href="#5-图模式" class="headerlink" title="5 图模式"></a>5 图模式</h2><h3 id="5-1-基本图模式"><a href="#5-1-基本图模式" class="headerlink" title="5.1 基本图模式"></a>5.1 基本图模式</h3><h4 id="5-1-1-空白节点标签"><a href="#5-1-1-空白节点标签" class="headerlink" title="5.1.1 空白节点标签"></a>5.1.1 空白节点标签</h4><h4 id="5-1-2-扩展基本图模式匹配"><a href="#5-1-2-扩展基本图模式匹配" class="headerlink" title="5.1.2 扩展基本图模式匹配"></a>5.1.2 扩展基本图模式匹配</h4><h3 id="5-2-组图模式"><a href="#5-2-组图模式" class="headerlink" title="5.2 组图模式"></a>5.2 组图模式</h3><h4 id="5-2-1-空组模式"><a href="#5-2-1-空组模式" class="headerlink" title="5.2.1 空组模式"></a>5.2.1 空组模式</h4><h4 id="5-2-2-过滤器范围"><a href="#5-2-2-过滤器范围" class="headerlink" title="5.2.2 过滤器范围"></a>5.2.2 过滤器范围</h4><h4 id="5-2-3-组图模式示例"><a href="#5-2-3-组图模式示例" class="headerlink" title="5.2.3 组图模式示例"></a>5.2.3 组图模式示例</h4><h2 id="6-包括可选值"><a href="#6-包括可选值" class="headerlink" title="6 包括可选值"></a>6 包括可选值</h2><h3 id="6-1-可选模式匹配"><a href="#6-1-可选模式匹配" class="headerlink" title="6.1 可选模式匹配"></a>6.1 可选模式匹配</h3><h3 id="6-2-可选模式匹配中的约束"><a href="#6-2-可选模式匹配中的约束" class="headerlink" title="6.2 可选模式匹配中的约束"></a>6.2 可选模式匹配中的约束</h3><h3 id="6-3-多个可选图形模式"><a href="#6-3-多个可选图形模式" class="headerlink" title="6.3 多个可选图形模式"></a>6.3 多个可选图形模式</h3><h2 id="7-匹配备选方案"><a href="#7-匹配备选方案" class="headerlink" title="7 匹配备选方案"></a>7 匹配备选方案</h2><h2 id="8-否定"><a href="#8-否定" class="headerlink" title="8 否定"></a>8 否定</h2><h3 id="8-1-使用图形模式过滤"><a href="#8-1-使用图形模式过滤" class="headerlink" title="8.1 使用图形模式过滤"></a>8.1 使用图形模式过滤</h3><h4 id="8-1-1-测试模式是否不存在"><a href="#8-1-1-测试模式是否不存在" class="headerlink" title="8.1.1 测试模式是否不存在"></a>8.1.1 测试模式是否不存在</h4><h4 id="8-1-2-测试模式是否存在"><a href="#8-1-2-测试模式是否存在" class="headerlink" title="8.1.2 测试模式是否存在"></a>8.1.2 测试模式是否存在</h4><h3 id="8-2-删除可能的解决方案"><a href="#8-2-删除可能的解决方案" class="headerlink" title="8.2 删除可能的解决方案"></a>8.2 删除可能的解决方案</h3><h3 id="8-3-NOT-EXISTS-和-MINUS-之间的关系和差异"><a href="#8-3-NOT-EXISTS-和-MINUS-之间的关系和差异" class="headerlink" title="8.3 NOT EXISTS 和 MINUS 之间的关系和差异"></a>8.3 NOT EXISTS 和 MINUS 之间的关系和差异</h3><h4 id="8-3-1-示例：变量共享"><a href="#8-3-1-示例：变量共享" class="headerlink" title="8.3.1 示例：变量共享"></a>8.3.1 示例：变量共享</h4><h4 id="8-3-2-示例：固定模式"><a href="#8-3-2-示例：固定模式" class="headerlink" title="8.3.2 示例：固定模式"></a>8.3.2 示例：固定模式</h4><h4 id="8-3-3-示例：内部过滤器"><a href="#8-3-3-示例：内部过滤器" class="headerlink" title="8.3.3 示例：内部过滤器"></a>8.3.3 示例：内部过滤器</h4><h2 id="9-属性路径"><a href="#9-属性路径" class="headerlink" title="9 属性路径"></a>9 属性路径</h2><h3 id="9-1-属性路径语法"><a href="#9-1-属性路径语法" class="headerlink" title="9.1 属性路径语法"></a>9.1 属性路径语法</h3><h3 id="9-2-示例"><a href="#9-2-示例" class="headerlink" title="9.2 示例"></a>9.2 示例</h3><h3 id="9-3-属性路径和等效模式"><a href="#9-3-属性路径和等效模式" class="headerlink" title="9.3 属性路径和等效模式"></a>9.3 属性路径和等效模式</h3><h3 id="9-4-任意长度路径匹配"><a href="#9-4-任意长度路径匹配" class="headerlink" title="9.4 任意长度路径匹配"></a>9.4 任意长度路径匹配</h3><h2 id="10-赋值"><a href="#10-赋值" class="headerlink" title="10 赋值"></a>10 赋值</h2><h3 id="10-1-BIND：分配给变量"><a href="#10-1-BIND：分配给变量" class="headerlink" title="10.1 BIND：分配给变量"></a>10.1 BIND：分配给变量</h3><h3 id="10-2-VALUES：提供内联数据"><a href="#10-2-VALUES：提供内联数据" class="headerlink" title="10.2 VALUES：提供内联数据"></a>10.2 VALUES：提供内联数据</h3><h4 id="10-2-1-VALUES-语法"><a href="#10-2-1-VALUES-语法" class="headerlink" title="10.2.1 VALUES 语法"></a>10.2.1 VALUES 语法</h4><h4 id="10-2-2-VALUES-示例"><a href="#10-2-2-VALUES-示例" class="headerlink" title="10.2.2 VALUES 示例"></a>10.2.2 VALUES 示例</h4><h2 id="11-聚合"><a href="#11-聚合" class="headerlink" title="11 聚合"></a>11 聚合</h2><h3 id="11-1-聚合示例"><a href="#11-1-聚合示例" class="headerlink" title="11.1 聚合示例"></a>11.1 聚合示例</h3><h3 id="11-2-GROUP-BY"><a href="#11-2-GROUP-BY" class="headerlink" title="11.2 GROUP BY"></a>11.2 GROUP BY</h3><h3 id="11-3-HAVING"><a href="#11-3-HAVING" class="headerlink" title="11.3 HAVING"></a>11.3 HAVING</h3><h3 id="11-4-聚合投影限制"><a href="#11-4-聚合投影限制" class="headerlink" title="11.4 聚合投影限制"></a>11.4 聚合投影限制</h3><h3 id="11-5-聚合示例（有错误）"><a href="#11-5-聚合示例（有错误）" class="headerlink" title="11.5 聚合示例（有错误）"></a>11.5 聚合示例（有错误）</h3><h2 id="12-子查询"><a href="#12-子查询" class="headerlink" title="12 子查询"></a>12 子查询</h2><h2 id="13-RDF-数据集"><a href="#13-RDF-数据集" class="headerlink" title="13 RDF 数据集"></a>13 RDF 数据集</h2><h3 id="13-1-RDF-数据集示例"><a href="#13-1-RDF-数据集示例" class="headerlink" title="13.1 RDF 数据集示例"></a>13.1 RDF 数据集示例</h3><h3 id="13-2-指定-RDF-数据集"><a href="#13-2-指定-RDF-数据集" class="headerlink" title="13.2 指定 RDF 数据集"></a>13.2 指定 RDF 数据集</h3><h4 id="13-2-1-指定默认图"><a href="#13-2-1-指定默认图" class="headerlink" title="13.2.1 指定默认图"></a>13.2.1 指定默认图</h4><h4 id="13-2-2-指定命名图"><a href="#13-2-2-指定命名图" class="headerlink" title="13.2.2 指定命名图"></a>13.2.2 指定命名图</h4><h4 id="13-2-3-结合-FROM-和-FROM-NAMED"><a href="#13-2-3-结合-FROM-和-FROM-NAMED" class="headerlink" title="13.2.3 结合 FROM 和 FROM NAMED"></a>13.2.3 结合 FROM 和 FROM NAMED</h4><h3 id="13-3-查询数据集"><a href="#13-3-查询数据集" class="headerlink" title="13.3 查询数据集"></a>13.3 查询数据集</h3><h4 id="13-3-1-访问图名"><a href="#13-3-1-访问图名" class="headerlink" title="13.3.1 访问图名"></a>13.3.1 访问图名</h4><h4 id="13-3-2-限制方式图-IRI"><a href="#13-3-2-限制方式图-IRI" class="headerlink" title="13.3.2 限制方式图 IRI"></a>13.3.2 限制方式图 IRI</h4><h4 id="13-3-3-限制可能的图-IRI"><a href="#13-3-3-限制可能的图-IRI" class="headerlink" title="13.3.3 限制可能的图 IRI"></a>13.3.3 限制可能的图 IRI</h4><h4 id="13-3-4-命名和默认图"><a href="#13-3-4-命名和默认图" class="headerlink" title="13.3.4 命名和默认图"></a>13.3.4 命名和默认图</h4><h2 id="14-基本联合查询"><a href="#14-基本联合查询" class="headerlink" title="14 基本联合查询"></a>14 基本联合查询</h2><h2 id="15-解决方案序列和修饰符"><a href="#15-解决方案序列和修饰符" class="headerlink" title="15 解决方案序列和修饰符"></a>15 解决方案序列和修饰符</h2><h3 id="15-1-ORDER-BY"><a href="#15-1-ORDER-BY" class="headerlink" title="15.1 ORDER BY"></a>15.1 ORDER BY</h3><h3 id="15-2-投影"><a href="#15-2-投影" class="headerlink" title="15.2 投影"></a>15.2 投影</h3><h3 id="15-3-重复解决方案"><a href="#15-3-重复解决方案" class="headerlink" title="15.3 重复解决方案"></a>15.3 重复解决方案</h3><h3 id="15-4-偏移量"><a href="#15-4-偏移量" class="headerlink" title="15.4 偏移量"></a>15.4 偏移量</h3><h3 id="15-5-限制"><a href="#15-5-限制" class="headerlink" title="15.5 限制"></a>15.5 限制</h3><h2 id="16-查询表单"><a href="#16-查询表单" class="headerlink" title="16 查询表单"></a>16 查询表单</h2><h3 id="16-1-SELECT"><a href="#16-1-SELECT" class="headerlink" title="16.1 SELECT"></a>16.1 SELECT</h3><h4 id="16-1-1-投影"><a href="#16-1-1-投影" class="headerlink" title="16.1.1 投影"></a>16.1.1 投影</h4><h4 id="16-1-2-SELECT-表达式"><a href="#16-1-2-SELECT-表达式" class="headerlink" title="16.1.2 SELECT 表达式"></a>16.1.2 SELECT 表达式</h4><h3 id="16-2-CONSTRUCT"><a href="#16-2-CONSTRUCT" class="headerlink" title="16.2 CONSTRUCT"></a>16.2 CONSTRUCT</h3><h4 id="16-2-1-带有空白节点的模板"><a href="#16-2-1-带有空白节点的模板" class="headerlink" title="16.2.1 带有空白节点的模板"></a>16.2.1 带有空白节点的模板</h4><h4 id="16-2-2-访问-RDF-数据集中的图形"><a href="#16-2-2-访问-RDF-数据集中的图形" class="headerlink" title="16.2.2 访问 RDF 数据集中的图形"></a>16.2.2 访问 RDF 数据集中的图形</h4><h4 id="16-2-3-解决方案修饰符和-CONSTRUCT"><a href="#16-2-3-解决方案修饰符和-CONSTRUCT" class="headerlink" title="16.2.3 解决方案修饰符和 CONSTRUCT"></a>16.2.3 解决方案修饰符和 CONSTRUCT</h4><h4 id="16-2-4-CONSTRUCT-WHERE"><a href="#16-2-4-CONSTRUCT-WHERE" class="headerlink" title="16.2.4 CONSTRUCT WHERE"></a>16.2.4 CONSTRUCT WHERE</h4><h3 id="16-3-ASK"><a href="#16-3-ASK" class="headerlink" title="16.3 ASK"></a>16.3 ASK</h3><h3 id="16-4-DESCRIBE-Informative"><a href="#16-4-DESCRIBE-Informative" class="headerlink" title="16.4 DESCRIBE (Informative )"></a>16.4 DESCRIBE (Informative )</h3><h4 id="16-4-1-显式-IRI"><a href="#16-4-1-显式-IRI" class="headerlink" title="16.4.1 显式 IRI"></a>16.4.1 显式 IRI</h4><h4 id="16-4-2-识别资源"><a href="#16-4-2-识别资源" class="headerlink" title="16.4.2 识别资源"></a>16.4.2 识别资源</h4><h4 id="16-4-3-资源描述"><a href="#16-4-3-资源描述" class="headerlink" title="16.4.3 资源描述"></a>16.4.3 资源描述</h4><h2 id="17-表达式和测试值"><a href="#17-表达式和测试值" class="headerlink" title="17 表达式和测试值"></a>17 表达式和测试值</h2><h3 id="17-1-操作数数据类型"><a href="#17-1-操作数数据类型" class="headerlink" title="17.1 操作数数据类型"></a>17.1 操作数数据类型</h3><h3 id="17-2-过滤器评估"><a href="#17-2-过滤器评估" class="headerlink" title="17.2 过滤器评估"></a>17.2 过滤器评估</h3><h4 id="17-2-1-调用"><a href="#17-2-1-调用" class="headerlink" title="17.2.1 调用"></a>17.2.1 调用</h4><h4 id="17-2-2-有效布尔值-EBV"><a href="#17-2-2-有效布尔值-EBV" class="headerlink" title="17.2.2 有效布尔值 (EBV)"></a>17.2.2 有效布尔值 (EBV)</h4><h3 id="17-3-运算符映射"><a href="#17-3-运算符映射" class="headerlink" title="17.3 运算符映射"></a>17.3 运算符映射</h3><h4 id="17-3-1-运算符可扩展性"><a href="#17-3-1-运算符可扩展性" class="headerlink" title="17.3.1 运算符可扩展性"></a>17.3.1 运算符可扩展性</h4><h3 id="17-4-函数定义"><a href="#17-4-函数定义" class="headerlink" title="17.4 函数定义"></a>17.4 函数定义</h3><h4 id="17-4-1-函数形式"><a href="#17-4-1-函数形式" class="headerlink" title="17.4.1 函数形式"></a>17.4.1 函数形式</h4><h5 id="17-4-1-1-绑定"><a href="#17-4-1-1-绑定" class="headerlink" title="17.4.1.1 绑定"></a>17.4.1.1 绑定</h5><h5 id="17-4-1-2-IF"><a href="#17-4-1-2-IF" class="headerlink" title="17.4.1.2 IF"></a>17.4.1.2 IF</h5><h5 id="17-4-1-3-COALESCE"><a href="#17-4-1-3-COALESCE" class="headerlink" title="17.4.1.3 COALESCE"></a>17.4.1.3 COALESCE</h5><h5 id="17-4-1-4-NOT-EXISTS-和-EXISTS"><a href="#17-4-1-4-NOT-EXISTS-和-EXISTS" class="headerlink" title="17.4.1.4 NOT EXISTS 和 EXISTS"></a>17.4.1.4 NOT EXISTS 和 EXISTS</h5><h5 id="17-4-1-5-逻辑或"><a href="#17-4-1-5-逻辑或" class="headerlink" title="17.4.1.5 逻辑或"></a>17.4.1.5 逻辑或</h5><h5 id="17-4-1-6-逻辑和"><a href="#17-4-1-6-逻辑和" class="headerlink" title="17.4.1.6 逻辑和"></a>17.4.1.6 逻辑和</h5><h5 id="17-4-1-7-RDFterm-equal"><a href="#17-4-1-7-RDFterm-equal" class="headerlink" title="17.4.1.7 RDFterm-equal"></a>17.4.1.7 RDFterm-equal</h5><h5 id="17-4-1-8-sameTerm"><a href="#17-4-1-8-sameTerm" class="headerlink" title="17.4.1.8 sameTerm"></a>17.4.1.8 sameTerm</h5><h5 id="17-4-1-9-IN"><a href="#17-4-1-9-IN" class="headerlink" title="17.4.1.9 IN"></a>17.4.1.9 IN</h5><h5 id="17-4-1-10-NOT-IN"><a href="#17-4-1-10-NOT-IN" class="headerlink" title="17.4.1.10 NOT IN"></a>17.4.1.10 NOT IN</h5><h4 id="17-4-2-RDF-术语上的函数"><a href="#17-4-2-RDF-术语上的函数" class="headerlink" title="17.4.2 RDF 术语上的函数"></a>17.4.2 RDF 术语上的函数</h4><h5 id="17-4-2-1-isIRI"><a href="#17-4-2-1-isIRI" class="headerlink" title="17.4.2.1  isIRI"></a>17.4.2.1  isIRI</h5><h5 id="17-4-2-2-ISBLANK"><a href="#17-4-2-2-ISBLANK" class="headerlink" title="17.4.2.2 ISBLANK"></a>17.4.2.2 ISBLANK</h5><h5 id="17-4-2-3-ISLITERAL"><a href="#17-4-2-3-ISLITERAL" class="headerlink" title="17.4.2.3 ISLITERAL"></a>17.4.2.3 ISLITERAL</h5><h5 id="17-4-2-4-ISNUMERIC"><a href="#17-4-2-4-ISNUMERIC" class="headerlink" title="17.4.2.4 ISNUMERIC"></a>17.4.2.4 ISNUMERIC</h5><h5 id="17-4-2-5-Str"><a href="#17-4-2-5-Str" class="headerlink" title="17.4.2.5 Str"></a>17.4.2.5 Str</h5><h5 id="17-4-2-6-Lang"><a href="#17-4-2-6-Lang" class="headerlink" title="17.4.2.6 Lang"></a>17.4.2.6 Lang</h5><h5 id="17-4-2-7-DataType"><a href="#17-4-2-7-DataType" class="headerlink" title="17.4.2.7 DataType"></a>17.4.2.7 DataType</h5><h5 id="17-4-2-8-IRI"><a href="#17-4-2-8-IRI" class="headerlink" title="17.4.2.8 IRI"></a>17.4.2.8 IRI</h5><h5 id="17-4-2-9-Bnode"><a href="#17-4-2-9-Bnode" class="headerlink" title="17.4.2.9 Bnode"></a>17.4.2.9 Bnode</h5><h5 id="17-4-4-2-10-strdt"><a href="#17-4-4-2-10-strdt" class="headerlink" title="17.4.4.2.10 strdt"></a>17.4.4.2.10 strdt</h5><h5 id="17-4-2-11-Strlang"><a href="#17-4-2-11-Strlang" class="headerlink" title="17.4.2.11 Strlang"></a>17.4.2.11 Strlang</h5><h5 id="17-4-2-12-UUIID"><a href="#17-4-2-12-UUIID" class="headerlink" title="17.4.2.12 UUIID"></a>17.4.2.12 UUIID</h5><h5 id="17-4-2-13-StruID-STRUID-STRUID"><a href="#17-4-2-13-StruID-STRUID-STRUID" class="headerlink" title="17.4.2.13 StruID STRUID STRUID"></a>17.4.2.13 StruID STRUID STRUID</h5><h4 id="17-4-3-字符串函数"><a href="#17-4-3-字符串函数" class="headerlink" title="17.4.3 字符串函数"></a>17.4.3 字符串函数</h4><h5 id="17-4-3-1-SPARQL-函数中的字符串"><a href="#17-4-3-1-SPARQL-函数中的字符串" class="headerlink" title="17.4.3.1 SPARQL 函数中的字符串"></a>17.4.3.1 SPARQL 函数中的字符串</h5><h6 id="17-4-3-1-1-字符串参数"><a href="#17-4-3-1-1-字符串参数" class="headerlink" title="17.4.3.1.1 字符串参数"></a>17.4.3.1.1 字符串参数</h6><h6 id="17-4-3-1-2-参数兼容性规则"><a href="#17-4-3-1-2-参数兼容性规则" class="headerlink" title="17.4.3.1.2 参数兼容性规则"></a>17.4.3.1.2 参数兼容性规则</h6><h6 id="17-4-3-1-3-字符串字面量返回类型"><a href="#17-4-3-1-3-字符串字面量返回类型" class="headerlink" title="17.4.3.1.3 字符串字面量返回类型"></a>17.4.3.1.3 字符串字面量返回类型</h6><h5 id="17-4-3-2-STRLEN"><a href="#17-4-3-2-STRLEN" class="headerlink" title="17.4.3.2 STRLEN"></a>17.4.3.2 STRLEN</h5><h5 id="17-4-3-3-SUBSTR"><a href="#17-4-3-3-SUBSTR" class="headerlink" title="17.4.3.3 SUBSTR"></a>17.4.3.3 SUBSTR</h5><h5 id="17-4-3-4-UCASE"><a href="#17-4-3-4-UCASE" class="headerlink" title="17.4.3.4 UCASE"></a>17.4.3.4 UCASE</h5><h5 id="17-4-3-5-LCASE"><a href="#17-4-3-5-LCASE" class="headerlink" title="17.4 .3.5 LCASE"></a>17.4 .3.5 LCASE</h5><h5 id="17-4-3-6-STRSTARTS"><a href="#17-4-3-6-STRSTARTS" class="headerlink" title="17.4.3.6 STRSTARTS"></a>17.4.3.6 STRSTARTS</h5><h5 id="17-4-3-7-STRENDS"><a href="#17-4-3-7-STRENDS" class="headerlink" title="17.4.3.7 STRENDS"></a>17.4.3.7 STRENDS</h5><h5 id="17-4-3-8-CONTAINS"><a href="#17-4-3-8-CONTAINS" class="headerlink" title="17.4.3.8 CONTAINS"></a>17.4.3.8 CONTAINS</h5><h5 id="17-4-3-9-STRBEFORE"><a href="#17-4-3-9-STRBEFORE" class="headerlink" title="17.4.3.9 STRBEFORE"></a>17.4.3.9 STRBEFORE</h5><h5 id="17-4-3-10-STRAFTER"><a href="#17-4-3-10-STRAFTER" class="headerlink" title="17.4.3.10 STRAFTER"></a>17.4.3.10 STRAFTER</h5><h5 id="17-4-3-11-ENCODE-FOR-URI"><a href="#17-4-3-11-ENCODE-FOR-URI" class="headerlink" title="17.4.3.11 ENCODE_FOR_URI"></a>17.4.3.11 ENCODE_FOR_URI</h5><h5 id="17-4-3-12-CONCAT"><a href="#17-4-3-12-CONCAT" class="headerlink" title="17.4.3.12 CONCAT"></a>17.4.3.12 CONCAT</h5><h5 id="17-4-3-13-langMatches"><a href="#17-4-3-13-langMatches" class="headerlink" title="17.4.3.13 langMatches"></a>17.4.3.13 langMatches</h5><h5 id="17-4-3-14-REGEX"><a href="#17-4-3-14-REGEX" class="headerlink" title="17.4.3.14 REGEX"></a>17.4.3.14 REGEX</h5><h5 id="17-4-3-15-REPLACE"><a href="#17-4-3-15-REPLACE" class="headerlink" title="17.4.3.15 REPLACE"></a>17.4.3.15 REPLACE</h5><h4 id="17-4-4-Functions-on-Numerics"><a href="#17-4-4-Functions-on-Numerics" class="headerlink" title="17.4.4 Functions on Numerics"></a>17.4.4 Functions on Numerics</h4><h5 id="17-4-4-1-abs"><a href="#17-4-4-1-abs" class="headerlink" title="17.4 .4.1 abs"></a>17.4 .4.1 abs</h5><h5 id="17-4-4-2-round"><a href="#17-4-4-2-round" class="headerlink" title="17.4.4.2 round"></a>17.4.4.2 round</h5><h5 id="17-4-4-3-ceil"><a href="#17-4-4-3-ceil" class="headerlink" title="17.4.4.3 ceil"></a>17.4.4.3 ceil</h5><h5 id="17-4-4-4-floor"><a href="#17-4-4-4-floor" class="headerlink" title="17.4.4.4 floor"></a>17.4.4.4 floor</h5><h5 id="17-4-4-5-RAND"><a href="#17-4-4-5-RAND" class="headerlink" title="17.4.4.5 RAND"></a>17.4.4.5 RAND</h5><h4 id="17-4-5-日期和时间函数"><a href="#17-4-5-日期和时间函数" class="headerlink" title="17.4.5 日期和时间函数"></a>17.4.5 日期和时间函数</h4><h5 id="17-4-5-1-现在"><a href="#17-4-5-1-现在" class="headerlink" title="17.4.5.1 现在"></a>17.4.5.1 现在</h5><h5 id="17-4-5-2-年"><a href="#17-4-5-2-年" class="headerlink" title="17.4.5.2 年"></a>17.4.5.2 年</h5><h5 id="17-4-5-3-月"><a href="#17-4-5-3-月" class="headerlink" title="17.4.5.3 月"></a>17.4.5.3 月</h5><h5 id="17-4-5-4-天"><a href="#17-4-5-4-天" class="headerlink" title="17.4.5.4 天"></a>17.4.5.4 天</h5><h5 id="17-4-5-5-小时"><a href="#17-4-5-5-小时" class="headerlink" title="17.4.5.5 小时"></a>17.4.5.5 小时</h5><h5 id="17-4-5-6-分钟"><a href="#17-4-5-6-分钟" class="headerlink" title="17.4.5.6 分钟"></a>17.4.5.6 分钟</h5><h5 id="17-4-5-7-秒"><a href="#17-4-5-7-秒" class="headerlink" title="17.4.5.7 秒"></a>17.4.5.7 秒</h5><h5 id="17-4-5-8-时区"><a href="#17-4-5-8-时区" class="headerlink" title="17.4.5.8 时区"></a>17.4.5.8 时区</h5><h5 id="17-4-5-9-tz"><a href="#17-4-5-9-tz" class="headerlink" title="17.4.5.9 tz"></a>17.4.5.9 tz</h5><h4 id="17-4-6-哈希函数"><a href="#17-4-6-哈希函数" class="headerlink" title="17.4.6 哈希函数"></a>17.4.6 哈希函数</h4><h5 id="17-4-6-1-MD5"><a href="#17-4-6-1-MD5" class="headerlink" title="17.4.6.1 MD5"></a>17.4.6.1 MD5</h5><h5 id="17-4-6-2-SHA1"><a href="#17-4-6-2-SHA1" class="headerlink" title="17.4.6.2 SHA1"></a>17.4.6.2 SHA1</h5><h5 id="17-4-6-3-SHA256"><a href="#17-4-6-3-SHA256" class="headerlink" title="17.4.6.3 SHA256"></a>17.4.6.3 SHA256</h5><h5 id="17-4-6-4-SHA384"><a href="#17-4-6-4-SHA384" class="headerlink" title="17.4.6.4 SHA384"></a>17.4.6.4 SHA384</h5><h5 id="17-4-6-5-SHA512"><a href="#17-4-6-5-SHA512" class="headerlink" title="17.4.6.5 SHA512"></a>17.4.6.5 SHA512</h5><h3 id="17-5-XPath-构造函数"><a href="#17-5-XPath-构造函数" class="headerlink" title="17.5 XPath 构造函数"></a>17.5 XPath 构造函数</h3><h3 id="17-6-可扩展值测试"><a href="#17-6-可扩展值测试" class="headerlink" title="17.6 可扩展值测试"></a>17.6 可扩展值测试</h3><h2 id="18-SPARQL-的定义"><a href="#18-SPARQL-的定义" class="headerlink" title="18 SPARQL 的定义"></a>18 SPARQL 的定义</h2><h3 id="18-1-初始定义"><a href="#18-1-初始定义" class="headerlink" title="18.1 初始定义"></a>18.1 初始定义</h3><h4 id="18-1-1-RDF-术语"><a href="#18-1-1-RDF-术语" class="headerlink" title="18.1.1 RDF 术语"></a>18.1.1 RDF 术语</h4><h4 id="18-1-2-简单文字"><a href="#18-1-2-简单文字" class="headerlink" title="18.1.2 简单文字"></a>18.1.2 简单文字</h4><h4 id="18-1-3-RDF-数据集"><a href="#18-1-3-RDF-数据集" class="headerlink" title="18.1.3 RDF 数据集"></a>18.1.3 RDF 数据集</h4><h4 id="18-1-4-查询变量"><a href="#18-1-4-查询变量" class="headerlink" title="18.1.4 查询变量"></a>18.1.4 查询变量</h4><h4 id="18-1-5-三重模式"><a href="#18-1-5-三重模式" class="headerlink" title="18.1.5 三重模式"></a>18.1.5 三重模式</h4><h4 id="18-1-6-基本图模式"><a href="#18-1-6-基本图模式" class="headerlink" title="18.1.6 基本图模式"></a>18.1.6 基本图模式</h4><h4 id="18-1-7-属性路径模式"><a href="#18-1-7-属性路径模式" class="headerlink" title="18.1.7 属性路径模式"></a>18.1.7 属性路径模式</h4><h4 id="18-1-8-解决方案映射"><a href="#18-1-8-解决方案映射" class="headerlink" title="18.1.8 解决方案映射"></a>18.1.8 解决方案映射</h4><h4 id="18-1-9-解决方案序列修饰符"><a href="#18-1-9-解决方案序列修饰符" class="headerlink" title="18.1.9 解决方案序列修饰符"></a>18.1.9 解决方案序列修饰符</h4><h4 id="18-1-10-SPARQL-查询"><a href="#18-1-10-SPARQL-查询" class="headerlink" title="18.1.10 SPARQL 查询"></a>18.1.10 SPARQL 查询</h4><h3 id="18-2-转换为-SPARQL-代数"><a href="#18-2-转换为-SPARQL-代数" class="headerlink" title="18.2 转换为 SPARQL 代数"></a>18.2 转换为 SPARQL 代数</h3><h4 id="18-2-1-变量范围"><a href="#18-2-1-变量范围" class="headerlink" title="18.2.1 变量范围"></a>18.2.1 变量范围</h4><h4 id="18-2-2-转换图形模式"><a href="#18-2-2-转换图形模式" class="headerlink" title="18.2.2 转换图形模式"></a>18.2.2 转换图形模式</h4><h5 id="18-2-2-1-扩展语法形式"><a href="#18-2-2-1-扩展语法形式" class="headerlink" title="18.2.2.1 扩展语法形式"></a>18.2.2.1 扩展语法形式</h5><h5 id="18-2-2-2-收集过滤器元素"><a href="#18-2-2-2-收集过滤器元素" class="headerlink" title="18.2.2.2 收集过滤器元素"></a>18.2.2.2 收集过滤器元素</h5><h5 id="18-2-2-3-翻译属性路径表达式"><a href="#18-2-2-3-翻译属性路径表达式" class="headerlink" title="18.2.2.3 翻译属性路径表达式"></a>18.2.2.3 翻译属性路径表达式</h5><h5 id="18-2-2-4-翻译属性路径模式"><a href="#18-2-2-4-翻译属性路径模式" class="headerlink" title="18.2.2.4 翻译属性路径模式"></a>18.2.2.4 翻译属性路径模式</h5><h5 id="18-2-2-5-转换基本图模式"><a href="#18-2-2-5-转换基本图模式" class="headerlink" title="18.2.2.5 转换基本图模式"></a>18.2.2.5 转换基本图模式</h5><h5 id="18-2-2-6-转换图模式"><a href="#18-2-2-6-转换图模式" class="headerlink" title="18.2.2.6 转换图模式"></a>18.2.2.6 转换图模式</h5><h5 id="18-2-2-7-组过滤器"><a href="#18-2-2-7-组过滤器" class="headerlink" title="18.2.2.7 组过滤器"></a>18.2.2.7 组过滤器</h5><h5 id="18-2-2-8-简化步骤"><a href="#18-2-2-8-简化步骤" class="headerlink" title="18.2.2.8 简化步骤"></a>18.2.2.8 简化步骤</h5><h4 id="18-2-3-映射图模式示例"><a href="#18-2-3-映射图模式示例" class="headerlink" title="18.2.3 映射图模式示例"></a>18.2.3 映射图模式示例</h4><h4 id="18-2-4-转换组、聚合、HAVING、最终VALUES子句和SELECT经验"><a href="#18-2-4-转换组、聚合、HAVING、最终VALUES子句和SELECT经验" class="headerlink" title="18.2.4 转换组、聚合、HAVING、最终VALUES子句和SELECT经验"></a>18.2.4 转换组、聚合、HAVING、最终VALUES子句和SELECT经验</h4><h5 id="18-2-4-1-分组和聚合"><a href="#18-2-4-1-分组和聚合" class="headerlink" title="18.2.4.1 分组和聚合"></a>18.2.4.1 分组和聚合</h5><h5 id="18-2-4-2-具有"><a href="#18-2-4-2-具有" class="headerlink" title="18.2.4.2 具有"></a>18.2.4.2 具有</h5><h5 id="18-2-4-3-值"><a href="#18-2-4-3-值" class="headerlink" title="18.2.4.3 值"></a>18.2.4.3 值</h5><h5 id="18-2-4-4-SELECT-表达式"><a href="#18-2-4-4-SELECT-表达式" class="headerlink" title="18.2.4.4 SELECT 表达式"></a>18.2.4.4 SELECT 表达式</h5><h4 id="18-2-5-转换解决方案修饰符"><a href="#18-2-5-转换解决方案修饰符" class="headerlink" title="18.2.5 转换解决方案修饰符"></a>18.2.5 转换解决方案修饰符</h4><h5 id="18-2-5-1-ORDER-BY"><a href="#18-2-5-1-ORDER-BY" class="headerlink" title="18.2.5.1 ORDER BY"></a>18.2.5.1 ORDER BY</h5><h5 id="18-2-5-2-投影"><a href="#18-2-5-2-投影" class="headerlink" title="18.2.5.2 投影"></a>18.2.5.2 投影</h5><h5 id="18-2-5-3-DISTINCT"><a href="#18-2-5-3-DISTINCT" class="headerlink" title="18.2.5.3 DISTINCT"></a>18.2.5.3 DISTINCT</h5><h5 id="18-2-5-4-减少"><a href="#18-2-5-4-减少" class="headerlink" title="18.2.5.4 减少"></a>18.2.5.4 减少</h5><h5 id="18-2-5-5-偏移和限制"><a href="#18-2-5-5-偏移和限制" class="headerlink" title="18.2.5.5 偏移和限制"></a>18.2.5.5 偏移和限制</h5><h5 id="18-2-5-6-最终代数表达式"><a href="#18-2-5-6-最终代数表达式" class="headerlink" title="18.2.5.6 最终代数表达式"></a>18.2.5.6 最终代数表达式</h5><h3 id="18-3-基本图形模式"><a href="#18-3-基本图形模式" class="headerlink" title="18.3 基本图形模式"></a>18.3 基本图形模式</h3><h4 id="18-3-1-SPARQL-基本图形模式匹配"><a href="#18-3-1-SPARQL-基本图形模式匹配" class="headerlink" title="18.3.1 SPARQL 基本图形模式匹配"></a>18.3.1 SPARQL 基本图形模式匹配</h4><h4 id="18-3-2-空白节点的处理"><a href="#18-3-2-空白节点的处理" class="headerlink" title="18.3.2 空白节点的处理"></a>18.3.2 空白节点的处理</h4><h3 id="18-4-属性路径模式"><a href="#18-4-属性路径模式" class="headerlink" title="18.4 属性路径模式"></a>18.4 属性路径模式</h3><h3 id="18-5-SPARQL-代数"><a href="#18-5-SPARQL-代数" class="headerlink" title="18.5 SPARQL 代数"></a>18.5 SPARQL 代数</h3><h4 id="18-5-1-聚合代数"><a href="#18-5-1-聚合代数" class="headerlink" title="18.5.1 聚合代数"></a>18.5.1 聚合代数</h4><h5 id="18-5-1-1-集合函数"><a href="#18-5-1-1-集合函数" class="headerlink" title="18.5.1.1 集合函数"></a>18.5.1.1 集合函数</h5><h5 id="18-5-1-2-计数"><a href="#18-5-1-2-计数" class="headerlink" title="18.5.1.2 计数"></a>18.5.1.2 计数</h5><h5 id="18-5-1-3-总和"><a href="#18-5-1-3-总和" class="headerlink" title="18.5.1.3 总和"></a>18.5.1.3 总和</h5><h5 id="18-5-1-4-平均"><a href="#18-5-1-4-平均" class="headerlink" title="18.5.1.4 平均"></a>18.5.1.4 平均</h5><h5 id="18-5-1-5-最小"><a href="#18-5-1-5-最小" class="headerlink" title="18.5.1.5 最小"></a>18.5.1.5 最小</h5><h5 id="18-5-1-6-最大"><a href="#18-5-1-6-最大" class="headerlink" title="18.5.1.6 最大"></a>18.5.1.6 最大</h5><h5 id="18-5-1-7-GroupConcat"><a href="#18-5-1-7-GroupConcat" class="headerlink" title="18.5.1.7 GroupConcat"></a>18.5.1.7 GroupConcat</h5><h5 id="18-5-1-8-样本"><a href="#18-5-1-8-样本" class="headerlink" title="18.5.1.8 样本"></a>18.5.1.8 样本</h5><h3 id="18-6-评估语义"><a href="#18-6-评估语义" class="headerlink" title="18.6 评估语义"></a>18.6 评估语义</h3><h3 id="18-7-扩展-SPARQL-基本图匹配"><a href="#18-7-扩展-SPARQL-基本图匹配" class="headerlink" title="18.7 扩展 SPARQL 基本图匹配"></a>18.7 扩展 SPARQL 基本图匹配</h3><h4 id="18-7-1-注释"><a href="#18-7-1-注释" class="headerlink" title="18.7.1 注释"></a>18.7.1 注释</h4><h2 id="19-SPARQL-语法"><a href="#19-SPARQL-语法" class="headerlink" title="19 SPARQL 语法"></a>19 SPARQL 语法</h2><h3 id="19-1-SPARQL-请求字符串"><a href="#19-1-SPARQL-请求字符串" class="headerlink" title="19.1 SPARQL 请求字符串"></a>19.1 SPARQL 请求字符串</h3><h3 id="19-2-代码点转义序列"><a href="#19-2-代码点转义序列" class="headerlink" title="19.2 代码点转义序列"></a>19.2 代码点转义序列</h3><h3 id="19-3-空白"><a href="#19-3-空白" class="headerlink" title="19.3 空白"></a>19.3 空白</h3><h3 id="19-4-注释"><a href="#19-4-注释" class="headerlink" title="19.4 注释"></a>19.4 注释</h3><h3 id="19-5-IRI-参考"><a href="#19-5-IRI-参考" class="headerlink" title="19.5 IRI 参考"></a>19.5 IRI 参考</h3><h3 id="19-6-空白节点和空白节点标签"><a href="#19-6-空白节点和空白节点标签" class="headerlink" title="19.6 空白节点和空白节点标签"></a>19.6 空白节点和空白节点标签</h3><h3 id="19-7-字符串中的转义序列"><a href="#19-7-字符串中的转义序列" class="headerlink" title="19.7 字符串中的转义序列"></a>19.7 字符串中的转义序列</h3><h3 id="19-8-语法"><a href="#19-8-语法" class="headerlink" title="19.8 语法"></a>19.8 语法</h3><h2 id="20-一致性"><a href="#20-一致性" class="headerlink" title="20 一致性"></a>20 一致性</h2><h2 id="21-安全注意事项（信息性）"><a href="#21-安全注意事项（信息性）" class="headerlink" title="21 安全注意事项（信息性）"></a>21 安全注意事项（信息性）</h2><h2 id="22-互联网媒体类型、文件扩展名和-Macintosh文件类型"><a href="#22-互联网媒体类型、文件扩展名和-Macintosh文件类型" class="headerlink" title="22 互联网媒体类型、文件扩展名和 Macintosh文件类型"></a>22 互联网媒体类型、文件扩展名和 Macintosh文件类型</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="A-参考文献"><a href="#A-参考文献" class="headerlink" title="A 参考文献"></a>A 参考文献</h3><h4 id="A-1-规范性参考文献"><a href="#A-1-规范性参考文献" class="headerlink" title="A.1 规范性参考文献"></a>A.1 规范性参考文献</h4><h4 id="A-2-其他参考文献"><a href="#A-2-其他参考文献" class="headerlink" title="A.2 其他参考文献"></a>A.2 其他参考文献</h4><hr><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>RDF 是一种有向的、标记的图形数据格式，用于表示 Web 中的信息。 RDF 通常用于表示个人信息、社交网络、有关数字工件的元数据等，以及提供一种集成不同信息源的方法。本规范定义了 RDF 的 SPARQL 查询语言的语法和语义。</p><p>RDF 的 SPARQL 查询语言旨在满足 RDF 数据访问工作组在 RDF 数据访问用例和要求 [UCNR] 和 SPARQL 新特性和基本原理 [UCNR2] 中确定的用例和要求。</p><h3 id="1-1-文件大纲"><a href="#1-1-文件大纲" class="headerlink" title="1.1 文件大纲"></a>1.1 文件大纲</h3><p>除非章节标题中另有说明，否则本文件中的所有章节和附录均为规范性的。</p><p>文档的这一部分，即第 1 节，介绍了 SPARQL 查询语言规范。它介绍了本规范文档的组织以及整个规范中使用的约定。</p><p>规范的第 2 节通过一系列示例查询和查询结果介绍了 SPARQL 查询语言本身。第 3 节继续介绍 SPARQL 查询语言，并提供更多示例来展示 SPARQL 表达对出现在查询结果中的 RDF 术语的约束的能力。</p><p>第 4 节详细介绍了 SPARQL 查询语言的语法。它是语言完整语法的伴侣，并定义了语法结构如何表示 IRI、空白节点、文字和变量。第 4 节还定义了几个语法结构的含义，这些语法结构用作更详细表达的句法糖。</p><p>第 5 节介绍了基本图模式和组图模式，它们是构建更复杂 SPARQL 查询模式的基础。第 6、7 和 8 节介绍了将 SPARQL 图模式组合成更大图模式的结构。特别是，第 6 节介绍了使查询的某些部分成为可选的能力；第 7 节介绍了表达替代图形模式的析取的能力；第 8 节介绍了测试信息缺失的模式。</p><p>第 9 节为图形模式匹配添加了属性路径，给出了查询的紧凑表示，并且还能够匹配图形中任意长度的路径。</p><p>第 10 节描述了 SPARQL 中可能的赋值形式。</p><p>第 11 节介绍了对结果进行分组和聚合的机制，可以将其合并为第 12 节中描述的子查询。</p><p>第 13 节介绍了将查询的一部分约束到特定源图的能力。第 13 节还介绍了 SPARQL 为查询定义源图的机制。</p><p>第 14 节参考了单独的文档 SPARQL 1.1 Federated Query。</p><p>第 15 节定义了通过排序、切片、投影、限制和删除一系列解决方案中的重复项来影响查询解决方案的结构。</p><p>第 16 节定义了产生不同形式结果的四种类型的 SPARQL 查询。</p><p>第 17 节定义了 SPARQL 的可扩展值测试和表达框架。它提供了可用于约束查询结果中出现的值并计算查询返回的新值的函数和运算符。</p><p>第 18 节是 SPARQL 图模式和解决方案修饰符评估的正式定义。</p><p>第 19 节包含 SPARQL 查询和 SPARQL 更新语言语法的规范定义，由 EBNF 表示法表示的语法给出。</p><h3 id="1-2-文档约定-1"><a href="#1-2-文档约定-1" class="headerlink" title="1.2 文档约定"></a>1.2 文档约定</h3><p>在本文档中，除非另有说明，否则示例假定以下命名空间前缀绑定：</p><p><img src="https://gitee.com/chaoyuan-mao/img/raw/master//image-20220604161444997.png" alt="image-20220604161444997"></p><h4 id="1-2-2-数据说明"><a href="#1-2-2-数据说明" class="headerlink" title="1.2.2 数据说明"></a>1.2.2 数据说明</h4><p>本文档使用 Turtle [TURTLE] 数据格式明确显示每个三元组。 Turtle 允许使用前缀缩写 IRI：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .</span><br><span class="line">@prefix :     &lt;http://example.org/book/&gt; .</span><br><span class="line">:book1  dc:title  &quot;SPARQL Tutorial&quot; .</span><br></pre></td></tr></table></figure><h4 id="1-2-3-结果说明"><a href="#1-2-3-结果说明" class="headerlink" title="1.2.3 结果说明"></a>1.2.3 结果说明</h4><p>结果集以表格形式显示。</p><p><img src="image/image-20220604161639223.png" alt="image-20220604161639223"></p><p>“绑定”是一对（变量，RDF 术语）。在此结果集中，存在三个变量：x、y 和 z（显示为列标题）。每个解决方案在表格正文中显示为一行。这里有一个单一的解决方案，其中变量 x 绑定到“Alice”，变量 y 绑定到<code>&lt;http://example/a&gt;</code>，变量 z 不绑定到 RDF 项。变量不需要绑定在解决方案中。</p><h4 id="1-2-4-术语-1"><a href="#1-2-4-术语-1" class="headerlink" title="1.2.4 术语"></a>1.2.4 术语</h4><p>SPARQL 语言包括 IRI，它是省略空格的 RDF URI 引用的子集。请注意，SPARQL 查询中的所有 IRI 都是绝对的；它们可能包含也可能不包含片段标识符 [RFC3987，第 3.1 节]。 IRI 包括 URI [RFC3986] 和 URL。 SPARQL 语法中的缩写形式（相对 IRI 和前缀名称）被解析为生成绝对 IRI。</p><p>以下术语在 RDF 概念和抽象语法 [CONCEPTS] 中定义并在 SPARQL 中使用：</p><ul><li>IRI (corresponds to the Concepts and Abstract Syntax term “RDF URI reference”)  RDF 图内的 URI 引用（RDF URI 引用）是一个 Unicode 字符串</li><li>literal  RDF 图中的文字包含一个或两个命名组件。</li><li>lexical form 所有文字都有一个词法形式，即 Unicode [UNICODE] 字符串，它应该是 Normal Form C [NFC]。</li><li>plain literal  普通文字具有词汇形式和可选的语言标记，如 [RFC-3066] 定义的，标准化为小写。</li><li>language tag</li><li>typed literal  类型化文字有一个词法形式和一个作为 RDF URI 引用的数据类型 URI。</li><li>datatype IRI (corresponds to the Concepts and Abstract Syntax term “datatype URI”)</li><li>blank node  RDF 图中的空白节点是从无限集合中绘制的。这组空白节点、所有 RDF URI 引用的集合和所有文字的集合是成对不相交的。否则，这组空白节点是任意的。<br>RDF 不参考空白节点的任何内部结构。给定两个空白节点，可以确定它们是否相同。</li></ul><p>此外，我们定义了以下术语：</p><ul><li>RDF Term, which includes IRIs, blank nodes and literals</li><li>Simple Literal, which covers literals without language tag or datatype IRI</li></ul><hr><h2 id="2-制作简单的查询（信息性）"><a href="#2-制作简单的查询（信息性）" class="headerlink" title="2 制作简单的查询（信息性）"></a>2 制作简单的查询（信息性）</h2><p>大多数形式的 SPARQL 查询都包含一组三元组模式，称为基本图模式。三元组模式类似于 RDF 三元组，只是主语、谓语和宾语中的每一个都可以是一个变量。基本图模式匹配 RDF 数据的子图，当来自该子图的 RDF 项可以替换变量并且结果是与子图等效的 RDF 图时。</p><h3 id="2-1-编写一个简单的查询"><a href="#2-1-编写一个简单的查询" class="headerlink" title="2.1 编写一个简单的查询"></a>2.1 编写一个简单的查询</h3><p>下面的示例显示了一个 SPARQL 查询，用于从给定的数据图中查找书名。查询由两部分组成：SELECT 子句标识要出现在查询结果中的变量，WHERE 子句提供与数据图匹配的基本图模式。此示例中的基本图形模式由一个三元组模式组成，在对象位置有一个变量 (?title)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Data:</span><br><span class="line">&lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; &quot;SPARQL Tutorial&quot; .</span><br><span class="line"></span><br><span class="line">Query:</span><br><span class="line">SELECT ?title</span><br><span class="line">WHERE</span><br><span class="line">&#123;</span><br><span class="line">  &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Query Result:</span><br><span class="line">title</span><br><span class="line">&quot;SPARQL Tutorial&quot;</span><br></pre></td></tr></table></figure><p>2.2 多重匹配</p><p>查询的结果是一个解决方案序列，对应于查询的图形模式匹配数据的方式。一个查询可能有零个、一个或多个解决方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Data:</span><br><span class="line">@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .</span><br><span class="line">_:a  foaf:name   &quot;Johnny Lee Outlaw&quot; .</span><br><span class="line">_:a  foaf:mbox   &lt;mailto:jlow@example.com&gt; .</span><br><span class="line">_:b  foaf:name   &quot;Peter Goodguy&quot; .</span><br><span class="line">_:b  foaf:mbox   &lt;mailto:peter@example.org&gt; .</span><br><span class="line">_:c  foaf:mbox   &lt;mailto:carol@example.org&gt; .</span><br><span class="line"></span><br><span class="line">Query:</span><br><span class="line">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;</span><br><span class="line">SELECT ?name ?mbox</span><br><span class="line">WHERE</span><br><span class="line">  &#123; ?x foaf:name ?name .</span><br><span class="line">    ?x foaf:mbox ?mbox &#125;</span><br><span class="line">    </span><br><span class="line">Query Result:</span><br><span class="line">namembox</span><br><span class="line">&quot;Johnny Lee Outlaw&quot;&lt;mailto:jlow@example.com&gt;</span><br><span class="line">&quot;Peter Goodguy&quot;&lt;mailto:peter@example.org&gt;</span><br></pre></td></tr></table></figure><p>每个解决方案都提供了一种方法，可以将所选变量绑定到 RDF 术语，以便查询模式与数据匹配。结果集给出了所有可能的解决方案。在上面的示例中，以下两个数据子集提供了两个匹配项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_:a foaf:name  &quot;Johnny Lee Outlaw&quot; .</span><br><span class="line">_:a foaf:box   &lt;mailto:jlow@example.com&gt; .</span><br><span class="line"></span><br><span class="line">_:b foaf:name  &quot;Peter Goodguy&quot; .</span><br><span class="line">_:b foaf:box   &lt;mailto:peter@example.org&gt; .</span><br></pre></td></tr></table></figure><p>这是一个基本的图形模式匹配；查询模式中使用的所有变量都必须在每个解决方案中绑定。</p><h3 id="2-3-匹配-RDF-文字-1"><a href="#2-3-匹配-RDF-文字-1" class="headerlink" title="2.3 匹配 RDF 文字"></a>2.3 匹配 RDF 文字</h3><p>下面的数据包含三个 RDF 文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@prefix dt:   &lt;http://example.org/datatype#&gt; .</span><br><span class="line">@prefix ns:   &lt;http://example.org/ns#&gt; .</span><br><span class="line">@prefix :     &lt;http://example.org/ns#&gt; .</span><br><span class="line">@prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt; .</span><br><span class="line"></span><br><span class="line">:x   ns:p     &quot;cat&quot;@en .</span><br><span class="line">:y   ns:p     &quot;42&quot;^^xsd:integer .</span><br><span class="line">:z   ns:p     &quot;abc&quot;^^dt:specialDatatype .</span><br></pre></td></tr></table></figure><p>请注意，在 Turtle 中，“cat”@en 是一个 RDF 文字，具有词汇形式“cat”和语言标记“en”；</p><p><code>&quot;42&quot;^^xsd:integer</code> 是数据类型为 <code>http://www.w3.org/2001/XMLSchema#integer</code> 的类型化文字； </p><p><code>&quot;abc&quot;^^dt:specialDatatype</code> 是一个类型化的文字，数据类型为 <code>http://example.org/datatype#specialDatatype</code>。</p><p>此 RDF 数据是 2.3.1-2.3.3 节中查询示例的数据图。</p><h4 id="2-3-1-用语言标签匹配文字"><a href="#2-3-1-用语言标签匹配文字" class="headerlink" title="2.3.1 用语言标签匹配文字"></a>2.3.1 用语言标签匹配文字</h4><p>SPARQL 中的语言标签使用 @ 和语言标签表示，如<a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">Best Common Practice 47</a> [<a href="https://www.w3.org/TR/sparql11-query/#BCP47">BCP47</a>] 中所定义。</p><p>以下查询没有解决方案，因为“cat”与“cat”@en 不是同一个 RDF 文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT ?v WHERE &#123; ?v ?p &quot;cat&quot; &#125;  # 无结果</span><br><span class="line">SELECT ?v WHERE &#123; ?v ?p &quot;cat&quot;@en &#125;</span><br><span class="line"></span><br><span class="line">v</span><br><span class="line">&lt;http://example.org/ns#x&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/1970/01/01/hello-world/"/>
      <url>/1970/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
